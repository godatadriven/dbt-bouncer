{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-dbt-bouncer","title":"Welcome to dbt-bouncer","text":"<p><code>dbt-bouncer</code> is an open-source tool that allows you to configure and enforce conventions for your dbt project. The conventions are run against dbt's artifact files (think <code>./target/manifest.json</code>) resulting in speedy tests. Conventions can be specified in a <code>.yml</code> file, allowing maximum customisation to the conventions you wish to follow (or create \ud83d\ude00).</p> <p>Check out our <code>Getting Started</code> guide.</p>"},{"location":"#terminology","title":"Terminology","text":"<ul> <li>Check: A check is a rule run against a dbt artifact.</li> <li>Config file: A <code>.yml</code> file that specifies which checks to run along with any parameters.</li> <li>dbt artifacts directory: The directory that contains the dbt artifacts (<code>manifest.json</code>, etc.), generally this is <code>./target</code>.</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>dbt-bouncer</code> is free software, released under the MIT license. It originated at Xebia Data in Amsterdam, Netherlands. Source code is available on GitHub.</p> <p>All contributions, in the form of bug reports, pull requests, feedback or discussion are welcome. See the contributing guide for more information.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>dbt-bouncer</code>","text":"<p><code>dbt-bouncer</code> is open source software. Whether you are a seasoned open source contributor or a first-time committer, we welcome and encourage you to contribute code, documentation, ideas, or problem statements to this project.</p>"},{"location":"CONTRIBUTING/#about-this-document","title":"About this document","text":"<p>There are many ways to contribute to the ongoing development of <code>dbt-bouncer</code>, such as by participating in discussions and issues.</p> <p>The rest of this document serves as a more granular guide for contributing code changes to <code>dbt-bouncer</code> (this repository). It is not intended as a guide for using <code>dbt-bouncer</code>, and some pieces assume a level of familiarity with Python development (virtualenvs, <code>Poetry</code>, etc). Specific code snippets in this guide assume you are using macOS or Linux and are comfortable with the command line.</p> <p>If you get stuck, we're happy to help! Just open an issue or draft PR and we'll do our best to help out.</p>"},{"location":"CONTRIBUTING/#note","title":"Note","text":"<ul> <li>Branches: All pull requests from community contributors should target the <code>main</code> branch (default).</li> </ul>"},{"location":"CONTRIBUTING/#getting-the-code","title":"Getting the code","text":""},{"location":"CONTRIBUTING/#installing-git","title":"Installing git","text":"<p>You will need <code>git</code> in order to download and modify the <code>dbt-bouncer</code> source code. On macOS, the best way to download git is to just install Xcode.</p>"},{"location":"CONTRIBUTING/#contributors","title":"Contributors","text":"<p>You can contribute to <code>dbt-bouncer</code> by forking the <code>dbt-bouncer</code> repository. For a detailed overview on forking, check out the GitHub docs on forking. In short, you will need to:</p> <ol> <li>Fork the <code>dbt-bouncer</code> repository.</li> <li>Clone your fork locally.</li> <li>Check out a new branch for your proposed changes.</li> <li>Push changes to your fork.</li> <li>Open a pull request against <code>godatadriven/dbt-bouncer</code> from your forked repository.</li> </ol>"},{"location":"CONTRIBUTING/#setting-up-an-environment","title":"Setting up an environment","text":"<p>There are some tools that will be helpful to you in developing locally. While this is the list relevant for <code>dbt-bouncer</code> development, many of these tools are used commonly across open-source python projects.</p>"},{"location":"CONTRIBUTING/#tools","title":"Tools","text":"<p>These are the tools used in <code>dbt-bouncer</code> development and testing:</p> <ul> <li><code>black</code> for code formatting.</li> <li><code>click</code> to create our CLI interface.</li> <li>GitHub Actions for automating tests and checks, once a PR is pushed to the <code>dbt-bouncer</code> repository.</li> <li><code>make</code> to run multiple setup or test steps in combination.</li> <li><code>mypy</code> for static type checking.</li> <li><code>Poetry</code> to manage our python virtual environment.</li> <li><code>pre-commit</code> to easily run those checks.</li> <li><code>Pydantic</code> to validate our configuration file.</li> <li><code>pytest</code> to define, discover, and run tests.</li> </ul> <p>A deep understanding of these tools in not required to effectively contribute to <code>dbt-bouncer</code>, but we recommend checking out the attached documentation if you're interested in learning more about each one.</p>"},{"location":"CONTRIBUTING/#virtual-environments","title":"Virtual environments","text":"<p>We strongly recommend using virtual environments when developing code in <code>dbt-bouncer</code>. We recommend creating this virtualenv in the root of the <code>dbt-bouncer</code> repository. To create a new virtualenv, run:</p> <pre><code>poetry shell\n</code></pre> <p>This will create a new Python virtual environment.</p>"},{"location":"CONTRIBUTING/#setting-environment-variables","title":"Setting environment variables","text":"<p>Set required environment variables by copying <code>.env.example</code> to <code>.env</code> and updating the values.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer-in-development","title":"Running <code>dbt-bouncer</code> in development","text":""},{"location":"CONTRIBUTING/#installation","title":"Installation","text":"<p>First make sure that you set up your <code>virtualenv</code> as described in Setting up an environment. Next, install <code>dbt-bouncer</code>, its dependencies and <code>pre-commit</code>:</p> <pre><code>poetry install\npoetry run pre-commit install\n</code></pre> <p>When installed in this way, any changes you make to your local copy of the source code will be reflected immediately in your next <code>dbt-bouncer</code> run.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer","title":"Running <code>dbt-bouncer</code>","text":"<p>With your virtualenv activated, the <code>dbt-bouncer</code> script should point back to the source code you've cloned on your machine. You can verify this by running <code>which dbt-bouncer</code>. This command should show you a path to an executable in your virtualenv. You can run <code>dbt-bouncer</code> using the provided example configuration file via:</p> <pre><code>poetry run dbt-bouncer --config-file dbt-bouncer-example.yml\n</code></pre>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Once you're able to manually test that your code change is working as expected, it's important to run existing automated tests, as well as adding some new ones. These tests will ensure that: - Your code changes do not unexpectedly break other established functionality - Your code changes can handle all known edge cases - The functionality you're adding will keep working in the future</p>"},{"location":"CONTRIBUTING/#note_1","title":"Note","text":"<ul> <li>Generating dbt artifacts: If you change the configuration of the dbt project located in <code>dbt_project</code> then you will need to re-generate the dbt artifacts used in testing. To do so, run:</li> </ul> <pre><code>make build-artifacts\n</code></pre>"},{"location":"CONTRIBUTING/#test-commands","title":"Test commands","text":"<p>There are a few methods for running tests locally.</p>"},{"location":"CONTRIBUTING/#makefile","title":"<code>makefile</code>","text":"<p>There are multiple targets in the <code>makefile</code> to run common test suites, most notably:</p> <pre><code># Runs unit tests\nmake test-unit\n\n# Runs integration tests\nmake test-integration\n\n# Runs all tests\nmake test\n</code></pre>"},{"location":"CONTRIBUTING/#pre-commit","title":"<code>pre-commit</code>","text":"<p><code>pre-commit</code> takes care of running all code-checks for formatting and linting. Run <code>poetry run pre-commit install</code> to install <code>pre-commit</code> in your local environment. Once this is done you can use the git pre-commit hooks to ensure proper formatting and linting.</p>"},{"location":"CONTRIBUTING/#pytest","title":"<code>pytest</code>","text":"<p>Finally, you can also run a specific test or group of tests using <code>pytest</code> directly. With a virtualenv active and dev dependencies installed you can do things like:</p> <pre><code># run all unit tests in a file\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py\n\n# run a specific unit test\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py::test_check_columns_are_documented_in_public_models\n</code></pre> <p>See pytest usage docs for an overview of useful command-line options.</p>"},{"location":"CONTRIBUTING/#assorted-development-tips","title":"Assorted development tips","text":"<ul> <li>Append <code># type: ignore</code> to the end of a line if you need to disable <code>mypy</code> on that line.</li> </ul>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>Code can be merged into the current development branch <code>main</code> by opening a pull request. If the proposal looks like it's on the right track, then a <code>dbt-bouncer</code> maintainer will review the PR. They may suggest code revision for style or clarity, or request that you add unit or integration test(s). These are good things! We believe that, with a little bit of help, anyone can contribute high-quality code. Once merged, your contribution will be available for the next release of <code>dbt-bouncer</code>.</p> <p>Automated tests run via GitHub Actions. If you're a first-time contributor, all tests will require a maintainer to approve.</p> <p>Once all tests are passing and your PR has been approved, a <code>dbt-bouncer</code> maintainer will merge your changes into the active development branch. And that's it! Happy developing :tada:</p>"},{"location":"cli/","title":"CLI","text":"<p>This page provides documentation for the <code>dbt-bouncer</code> CLI.</p>"},{"location":"cli/#dbt-bouncer","title":"dbt-bouncer","text":"<p>Usage:</p> <pre><code>dbt-bouncer [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --config-file PATH  Location of the YML config file.\n  --output-file PATH  Location of the json file where check metadata will be\n                      saved.\n  -v, --verbosity     Verbosity.\n  --version           Show the version and exit.\n  --help              Show this message and exit.\n</code></pre>"},{"location":"cli/#exit-codes","title":"Exit codes","text":"<p><code>dbt-bouncer</code> returns the following exit codes:</p> <ul> <li> <p><code>0</code>: All checks have succeeded.</p> </li> <li> <p><code>1</code>:</p> <ul> <li>At least one check has failed. Check the logs for more information.</li> <li>A fatal error occurred during check setup or check execution. Check the logs for more information.</li> </ul> </li> </ul>"},{"location":"config_file/","title":"Config file","text":"<p><code>dbt-bouncer</code> requires a config file which determines what checks are run. The following options are available, in order of priority:</p> <ol> <li>A file passed via the <code>--config-file</code> CLI flag.</li> <li>A file named <code>dbt-bouncer.yml</code> in the current working directory.</li> <li>A <code>[tool.dbt-bouncer]</code> section in <code>pyproject.toml</code>.</li> </ol> <p>Here is an example config file in <code>yaml</code>:</p> <pre><code># [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `./target`.\ndbt_artifacts_dir: target\n\nmanifest_checks:\n  - name: check_macro_name_matches_file_name\n  - name: check_model_names\n    include: ^staging\n    model_name_pattern: ^stg_\n</code></pre> <p>And the same config in <code>toml</code>:</p> <pre><code>[tool.dbt-bouncer]\n# [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `./target`.\ndbt_artifacts_dir = \"target\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_macro_name_matches_file_name\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_model_names\"\ninclude = \"^staging\"\nmodel_name_pattern = \"^stg_\"\n</code></pre> <p>For more example config files, see here.</p>"},{"location":"config_file/#common-arguments","title":"Common arguments","text":"<p>Most (but not all) checks accept the following optional arguments:</p> <ul> <li><code>exclude</code>: Regexp to match which paths to exclude.</li> <li><code>include</code>: Regexp to match which paths to include.</li> </ul> <p>Example per resource type:</p> <ul> <li><code>Exposures</code>: The path to the properties file where the source is defined, e.g. <code>^marts/finance</code> will match exposures defined in <code>./models/marts/finance/_exposures.yml</code>.</li> <li><code>Macros</code>: The path to the macro file, e.g. <code>^macros/system</code> will match files like <code>./macros/system/generate_schema_name.sql</code>.</li> <li><code>Models</code>: The path to the model file, e.g. <code>^marts</code> will match files like <code>./models/marts/customers.sql</code>.</li> <li><code>Run results</code>: The path to the file associated with the resource, e.g. <code>^finance/.*\\.csv$</code> will match seeds in <code>./seeds/finance</code>, <code>^staging</code> will match models and tests in <code>./models/staging</code>.</li> <li><code>Sources</code>: The path to the properties file where the source is defined, e.g. <code>^staging/crm</code> will match sources defined in <code>./models/staging/crm/_crm__sources.yml</code>.</li> <li><code>Unit tests</code>: The path to the properties file where the unit test is defined, e.g. <code>^staging/crm</code> will match unit tests defined in <code>^staging/crm/_stg_crm__unit_tests.yml</code>.</li> </ul> <p>To determine if a check accepts these arguments view the Checks page.</p> <p>Note</p> <p><code>exclude</code> and <code>include</code> can be specified at both the check level and the global level. Should both levels be specified, then the check level is applied. All the below examples result in the <code>check_model_names</code> check being run on all models in <code>./models/staging</code>:</p> <pre><code># Specify `include` at the check level only\nmanifest_checks:\n  - name: check_model_names\n    include: ^staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the check and global levels\ninclude: ^marts\nmanifest_checks:\n  - name: check_model_names\n    include: ^staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the global level only\ninclude: ^staging\nmanifest_checks:\n  - name: check_model_names\n    model_name_pattern: ^stg_\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"How to set up `dbt-bouncer` in a monorepo?      A monorepo may consist of one directory with a dbt project and other directories with unrelated code. It may be desired for `dbt-bouncer` to be configured from the root directory. Sample directory tree:      <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 dbt-project\n\u2502   \u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 dbt_project.yml\n\u2502   \u2514\u2500\u2500 profiles.yml\n\u2514\u2500\u2500 package-a\n    \u251c\u2500\u2500 src\n    \u251c\u2500\u2500 tests\n    \u2514\u2500\u2500 package.json\n</code></pre>      To ease configuration you can use `exclude` or `include` at the global level (see [Config File](./config-file.md) for more details). For the above example `dbt-bouncer.yml` could be configured as:      <pre><code>dbt_artifacts_dir: dbt-project/target\ninclude: ^dbt-project\n\nmanifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre>      `dbt-bouncer` can now be run from the root directory."},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#how-to-run-dbt-bouncer","title":"How to run <code>dbt-bouncer</code>","text":"<ol> <li> <p>Generate dbt artifacts by running a dbt command:</p> <ul> <li><code>dbt parse</code> to generate a <code>manifest.json</code> artifact.</li> <li><code>dbt docs generate</code> to generate a <code>catalog.json</code> artifact (necessary if you are using catalog checks).</li> <li><code>dbt run</code> (or any other command that implies it e.g. <code>dbt build</code>) to generate a <code>run_results.json</code> artifact (necessary if you are using run results checks).</li> </ul> </li> <li> <p>Create a <code>dbt-bouncer.yml</code> config file, details here.</p> </li> <li> <p>Run <code>dbt-bouncer</code> to validate that your conventions are being maintained.</p> </li> </ol>"},{"location":"getting_started/#python","title":"Python","text":"<p>Install from pypi.org:</p> <pre><code>pip install dbt-bouncer\n</code></pre> <p>Run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nLoaded config from dbt-bouncer-example.yml...\nValidating conf...\n</code></pre> <p><code>dbt-bouncer</code> also supports a verbose mode, run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt; -v\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nconfig_file=PosixPath('dbt-bouncer-example.yml')\nconfig_file_source='COMMANDLINE'\nConfig file passed via command line: dbt-bouncer-example.yml\nLoading config from /home/pslattery/repos/dbt-bouncer/dbt-bouncer-example.yml...\nLoading config from dbt-bouncer-example.yml...\nLoaded config from dbt-bouncer-example.yml...\nconf={'dbt_artifacts_dir': 'dbt_project/target', 'catalog_checks': [{'name': 'check_column_name_complies_to_column_type', 'column_name_pattern': '^is_.*', 'exclude': '^staging', 'types': ['BOOLEAN']}]}\nValidating conf...\n</code></pre>"},{"location":"getting_started/#github-actions","title":"GitHub Actions","text":"<p>Run <code>dbt-bouncer</code> as part of your CI pipeline: <pre><code>steps:\n    ...\n\n    - uses: godatadriven/dbt-bouncer@vX.X\n      with:\n        config-file: ./&lt;PATH_TO_CONFIG_FILE&gt;\n        output-file: results.json # optional, default does not save a results file\n        send-pr-comment: true # optional, defaults to true\n        verbose: false # optional, defaults to false\n\n    ...\n</code></pre></p> <p>We recommend pinning both a major and minor version number.</p>"},{"location":"getting_started/#docker","title":"Docker","text":"<p>Run <code>dbt-bouncer</code> via Docker:</p> <pre><code>docker run --rm \\\n    --volume \"$PWD\":/app \\\n    ghcr.io/godatadriven/dbt-bouncer:vX.X.X \\\n    --config-file /app/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#pex","title":"Pex","text":"<p>You can also run the <code>.pex</code> (Python EXecutable) artifact directly once you have a python executable (3.8 -&gt; 3.12) installed:</p> <pre><code>wget https://github.com/godatadriven/dbt-bouncer/releases/download/vX.X.X/dbt-bouncer.pex -O dbt-bouncer.pex\n\npython dbt-bouncer.pex --config-file $PWD/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"checks/","title":"Checks","text":"<p><code>dbt-bouncer</code> runs checks against artifacts from dbt. These checks fall into three categories:</p> <ul> <li>Manifest Checks</li> <li>Catalog Checks</li> <li>Run Results Checks</li> </ul>"},{"location":"checks/checks_catalog/","title":"Catalog Checks","text":"<p>Note</p> <p>The below checks require both <code>catalog.json</code> and <code>manifest.json</code> to be present.</p>"},{"location":"checks/checks_catalog/#catalog.check_catalog_sources","title":"<code>check_catalog_sources</code>","text":""},{"location":"checks/checks_catalog/#catalog.check_catalog_sources.check_source_columns_are_all_documented","title":"<code>check_source_columns_are_all_documented</code>","text":"<p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p> <p>Receives:</p> Name Type Description <code>catalog_source</code> <code>DbtBouncerCatalogNode</code> <p>The DbtBouncerCatalogNode object to check.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_source_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_catalog_sources.py</code> <pre><code>@pytest.mark.iterate_over_catalog_sources\n@bouncer_check\ndef check_source_columns_are_all_documented(\n    sources: List[DbtBouncerSource],\n    request: TopRequest,\n    catalog_source: Union[DbtBouncerCatalogNode, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    All columns in a source should be included in the source's properties file, i.e. `.yml` file.\n\n    Receives:\n        catalog_source (DbtBouncerCatalogNode): The DbtBouncerCatalogNode object to check.\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_source_columns_are_all_documented\n        ```\n    \"\"\"\n\n    source = [s for s in sources if s.unique_id == catalog_source.unique_id][0]\n    undocumented_columns = [\n        v.name for _, v in catalog_source.columns.items() if v.name not in source.columns.keys()\n    ]\n    assert (\n        not undocumented_columns\n    ), f\"`{catalog_source.unique_id}` has columns that are not included in the sources properties file: {undocumented_columns}\"\n</code></pre>"},{"location":"checks/checks_catalog/#catalog.check_columns","title":"<code>check_columns</code>","text":""},{"location":"checks/checks_catalog/#catalog.check_columns.check_column_description_populated","title":"<code>check_column_description_populated</code>","text":"<p>Columns must have a populated description.</p> <p>Receives:</p> Name Type Description <code>catalog_node</code> <code>CatalogTable</code> <p>The CatalogTable object to check.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_column_description_populated\n      include: ^marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_column_description_populated(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns must have a populated description.\n\n    Receives:\n        catalog_node (CatalogTable): The CatalogTable object to check.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_column_description_populated\n              include: ^marts\n        ```\n    \"\"\"\n\n    if catalog_node.unique_id.split(\".\")[0] == \"model\":\n        model = [m for m in models if m.unique_id == catalog_node.unique_id][0]\n        non_complying_columns = []\n        for _, v in catalog_node.columns.items():\n            if (\n                model.columns.get(v.name) is None\n                or len(model.columns[v.name].description.strip()) &lt;= 4\n            ):\n                non_complying_columns.append(v.name)\n\n        assert (\n            not non_complying_columns\n        ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that do not have a populated description: {non_complying_columns}\"\n</code></pre>"},{"location":"checks/checks_catalog/#catalog.check_columns.check_column_name_complies_to_column_type","title":"<code>check_column_name_complies_to_column_type</code>","text":"<p>Columns with specified data types must comply to the specified regexp naming pattern.</p> <p>Receives:</p> Name Type Description <code>catalog_node</code> <code>CatalogTable</code> <p>The CatalogTable object to check.</p> <code>column_name_pattern</code> <code>None</code> <p>(str): Regex pattern to match the model name.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>catalog_checks:\n    # DATE columns must end with \"_date\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: .*_date$\n      types:\n        - DATE\n</code></pre> <pre><code>catalog_checks:\n    # BOOLEAN columns must start with \"is_\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^is_.*\n      types:\n        - BOOLEAN\n</code></pre> <pre><code>catalog_checks:\n    # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^[a-z_]*$\n      types:\n        - BIGINT\n        - BOOLEAN\n        - DATE\n        - DOUBLE\n        - INTEGER\n        - VARCHAR\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_column_name_complies_to_column_type(\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    column_name_pattern: Union[None, str] = None,\n    types: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns with specified data types must comply to the specified regexp naming pattern.\n\n    Receives:\n        catalog_node (CatalogTable): The CatalogTable object to check.\n        column_name_pattern: (str): Regex pattern to match the model name.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            # DATE columns must end with \"_date\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: .*_date$\n              types:\n                - DATE\n        ```\n        ```yaml\n        catalog_checks:\n            # BOOLEAN columns must start with \"is_\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^is_.*\n              types:\n                - BOOLEAN\n        ```\n        ```yaml\n        catalog_checks:\n            # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^[a-z_]*$\n              types:\n                - BIGINT\n                - BOOLEAN\n                - DATE\n                - DOUBLE\n                - INTEGER\n                - VARCHAR\n        ```\n    \"\"\"\n\n    non_complying_columns = [\n        v.name\n        for _, v in catalog_node.columns.items()\n        if v.type in types and re.compile(column_name_pattern.strip()).match(v.name) is None  # type: ignore[operator]\n    ]\n\n    assert (\n        not non_complying_columns\n    ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that don't comply with the specified regexp pattern (`{column_name_pattern}`): {non_complying_columns}\"\n</code></pre>"},{"location":"checks/checks_catalog/#catalog.check_columns.check_columns_are_all_documented","title":"<code>check_columns_are_all_documented</code>","text":"<p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> <p>Receives:</p> Name Type Description <code>catalog_node</code> <code>CatalogTable</code> <p>The CatalogTable object to check.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_columns_are_all_documented(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    All columns in a model should be included in the model's properties file, i.e. `.yml` file.\n\n    Receives:\n        catalog_node (CatalogTable): The CatalogTable object to check.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_all_documented\n        ```\n    \"\"\"\n\n    if catalog_node.unique_id.split(\".\")[0] == \"model\":\n        model = [m for m in models if m.unique_id == catalog_node.unique_id][0]\n        undocumented_columns = [\n            v.name for _, v in catalog_node.columns.items() if v.name not in model.columns.keys()\n        ]\n        assert (\n            not undocumented_columns\n        ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that are not included in the models properties file: {undocumented_columns}\"\n</code></pre>"},{"location":"checks/checks_catalog/#catalog.check_columns.check_columns_are_documented_in_public_models","title":"<code>check_columns_are_documented_in_public_models</code>","text":"<p>Columns should have a populated description in public models.</p> <p>Receives:</p> Name Type Description <code>catalog_node</code> <code>CatalogTable</code> <p>The CatalogTable object to check.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_documented_in_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_columns_are_documented_in_public_models(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns should have a populated description in public models.\n\n    Receives:\n        catalog_node (CatalogTable): The CatalogTable object to check.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_documented_in_public_models\n        ```\n    \"\"\"\n\n    if catalog_node.unique_id.split(\".\")[0] == \"model\":\n        model = [m for m in models if m.unique_id == catalog_node.unique_id][0]\n        non_complying_columns = []\n        for k, v in catalog_node.columns.items():\n            if model.access.value == \"public\":\n                column_config = model.columns.get(v.name)\n                if column_config is None or len(column_config.description.strip()) &lt; 4:\n                    non_complying_columns.append(v.name)\n\n        assert (\n            not non_complying_columns\n        ), f\"`{catalog_node.unique_id.split('.')[-1]}` is a public model but has columns that don't have a populated description: {non_complying_columns}\"\n</code></pre>"},{"location":"checks/checks_catalog/#catalog.check_columns.check_column_has_specified_test","title":"<code>check_column_has_specified_test</code>","text":"<p>Columns that match the specified regexp pattern must have a specified test.</p> <p>Receives:</p> Name Type Description <code>catalog_node</code> <code>CatalogTable</code> <p>The CatalogTable object to check.</p> <code>column_name_pattern</code> <code>str</code> <p>Regex pattern to match the column name.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>test_name</code> <code>str</code> <p>Name of the test to check for.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_column_has_specified_test\n      column_name_pattern: ^is_.*\n      test_name: not_null\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_column_has_specified_test(\n    request: TopRequest,\n    tests: List[DbtBouncerTest],\n    catalog_node: Union[CatalogTable, None] = None,\n    column_name_pattern: Union[None, str] = None,\n    test_name: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns that match the specified regexp pattern must have a specified test.\n\n    Receives:\n        catalog_node (CatalogTable): The CatalogTable object to check.\n        column_name_pattern (str): Regex pattern to match the column name.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        test_name (str): Name of the test to check for.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_column_has_specified_test\n              column_name_pattern: ^is_.*\n              test_name: not_null\n        ```\n    \"\"\"\n\n    columns_to_check = [\n        v.name\n        for _, v in catalog_node.columns.items()\n        if re.compile(column_name_pattern.strip()).match(v.name) is not None\n    ]\n    relevant_tests = [\n        t\n        for t in tests\n        if t.test_metadata.name == test_name and t.attached_node == catalog_node.unique_id\n    ]\n    non_complying_columns = [\n        c\n        for c in columns_to_check\n        if f\"{catalog_node.unique_id}.{c}\"\n        not in [f\"{t.attached_node}.{t.column_name}\" for t in relevant_tests]\n    ]\n\n    assert (\n        not non_complying_columns\n    ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that should have a `{test_name}` test: {non_complying_columns}\"\n</code></pre>"},{"location":"checks/checks_manifest/","title":"Manifest Checks","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p>"},{"location":"checks/checks_manifest/#manifest.check_exposures","title":"<code>check_exposures</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_exposures.check_exposure_based_on_non_public_models","title":"<code>check_exposure_based_on_non_public_models</code>","text":"<p>Exposures should be based on public models only.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>exposure</code> <code>Exposures</code> <p>The Exposures object to check.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>@pytest.mark.iterate_over_exposures\n@bouncer_check\ndef check_exposure_based_on_non_public_models(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    exposure: Union[Exposures, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Exposures should be based on public models only.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        exposure (Exposures): The Exposures object to check.\n        include (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_non_public_models\n        ```\n    \"\"\"\n\n    non_public_upstream_dependencies = []\n    for model in exposure.depends_on.nodes:\n        if model.split(\".\")[0] == \"model\" and model.split(\".\")[1] == exposure.package_name:\n            model = [m for m in models if m.unique_id == model][0]\n            if model.access.value != \"public\":\n                non_public_upstream_dependencies.append(model.name)\n\n    assert (\n        not non_public_upstream_dependencies\n    ), f\"`{exposure.name}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_exposures.check_exposure_based_on_view","title":"<code>check_exposure_based_on_view</code>","text":"<p>Exposures should not be based on views.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>exposure</code> <code>Exposures</code> <p>The Exposures object to check.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>materializations_to_include</code> <code>Optional[List[str]]</code> <p>List of materializations to include in the check. If not provided, defaults to <code>ephemeral</code> and <code>view</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n</code></pre> <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>@pytest.mark.iterate_over_exposures\n@bouncer_check\ndef check_exposure_based_on_view(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    exposure: Union[Exposures, None] = None,\n    materializations_to_include: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Exposures should not be based on views.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        exposure (Exposures): The Exposures object to check.\n        include (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        materializations_to_include (Optional[List[str]]): List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n        ```\n    \"\"\"\n\n    non_table_upstream_dependencies = []\n    for model in exposure.depends_on.nodes:\n        if model.split(\".\")[0] == \"model\" and model.split(\".\")[1] == exposure.package_name:\n            model = [m for m in models if m.unique_id == model][0]\n            if model.config.materialized in materializations_to_include:  # type: ignore[operator]\n                non_table_upstream_dependencies.append(model.name)\n\n    assert (\n        not non_table_upstream_dependencies\n    ), f\"`{exposure.name}` is based on a model that is not a table: {non_table_upstream_dependencies}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_lineage","title":"<code>check_lineage</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_lineage.check_lineage_permitted_upstream_models","title":"<code>check_lineage_permitted_upstream_models</code>","text":"<p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <code>upstream_path_pattern</code> <code>str</code> <p>Regexp pattern to match the upstream model(s) path.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_permitted_upstream_models\n      include: ^staging\n      upstream_path_pattern: $^\n    - name: check_lineage_permitted_upstream_models\n      include: ^intermediate\n      upstream_path_pattern: ^staging|^intermediate\n    - name: check_lineage_permitted_upstream_models\n      include: ^marts\n      upstream_path_pattern: ^staging|^intermediate\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_permitted_upstream_models(\n    manifest_obj: DbtBouncerManifest,\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    upstream_path_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Upstream models must have a path that matches the provided `upstream_path_pattern`.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n        upstream_path_pattern (str): Regexp pattern to match the upstream model(s) path.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_permitted_upstream_models\n              include: ^staging\n              upstream_path_pattern: $^\n            - name: check_lineage_permitted_upstream_models\n              include: ^intermediate\n              upstream_path_pattern: ^staging|^intermediate\n            - name: check_lineage_permitted_upstream_models\n              include: ^marts\n              upstream_path_pattern: ^staging|^intermediate\n        ```\n    \"\"\"\n\n    upstream_models = [\n        x\n        for x in model.depends_on.nodes\n        if x.split(\".\")[0] == \"model\"\n        and x.split(\".\")[1] == manifest_obj.manifest.metadata.project_name\n    ]\n    not_permitted_upstream_models = [\n        upstream_model\n        for upstream_model in upstream_models\n        if re.compile(upstream_path_pattern.strip()).match(\n            [m for m in models if m.unique_id == upstream_model][0].path\n        )\n        is None\n    ]\n    assert (\n        not not_permitted_upstream_models\n    ), f\"`{model.name}` references upstream models that are not permitted: {[m.split('.')[-1] for m in not_permitted_upstream_models]}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_lineage.check_lineage_seed_cannot_be_used","title":"<code>check_lineage_seed_cannot_be_used</code>","text":"<p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_seed_cannot_be_used\n      include: ^intermediate|^marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_seed_cannot_be_used(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Seed cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_seed_cannot_be_used\n              include: ^intermediate|^marts\n        ```\n    \"\"\"\n\n    assert not [\n        x for x in model.depends_on.nodes if x.split(\".\")[0] == \"seed\"\n    ], f\"`{model.name}` references a seed even though this is not permitted.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_lineage.check_lineage_source_cannot_be_used","title":"<code>check_lineage_source_cannot_be_used</code>","text":"<p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_source_cannot_be_used\n      include: ^intermediate|^marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_source_cannot_be_used(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_source_cannot_be_used\n              include: ^intermediate|^marts\n        ```\n    \"\"\"\n\n    assert not [\n        x for x in model.depends_on.nodes if x.split(\".\")[0] == \"source\"\n    ], f\"`{model.name}` references a source even though this is not permitted.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros","title":"<code>check_macros</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_arguments_description_populated","title":"<code>check_macro_arguments_description_populated</code>","text":"<p>Macro arguments must have a populated description.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_arguments_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have their arguments populated\nmanifest_checks:\n    - name: check_macro_arguments_description_populated\n      include: ^macros/common\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_arguments_description_populated(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macro arguments must have a populated description.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have their arguments populated\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n              include: ^macros/common\n        ```\n    \"\"\"\n\n    environment = jinja2.Environment(extensions=[TagExtension])\n    ast = environment.parse(macro.macro_sql)\n\n    # Assume macro is a \"true\" macro, if not see if it's a generic test\n    try:\n        macro_arguments = [a.name for a in ast.body[0].args]  # type: ignore[attr-defined]\n    except AttributeError:\n        test_macro = [x for x in ast.body if not isinstance(x.nodes[0], jinja2.nodes.Call)][0]  # type: ignore[attr-defined]\n        macro_arguments = [x.name for x in test_macro.nodes if isinstance(x, jinja2.nodes.Name)]  # type: ignore[attr-defined]\n\n    # macro_arguments: List of args parsed from macro SQL\n    # macro.arguments: List of args manually added to the properties file\n\n    non_complying_args = []\n    for arg in macro_arguments:\n        macro_doc_raw = [x for x in macro.arguments if x.name == arg]\n        if macro_doc_raw == []:\n            non_complying_args.append(arg)\n        elif (\n            arg not in [x.name for x in macro.arguments]\n            or len(macro_doc_raw[0].description.strip()) &lt;= 4\n        ):\n            non_complying_args.append(arg)\n\n    assert (\n        non_complying_args == []\n    ), f\"Macro `{macro.name}` does not have a populated description for the following argument(s): {non_complying_args}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_code_does_not_contain_regexp_pattern","title":"<code>check_macro_code_does_not_contain_regexp_pattern</code>","text":"<p>The raw code for a macro must not match the specified regexp pattern.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the macro code.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n    - name: check_macro_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_code_does_not_contain_regexp_pattern(\n    request: TopRequest,\n    macro: Union[Macros, None] = None,\n    regexp_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"The raw code for a macro must not match the specified regexp pattern.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n        regexp_pattern (str): The regexp pattern that should not be matched by the macro code.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n            - name: check_macro_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n    \"\"\"\n\n    assert (\n        re.compile(regexp_pattern.strip(), flags=re.DOTALL).match(macro.macro_sql) is None\n    ), f\"Macro `{macro.name}` contains a banned string: `{regexp_pattern.strip()}`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_description_populated","title":"<code>check_macro_description_populated</code>","text":"<p>Macros must have a populated description.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have a populated description\nmanifest_checks:\n    - name: check_macro_description_populated\n      include: ^macros/common\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_description_populated(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macros must have a populated description.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have a populated description\n        manifest_checks:\n            - name: check_macro_description_populated\n              include: ^macros/common\n        ```\n    \"\"\"\n\n    assert (\n        len(macro.description.strip()) &gt; 4\n    ), f\"Macro `{macro.name}` does not have a populated description.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_max_number_of_lines","title":"<code>check_macro_max_number_of_lines</code>","text":"<p>Macros may not have more than the specified number of lines.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines. Default: 50.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n      max_number_of_lines: 100\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_max_number_of_lines(\n    request: TopRequest,\n    macro: Union[Macros, None] = None,\n    max_number_of_lines: Union[int, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Macros may not have more than the specified number of lines.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n        max_number_of_lines (int): The maximum number of permitted lines. Default: 50.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n              max_number_of_lines: 100\n        ```\n    \"\"\"\n\n    actual_number_of_lines = macro.macro_sql.count(\"\\n\") + 1\n\n    assert (\n        actual_number_of_lines &lt;= max_number_of_lines\n    ), f\"Macro `{macro.name}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({max_number_of_lines}).\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_name_matches_file_name","title":"<code>check_macro_name_matches_file_name</code>","text":"<p>Macros names must be the same as the file they are contained in.</p> <p>Generic tests are also macros, however to document these tests the \"name\" value must be precededed with \"test_\".</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_name_matches_file_name\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_name_matches_file_name(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macros names must be the same as the file they are contained in.\n\n    Generic tests are also macros, however to document these tests the \"name\" value must be precededed with \"test_\".\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_name_matches_file_name\n        ```\n    \"\"\"\n\n    if macro.name.startswith(\"test_\"):\n        assert (\n            macro.name[5:] == macro.path.split(\"/\")[-1].split(\".\")[0]\n        ), f\"Macro `{macro.unique_id}` is not in a file named `{macro.name[5:]}.sql`.\"\n    else:\n        assert (\n            macro.name == macro.path.split(\"/\")[-1].split(\".\")[0]\n        ), f\"Macro `{macro.name}` is not in a file of the same name.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_macros.check_macro_property_file_location","title":"<code>check_macro_property_file_location</code>","text":"<p>Macro properties files must follow the guidance provided by dbt here.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_property_file_location(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macro properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/5-the-rest-of-the-project#how-we-use-the-other-folders).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        macro (Macros): The Macros object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_property_file_location\n        ```\n    \"\"\"\n\n    expected_substr = \"_\".join(macro.path[6:].split(\"/\")[:-1])\n    properties_yml_name = macro.patch_path.split(\"/\")[-1]\n\n    if macro.path.startswith(\"tests/\"):  # Do not check generic tests (which are also macros)\n        pass\n    elif expected_substr == \"\":  # i.e. macro in ./macros\n        assert (\n            properties_yml_name == \"_macros.yml\"\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) should be `_macros.yml`.\"\n    else:\n        assert properties_yml_name.startswith(\n            \"_\"\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n        assert (\n            expected_substr in properties_yml_name\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n        assert properties_yml_name.endswith(\n            \"__macros.yml\"\n        ), f\"The properties file for `{macro.name.name}` (`{properties_yml_name}`) does not end with `__macros.yml`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_metadata","title":"<code>check_metadata</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_metadata.check_project_name","title":"<code>check_project_name</code>","text":"<p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p> <p>Receives:</p> Type Description <code>None</code> <p>project_name_pattern str: Regex pattern to match the project name.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_project_name\n      project_name_pattern: ^awesome_company_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_metadata.py</code> <pre><code>@bouncer_check\ndef check_project_name(\n    manifest_obj: DbtBouncerManifest,\n    request: TopRequest,\n    project_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  `company_&lt;DOMAIN&gt;`.\n\n    Receives:\n        project_name_pattern str: Regex pattern to match the project name.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_project_name\n              project_name_pattern: ^awesome_company_\n        ```\n    \"\"\"\n\n    assert (\n        re.compile(project_name_pattern.strip()).match(manifest_obj.manifest.metadata.project_name)\n        is not None\n    ), f\"Project name (`{manifest_obj.manifest.metadata.project_name}`) does not conform to the supplied regex `({project_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models","title":"<code>check_models</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_models.check_model_access","title":"<code>check_model_access</code>","text":"<p>Models must have the specified access attribute. Requires dbt 1.7+.</p> <p>Receives:</p> Name Type Description <code>access</code> <code>Literal['private', 'protected', 'public']</code> <p>The access level to check for.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n    - name: check_model_access\n      access: protected\n      include: ^intermediate\n    - name: check_model_access\n      access: public\n      include: ^marts\n    - name: check_model_access\n      access: protected\n      include: ^staging\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_access(\n    request: TopRequest,\n    access: Union[None, str] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have the specified access attribute. Requires dbt 1.7+.\n\n    Receives:\n        access (Literal[\"private\", \"protected\", \"public\"]): The access level to check for.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n            - name: check_model_access\n              access: protected\n              include: ^intermediate\n            - name: check_model_access\n              access: public\n              include: ^marts\n            - name: check_model_access\n              access: protected\n              include: ^staging\n        ```\n    \"\"\"\n\n    assert (\n        model.access.value == access\n    ), f\"`{model.name}` has `{model.access.value}` access, it should have access `{access}`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_contract_enforced_for_public_model","title":"<code>check_model_contract_enforced_for_public_model</code>","text":"<p>Public models must have contracts enforced.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_contract_enforced_for_public_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_contract_enforced_for_public_model(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Public models must have contracts enforced.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_contract_enforced_for_public_model\n        ```\n    \"\"\"\n\n    if model.access.value == \"public\":\n        assert (\n            model.contract.enforced is True\n        ), f\"`{model.name}` is a public model but does not have contracts enforced.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_description_populated","title":"<code>check_model_description_populated</code>","text":"<p>Models must have a populated description.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_description_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_description_populated(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models must have a populated description.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_populated\n        ```\n    \"\"\"\n\n    assert (\n        len(model.description.strip()) &gt; 4\n    ), f\"`{model.name}` does not have a populated description.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_documentation_coverage","title":"<code>check_model_documentation_coverage</code>","text":"<p>Set the minimum percentage of models that have a populated description.</p> <p>Receives:</p> Name Type Description <code>min_model_documentation_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have a populated description. Default: 100.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_description_populated\n      min_model_documentation_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@bouncer_check\ndef check_model_documentation_coverage(\n    request: TopRequest,\n    models: List[DbtBouncerModel],\n    min_model_documentation_coverage_pct: Union[float, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Set the minimum percentage of models that have a populated description.\n\n    Receives:\n        min_model_documentation_coverage_pct (float): The minimum percentage of models that must have a populated description. Default: 100.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_populated\n              min_model_documentation_coverage_pct: 90\n        ```\n    \"\"\"\n\n    num_models = len(models)\n    models_with_description = []\n    for model in models:\n        if len(model.description.strip()) &gt; 4:\n            models_with_description.append(model.unique_id)\n\n    num_models_with_descriptions = len(models_with_description)\n    model_description_coverage_pct = (num_models_with_descriptions / num_models) * 100\n\n    assert (\n        model_description_coverage_pct &gt;= min_model_documentation_coverage_pct  # type: ignore[operator]\n    ), f\"Only {model_description_coverage_pct}% of models have a populated description, this is less than the permitted minimum of {min_model_documentation_coverage_pct}%.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_documented_in_same_directory","title":"<code>check_model_documented_in_same_directory</code>","text":"<p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_documented_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_documented_in_same_directory(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models must be documented in the same directory where they are defined (i.e. `.yml` and `.sql` files are in the same directory).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_documented_in_same_directory\n        ```\n    \"\"\"\n\n    model_doc_dir = model.patch_path[model.patch_path.find(\"models\") :].split(\"/\")[1:-1]\n    model_sql_dir = model.path.split(\"/\")[:-1]\n\n    assert (\n        model_doc_dir == model_sql_dir\n    ), f\"`{model.name}` is documented in a different directory to the `.sql` file: `{'/'.join(model_doc_dir)}` vs `{'/'.join(model_sql_dir)}`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_code_does_not_contain_regexp_pattern","title":"<code>check_model_code_does_not_contain_regexp_pattern</code>","text":"<p>The raw code for a model must not match the specified regexp pattern.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the model code.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n    - name: check_model_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_code_does_not_contain_regexp_pattern(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    regexp_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The raw code for a model must not match the specified regexp pattern.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n        regexp_pattern (str): The regexp pattern that should not be matched by the model code.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n            - name: check_model_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n    \"\"\"\n\n    assert (\n        re.compile(regexp_pattern.strip(), flags=re.DOTALL).match(model.raw_code) is None\n    ), f\"`{model.name}` contains a banned string: `{regexp_pattern.strip()}`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_depends_on_multiple_sources","title":"<code>check_model_depends_on_multiple_sources</code>","text":"<p>Models cannot reference more than one source.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_depends_on_multiple_sources\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_depends_on_multiple_sources(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models cannot reference more than one source.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_depends_on_multiple_sources\n        ```\n    \"\"\"\n\n    num_reffed_sources = sum(x.split(\".\")[0] == \"source\" for x in model.depends_on.nodes)\n    assert num_reffed_sources &lt;= 1, f\"`{model.name}` references more than one source.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_directories","title":"<code>check_model_directories</code>","text":"<p>Only specified sub-directories are permitted.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked. Special case: if you want to check <code>./models</code>, pass \"\" to <code>include</code>.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <code>permitted_sub_directories</code> <code>List[str]</code> <p>List of permitted sub-directories.</p> <p>Example(s):     <pre><code>manifest_checks:\n# Special case for top level directories within `./models`, pass \"\" to `include`\n- name: check_model_directories\n    include: \"\"\n    permitted_sub_directories:\n    - intermediate\n    - marts\n    - staging\n</code></pre> <pre><code># Restrict sub-directories within `./models/staging`\n- name: check_model_directories\n    include: ^staging\n    permitted_sub_directories:\n    - crm\n    - payments\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_directories(\n    request: TopRequest,\n    include: Union[None, str] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    permitted_sub_directories: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Only specified sub-directories are permitted.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked. Special case: if you want to check `./models`, pass \"\" to `include`.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n        permitted_sub_directories (List[str]): List of permitted sub-directories.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n        # Special case for top level directories within `./models`, pass \"\" to `include`\n        - name: check_model_directories\n            include: \"\"\n            permitted_sub_directories:\n            - intermediate\n            - marts\n            - staging\n        ```\n        ```yaml\n        # Restrict sub-directories within `./models/staging`\n        - name: check_model_directories\n            include: ^staging\n            permitted_sub_directories:\n            - crm\n            - payments\n        ```\n    \"\"\"\n\n    # Special case for `models` directory\n    if include == \"\":\n        assert (\n            model.path.split(\"/\")[0] in permitted_sub_directories  # type: ignore[operator]\n        ), f\"`{model.name}` is located in `{model.path.split('/')[0]}`, this is not a valid sub-directory.\"\n    else:\n        matched_path = re.compile(include.strip()).match(model.path)\n        path_after_match = model.path[matched_path.end() + 1 :]  # type: ignore[union-attr]\n\n        assert (\n            path_after_match.split(\"/\")[0] in permitted_sub_directories  # type: ignore[operator]\n        ), f\"`{model.name}` is located in `{model.path.split('/')[0]}`, this is not a valid sub-directory.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_contracts_enforced","title":"<code>check_model_has_contracts_enforced</code>","text":"<p>Model must have contracts enforced.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_contracts_enforced\n        include: ^marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_contracts_enforced(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Model must have contracts enforced.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_contracts_enforced\n                include: ^marts\n        ```\n    \"\"\"\n\n    assert model.contract.enforced is True, f\"`{model.name}` does not have contracts enforced.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_meta_keys","title":"<code>check_model_has_meta_keys</code>","text":"<p>The <code>meta</code> config for models must have the specified keys.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_meta_keys\n      keys:\n        - maturity\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_meta_keys(\n    request: TopRequest,\n    keys: Union[NestedDict, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The `meta` config for models must have the specified keys.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_meta_keys\n              keys:\n                - maturity\n                - owner\n        ```\n    \"\"\"\n\n    missing_keys = find_missing_meta_keys(\n        meta_config=model.meta,\n        required_keys=keys.model_dump(),\n    )\n    assert (\n        missing_keys == []\n    ), f\"`{model.name}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_no_upstream_dependencies","title":"<code>check_model_has_no_upstream_dependencies</code>","text":"<p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_no_upstream_dependencies\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_no_upstream_dependencies(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_no_upstream_dependencies\n        ```\n    \"\"\"\n\n    assert (\n        len(model.depends_on.nodes) &gt; 0\n    ), f\"`{model.name}` has no upstream dependencies, this likely indicates hard-coded tables references.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_tags","title":"<code>check_model_has_tags</code>","text":"<p>Models must have the specified tags.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <code>tags</code> <code>List[str]</code> <p>List of tags to check for.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_tags(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    tags: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have the specified tags.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n        tags (List[str]): List of tags to check for.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n    \"\"\"\n\n    missing_tags = [tag for tag in tags if tag not in model.tags]\n    assert not missing_tags, f\"`{model.name}` is missing required tags: {missing_tags}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_unique_test","title":"<code>check_model_has_unique_test</code>","text":"<p>Models must have a test for uniqueness of a column.</p> <p>Receives:</p> Name Type Description <code>accepted_uniqueness_tests</code> <code>Optional[List[str]]</code> <p>List of tests that are accepted as uniqueness tests. If not provided, defaults to <code>expect_compound_columns_to_be_unique</code>, <code>dbt_utils.unique_combination_of_columns</code> and <code>unique</code>.</p> <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n  - name: check_model_has_unique_test\n    include: ^fct_|^dim_\n</code></pre> <pre><code>manifest_checks:\n  # Example of allowing a custom uniqueness test\n  - name: check_model_has_unique_test\n    accepted_uniqueness_tests:\n        - expect_compound_columns_to_be_unique\n        - my_custom_uniqueness_test\n        - unique\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_unique_test(\n    request: TopRequest,\n    tests: List[DbtBouncerModel],\n    accepted_uniqueness_tests: Union[List[str], None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have a test for uniqueness of a column.\n\n    Receives:\n        accepted_uniqueness_tests (Optional[List[str]]): List of tests that are accepted as uniqueness tests. If not provided, defaults to `expect_compound_columns_to_be_unique`, `dbt_utils.unique_combination_of_columns` and `unique`.\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n          - name: check_model_has_unique_test\n            include: ^fct_|^dim_\n        ```\n        ```yaml\n        manifest_checks:\n          # Example of allowing a custom uniqueness test\n          - name: check_model_has_unique_test\n            accepted_uniqueness_tests:\n                - expect_compound_columns_to_be_unique\n                - my_custom_uniqueness_test\n                - unique\n        ```\n    \"\"\"\n\n    num_unique_tests = sum(\n        test.attached_node == model.unique_id\n        and test.test_metadata.name in accepted_uniqueness_tests  # type: ignore[operator]\n        for test in tests\n    )\n    assert (\n        num_unique_tests &gt;= 1\n    ), f\"`{model.name}` does not have a test for uniqueness of a column.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_has_unit_tests","title":"<code>check_model_has_unit_tests</code>","text":"<p>Models must have more than the specified number of unit tests.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>min_number_of_unit_tests</code> <code>Optional[int]</code> <p>The minimum number of unit tests that a model must have. Default: 1.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      include: ^marts\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      min_number_of_unit_tests: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_unit_tests(\n    manifest_obj: DbtBouncerManifest,\n    request: TopRequest,\n    unit_tests: List[UnitTests],\n    min_number_of_unit_tests: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have more than the specified number of unit tests.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        min_number_of_unit_tests (Optional[int]): The minimum number of unit tests that a model must have. Default: 1.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              include: ^marts\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              min_number_of_unit_tests: 2\n        ```\n    \"\"\"\n\n    if semver.Version.parse(manifest_obj.manifest.metadata.dbt_version) &gt;= \"1.8.0\":\n        num_unit_tests = len(\n            [t.unique_id for t in unit_tests if t.depends_on.nodes[0] == model.unique_id]\n        )\n        assert (\n            num_unit_tests &gt;= min_number_of_unit_tests  # type: ignore[operator]\n        ), f\"`{model.name}` has {num_unit_tests} unit tests, this is less than the minimum of {min_number_of_unit_tests}.\"\n    else:\n        logging.warning(\n            \"The `check_model_has_unit_tests` check is only supported for dbt 1.8.0 and above.\"\n        )\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_max_chained_views","title":"<code>check_model_max_chained_views</code>","text":"<p>Models cannot have more than the specified number of upstream dependents that are not tables (default: 3).</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materializations_to_include</code> <code>Optional[List[str]]</code> <p>List of materializations to include in the check. If not provided, defaults to <code>ephemeral</code> and <code>view</code>.</p> <code>max_chained_views</code> <code>Optional[int]</code> <p>The maximum number of upstream dependents that are not tables. Default: 3</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n      max_chained_views: 5\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_chained_views(\n    manifest_obj: DbtBouncerManifest,\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    materializations_to_include: Union[List[str], None] = None,\n    max_chained_views: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models cannot have more than the specified number of upstream dependents that are not tables (default: 3).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materializations_to_include (Optional[List[str]]): List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.\n        max_chained_views (Optional[int]): The maximum number of upstream dependents that are not tables. Default: 3\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n              max_chained_views: 5\n        ```\n    \"\"\"\n\n    def return_upstream_view_models(\n        materializations,\n        max_chained_views,\n        models,\n        model_unique_ids_to_check,\n        package_name,\n        depth=0,\n    ):\n        \"\"\"\n        Recursive function to return model unique_id's of upstream models that are views. Depth of recursion can be specified. If no models meet the criteria then an empty list is returned.\n        \"\"\"\n\n        if depth == max_chained_views or model_unique_ids_to_check == []:\n            return model_unique_ids_to_check\n\n        relevant_upstream_models = []\n        for model in model_unique_ids_to_check:\n            upstream_nodes = list(\n                [m2 for m2 in models if m2.unique_id == model][0].depends_on.nodes\n            )\n            if upstream_nodes != []:\n                upstream_models = [\n                    m\n                    for m in upstream_nodes\n                    if m.split(\".\")[0] == \"model\" and m.split(\".\")[1] == package_name\n                ]\n                for i in upstream_models:\n                    if [m for m in models if m.unique_id == i][\n                        0\n                    ].config.materialized in materializations:\n                        relevant_upstream_models.append(i)\n\n        depth += 1\n        return return_upstream_view_models(\n            materializations=materializations,\n            max_chained_views=max_chained_views,\n            models=models,\n            model_unique_ids_to_check=relevant_upstream_models,\n            package_name=package_name,\n            depth=depth,\n        )\n\n    assert (\n        len(\n            return_upstream_view_models(\n                materializations=materializations_to_include,\n                max_chained_views=max_chained_views,\n                models=models,\n                model_unique_ids_to_check=[model.unique_id],\n                package_name=manifest_obj.manifest.metadata.project_name,\n            )\n        )\n        == 0\n    ), f\"`{model.name}` has more than {max_chained_views} upstream dependents that are not tables.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_max_fanout","title":"<code>check_model_max_fanout</code>","text":"<p>Models cannot have more than the specified number of downstream models (default: 3).</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>max_downstream_models</code> <code>Optional[int]</code> <p>The maximum number of permitted downstream models. Default: 3</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_fanout\n      max_downstream_models: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_fanout(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    max_downstream_models: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models cannot have more than the specified number of downstream models (default: 3).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        max_downstream_models (Optional[int]): The maximum number of permitted downstream models. Default: 3\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_fanout\n              max_downstream_models: 2\n        ```\n    \"\"\"\n\n    num_downstream_models = sum(model.unique_id in m.depends_on.nodes for m in models)\n\n    assert (\n        num_downstream_models &lt;= max_downstream_models  # type: ignore[operator]\n    ), f\"`{model.name}` has {num_downstream_models} downstream models, which is more than the permitted maximum of {max_downstream_models}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_max_number_of_lines","title":"<code>check_model_max_number_of_lines</code>","text":"<p>Models may not have more than the specified number of lines.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern</p> <code>None</code> <p>will be checked.</p> <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines. Default: 100.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n      max_number_of_lines: 150\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_number_of_lines(\n    request: TopRequest,\n    max_number_of_lines: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models may not have more than the specified number of lines.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern\n        will be checked.\n        max_number_of_lines (int): The maximum number of permitted lines. Default: 100.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n              max_number_of_lines: 150\n        ```\n    \"\"\"\n\n    actual_number_of_lines = model.raw_code.count(\"\\n\") + 1\n\n    assert (\n        actual_number_of_lines &lt;= max_number_of_lines\n    ), f\"`{model.name}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({max_number_of_lines}).\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_max_upstream_dependencies","title":"<code>check_model_max_upstream_dependencies</code>","text":"<p>Limit the number of upstream dependencies a model has. Default values are 5 for models, 5 for macros, and 1 for sources.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>max_upstream_macros</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream macros. Default: 5</p> <code>max_upstream_models</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream models. Default: 5</p> <code>max_upstream_sources</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream sources. Default: 1</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_upstream_dependencies\n      max_upstream_models: 3\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_upstream_dependencies(\n    request: TopRequest,\n    max_upstream_macros: Union[int, None] = None,\n    max_upstream_models: Union[int, None] = None,\n    max_upstream_sources: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Limit the number of upstream dependencies a model has. Default values are 5 for models, 5 for macros, and 1 for sources.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        max_upstream_macros (Optional[int]): The maximum number of permitted upstream macros. Default: 5\n        max_upstream_models (Optional[int]): The maximum number of permitted upstream models. Default: 5\n        max_upstream_sources (Optional[int]): The maximum number of permitted upstream sources. Default: 1\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_upstream_dependencies\n              max_upstream_models: 3\n        ```\n    \"\"\"\n\n    num_upstream_macros = len(list(model.depends_on.macros))\n    num_upstream_models = len([m for m in model.depends_on.nodes if m.split(\".\")[0] == \"model\"])\n    num_upstream_sources = len([m for m in model.depends_on.nodes if m.split(\".\")[0] == \"source\"])\n\n    assert (\n        num_upstream_macros &lt;= max_upstream_macros  # type: ignore[operator]\n    ), f\"`{model.name}` has {num_upstream_macros} upstream macros, which is more than the permitted maximum of {max_upstream_macros}.\"\n    assert (\n        num_upstream_models &lt;= max_upstream_models  # type: ignore[operator]\n    ), f\"`{model.name}` has {num_upstream_models} upstream models, which is more than the permitted maximum of {max_upstream_models}.\"\n    assert (\n        num_upstream_sources &lt;= max_upstream_sources  # type: ignore[operator]\n    ), f\"`{model.name}` has {num_upstream_sources} upstream sources, which is more than the permitted maximum of {max_upstream_sources}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_names","title":"<code>check_model_names</code>","text":"<p>Models must have a name that matches the supplied regex.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model_name_pattern</code> <code>str</code> <p>Regexp the model name must match.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_names\n      include: ^intermediate\n      model_name_pattern: ^int_\n    - name: check_model_names\n      include: ^staging\n      model_name_pattern: ^stg_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_names(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    model_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have a name that matches the supplied regex.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model_name_pattern (str): Regexp the model name must match.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_names\n              include: ^intermediate\n              model_name_pattern: ^int_\n            - name: check_model_names\n              include: ^staging\n              model_name_pattern: ^stg_\n        ```\n    \"\"\"\n\n    assert (\n        re.compile(model_name_pattern.strip()).match(model.name) is not None\n    ), f\"`{model.name}` does not match the supplied regex `{model_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_property_file_location","title":"<code>check_model_property_file_location</code>","text":"<p>Model properties files must follow the guidance provided by dbt here.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>model</code> <code>DbtBouncerModel</code> <p>The DbtBouncerModel object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_property_file_location(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Model properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        model (DbtBouncerModel): The DbtBouncerModel object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_property_file_location\n        ```\n    \"\"\"\n\n    expected_substr = (\n        \"_\".join(model.path.split(\"/\")[:-1])\n        .replace(\"staging\", \"stg\")\n        .replace(\"intermediate\", \"int\")\n        .replace(\"marts\", \"\")\n    )\n    properties_yml_name = model.patch_path.split(\"/\")[-1]\n\n    assert properties_yml_name.startswith(\n        \"_\"\n    ), f\"The properties file for `{model.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n    assert (\n        expected_substr in properties_yml_name\n    ), f\"The properties file for `{model.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n    assert properties_yml_name.endswith(\n        \"__models.yml\"\n    ), f\"The properties file for `{model.name}` (`{properties_yml_name}`) does not end with `__models.yml`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_models.check_model_test_coverage","title":"<code>check_model_test_coverage</code>","text":"<p>Set the minimum percentage of models that have at least one test.</p> <p>Receives:</p> Name Type Description <code>min_model_test_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have at least one test. Default: 100</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_test_coverage\n      min_model_test_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@bouncer_check\ndef check_model_test_coverage(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    tests: List[DbtBouncerModel],\n    min_model_test_coverage_pct: Union[float, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Set the minimum percentage of models that have at least one test.\n\n    Receives:\n        min_model_test_coverage_pct (float): The minimum percentage of models that must have at least one test. Default: 100\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_test_coverage\n              min_model_test_coverage_pct: 90\n        ```\n    \"\"\"\n\n    num_models = len(models)\n    models_with_tests = []\n    for model in models:\n        for test in tests:\n            if model.unique_id in test.depends_on.nodes:\n                models_with_tests.append(model.unique_id)\n    num_models_with_tests = len(set(models_with_tests))\n    model_test_coverage_pct = (num_models_with_tests / num_models) * 100\n\n    assert (\n        model_test_coverage_pct &gt;= min_model_test_coverage_pct  # type: ignore[operator]\n    ), f\"Only {model_test_coverage_pct}% of models have at least one test, this is less than the permitted minimum of {min_model_test_coverage_pct}%.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources","title":"<code>check_sources</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_description_populated","title":"<code>check_source_description_populated</code>","text":"<p>Sources must have a populated description.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_description_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_description_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated description.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_description_populated\n        ```\n    \"\"\"\n\n    assert (\n        len(source.description.strip()) &gt; 4\n    ), f\"`{source.source_name}.{source.name}` does not have a populated description.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_freshness_populated","title":"<code>check_source_freshness_populated</code>","text":"<p>Sources must have a populated freshness.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_freshness_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_freshness_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated freshness.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_freshness_populated\n        ```\n    \"\"\"\n\n    assert (\n        source.freshness.error_after.count is not None\n        and source.freshness.error_after.period is not None\n    ) or (\n        source.freshness.warn_after.count is not None\n        and source.freshness.warn_after.period is not None\n    ), f\"`{source.source_name}.{source.name}` does not have a populated freshness.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_has_meta_keys","title":"<code>check_source_has_meta_keys</code>","text":"<p>The <code>meta</code> config for sources must have the specified keys.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_meta_keys\n      keys:\n        - contact:\n            - email\n            - slack\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_has_meta_keys(\n    request,\n    keys: Union[NestedDict, None] = None,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The `meta` config for sources must have the specified keys.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_meta_keys\n              keys:\n                - contact:\n                    - email\n                    - slack\n                - owner\n        ```\n    \"\"\"\n\n    missing_keys = find_missing_meta_keys(\n        meta_config=source.meta,\n        required_keys=keys.model_dump(),\n    )\n    assert (\n        missing_keys == []\n    ), f\"`{source.source_name}.{source.name}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_has_tags","title":"<code>check_source_has_tags</code>","text":"<p>Sources must have the specified tags.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <code>tags</code> <code>List[str]</code> <p>List of tags to check for.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_has_tags(\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    tags: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must have the specified tags.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n        tags (List[str]): List of tags to check for.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n    \"\"\"\n\n    missing_tags = [tag for tag in tags if tag not in source.tags]\n    assert (\n        not missing_tags\n    ), f\"`{source.source_name}.{source.name}` is missing required tags: {missing_tags}.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_loader_populated","title":"<code>check_source_loader_populated</code>","text":"<p>Sources must have a populated loader.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_loader_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_loader_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated loader.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_loader_populated\n        ```\n    \"\"\"\n\n    assert (\n        source.loader != \"\"\n    ), f\"`{source.source_name}.{source.name}` does not have a populated loader.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_names","title":"<code>check_source_names</code>","text":"<p>Sources must have a name that matches the supplied regex.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <code>source_name_pattern</code> <code>str</code> <p>Regexp the source name must match.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_names\n      source_name_pattern: &gt;\n        ^[a-z0-9_]*$\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_names(\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    source_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must have a name that matches the supplied regex.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n        source_name_pattern (str): Regexp the source name must match.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_names\n              source_name_pattern: &gt;\n                ^[a-z0-9_]*$\n        ```\n    \"\"\"\n\n    assert (\n        re.compile(source_name_pattern.strip()).match(source.name) is not None\n    ), f\"`{source.source_name}.{source.name}` does not match the supplied regex `({source_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_not_orphaned","title":"<code>check_source_not_orphaned</code>","text":"<p>Sources must be referenced in at least one model.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_not_orphaned\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_not_orphaned(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must be referenced in at least one model.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_not_orphaned\n        ```\n    \"\"\"\n\n    num_refs = sum(source.unique_id in model.depends_on.nodes for model in models)\n    assert (\n        num_refs &gt;= 1\n    ), f\"Source `{source.source_name}.{source.name}` is orphaned, i.e. not referenced by any model.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_property_file_location","title":"<code>check_source_property_file_location</code>","text":"<p>Source properties files must follow the guidance provided by dbt here.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_property_file_location(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Source properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_property_file_location\n        ```\n    \"\"\"\n\n    path_cleaned = source.path.replace(\"models/staging\", \"\")\n    expected_substring = \"_\".join(path_cleaned.split(\"/\")[:-1])\n\n    assert path_cleaned.split(\"/\")[-1].startswith(\n        \"_\"\n    ), f\"The properties file for `{source.source_name}.{source.name}` (`{path_cleaned}`) does not start with an underscore.\"\n    assert (\n        expected_substring in path_cleaned\n    ), f\"The properties file for `{source.source_name}.{source.name}` (`{path_cleaned}`) does not contain the expected substring (`{expected_substring}`).\"\n    assert path_cleaned.split(\"/\")[-1].endswith(\n        \"__sources.yml\"\n    ), f\"The properties file for `{source.source_name}.{source.name}` (`{path_cleaned}`) does not end with `__sources.yml`.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_used_by_models_in_same_directory","title":"<code>check_source_used_by_models_in_same_directory</code>","text":"<p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_models_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_used_by_models_in_same_directory(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources can only be referenced by models that are located in the same directory where the source is defined.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_models_in_same_directory\n        ```\n    \"\"\"\n\n    reffed_models_not_in_same_dir = []\n    for model in models:\n        if (\n            source.unique_id in model.depends_on.nodes\n            and model.path.split(\"/\")[:-1] != source.path.split(\"/\")[1:-1]\n        ):\n            reffed_models_not_in_same_dir.append(model.unique_id.split(\".\")[0])\n\n    assert (\n        len(reffed_models_not_in_same_dir) == 0\n    ), f\"Source `{source.source_name}.{source.name}` is referenced by models defined in a different directory: {reffed_models_not_in_same_dir}\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_sources.check_source_used_by_only_one_model","title":"<code>check_source_used_by_only_one_model</code>","text":"<p>Each source can be referenced by a maximum of one model.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSource object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_only_one_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_used_by_only_one_model(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each source can be referenced by a maximum of one model.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        source (DbtBouncerSource): The DbtBouncerSource object to check.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_only_one_model\n        ```\n    \"\"\"\n\n    num_refs = sum(source.unique_id in model.depends_on.nodes for model in models)\n    assert (\n        num_refs &lt;= 1\n    ), f\"Source `{source.source_name}.{source.name}` is referenced by more than one model.\"\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_unit_tests","title":"<code>check_unit_tests</code>","text":""},{"location":"checks/checks_manifest/#manifest.check_unit_tests.check_unit_test_expect_format","title":"<code>check_unit_test_expect_format</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>permitted_formats</code> <code>Optional[List[Literal['csv', 'dict', 'sql']]]</code> <p>A list of formats that are allowed to be used for <code>expect</code> input in a unit test.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_expect_format\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>@pytest.mark.iterate_over_unit_tests\n@bouncer_check\ndef check_unit_test_expect_format(\n    manifest_obj: DbtBouncerManifest,\n    request: TopRequest,\n    permitted_formats: Union[List[Literal[\"csv\", \"dict\", \"sql\"]], None] = None,\n    unit_test: Union[UnitTests, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Unit tests can only use the specified formats.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        permitted_formats (Optional[List[Literal[\"csv\", \"dict\", \"sql\"]]]): A list of formats that are allowed to be used for `expect` input in a unit test.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_expect_format\n              permitted_formats:\n                - csv\n        ```\n    \"\"\"\n\n    if semver.Version.parse(manifest_obj.manifest.metadata.dbt_version) &gt;= \"1.8.0\":\n        assert (\n            unit_test.expect.format.value in permitted_formats  # type: ignore[operator]\n        ), f\"Unit test `{unit_test.name}` has an `expect` format that is not permitted. Permitted formats are: {permitted_formats}.\"\n    else:\n        logging.warning(\n            \"The `check_unit_test_expect_format` check is only supported for dbt 1.8.0 and above.\"\n        )\n</code></pre>"},{"location":"checks/checks_manifest/#manifest.check_unit_tests.check_unit_test_given_formats","title":"<code>check_unit_test_given_formats</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>permitted_formats</code> <code>Optional[List[Literal['csv', 'dict', 'sql']]]</code> <p>A list of formats that are allowed to be used for <code>given</code> inputs in a unit test.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_given_formats\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>@pytest.mark.iterate_over_unit_tests\n@bouncer_check\ndef check_unit_test_given_formats(\n    manifest_obj: DbtBouncerManifest,\n    request: TopRequest,\n    permitted_formats: Union[List[Literal[\"csv\", \"dict\", \"sql\"]], None] = None,\n    unit_test: Union[UnitTests, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Unit tests can only use the specified formats.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        permitted_formats (Optional[List[Literal[\"csv\", \"dict\", \"sql\"]]]): A list of formats that are allowed to be used for `given` inputs in a unit test.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_given_formats\n              permitted_formats:\n                - csv\n        ```\n    \"\"\"\n\n    if semver.Version.parse(manifest_obj.manifest.metadata.dbt_version) &gt;= \"1.8.0\":\n        given_formats = [i.format.value for i in unit_test.given]\n        assert all(\n            e in permitted_formats for e in given_formats  # type: ignore[operator]\n        ), f\"Unit test `{unit_test.name}` has given formats which are not permitted. Permitted formats are: {permitted_formats}.\"\n    else:\n        logging.warning(\n            \"The `check_unit_test_given_formats` check is only supported for dbt 1.8.0 and above.\"\n        )\n</code></pre>"},{"location":"checks/checks_run_results/","title":"Run Results Checks","text":"<p>Note</p> <p>The below checks require both <code>manifest.json</code> and <code>run_results.json</code> to be present.</p>"},{"location":"checks/checks_run_results/#run_results.check_run_results","title":"<code>check_run_results</code>","text":""},{"location":"checks/checks_run_results/#run_results.check_run_results.check_run_results_max_gigabytes_billed","title":"<code>check_run_results_max_gigabytes_billed</code>","text":"<p>Each result can have a maximum number of gigabytes billed.</p> <p>Note</p> <p>Note that this check only works for the <code>dbt-bigquery</code> adapter.</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>max_gigabytes_billed</code> <code>float</code> <p>The maximum gigabytes billed allowed for a node.</p> <code>run_result</code> <code>DbtBouncerResult</code> <p>The DbtBouncerResult object to check.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_gigabytes_billed\n      max_gigabytes_billed: 100\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>@pytest.mark.iterate_over_run_results\n@bouncer_check\ndef check_run_results_max_gigabytes_billed(\n    request: TopRequest,\n    max_gigabytes_billed: Union[float, None] = None,\n    run_result: Union[DbtBouncerResult, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each result can have a maximum number of gigabytes billed.\n\n    !!! note\n\n        Note that this check only works for the `dbt-bigquery` adapter.\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        max_gigabytes_billed (float): The maximum gigabytes billed allowed for a node.\n        run_result (DbtBouncerResult): The DbtBouncerResult object to check.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_gigabytes_billed\n              max_gigabytes_billed: 100\n        ```\n    \"\"\"\n\n    try:\n        gigabytes_billed = run_result.adapter_response[\"bytes_billed\"] / (1000**3)\n    except KeyError:\n        raise RuntimeError(\n            \"`bytes_billed` not found in adapter response. Are you using the `dbt-bigquery` adapter?\"\n        )\n\n    assert (\n        gigabytes_billed &lt; max_gigabytes_billed\n    ), f\"`{run_result.unique_id.split('.')[-2]}` results in ({gigabytes_billed} billed bytes, this is greater than permitted ({max_gigabytes_billed}).\"\n</code></pre>"},{"location":"checks/checks_run_results/#run_results.check_run_results.check_run_results_max_execution_time","title":"<code>check_run_results_max_execution_time</code>","text":"<p>Each result can take a maximum duration (seconds).</p> <p>Receives:</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>max_execution_time_seconds</code> <code>float</code> <p>The maximum execution time (seconds) allowed for a node.</p> <code>run_result</code> <code>DbtBouncerResult</code> <p>The DbtBouncerResult object to check.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      max_execution_time_seconds: 60\n</code></pre> <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      include: ^staging # Not a good idea, here for demonstration purposes only\n      max_execution_time_seconds: 10\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>@pytest.mark.iterate_over_run_results\n@bouncer_check\ndef check_run_results_max_execution_time(\n    request: TopRequest,\n    max_execution_time_seconds: Union[float, None] = None,\n    run_result: Union[DbtBouncerResult, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each result can take a maximum duration (seconds).\n\n    Receives:\n        exclude (Optional[str]): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        max_execution_time_seconds (float): The maximum execution time (seconds) allowed for a node.\n        run_result (DbtBouncerResult): The DbtBouncerResult object to check.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              max_execution_time_seconds: 60\n        ```\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              include: ^staging # Not a good idea, here for demonstration purposes only\n              max_execution_time_seconds: 10\n        ```\n    \"\"\"\n\n    assert (\n        run_result.execution_time &lt;= max_execution_time_seconds\n    ), f\"`{run_result.unique_id.split('.')[-1]}` has an execution time ({run_result.execution_time} greater than permitted ({max_execution_time_seconds}s).\"\n</code></pre>"}]}