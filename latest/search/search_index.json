{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-dbt-bouncer","title":"Welcome to dbt-bouncer","text":"<p><code>dbt-bouncer</code> is an open-source tool that allows you to configure and enforce conventions for your dbt project. The conventions are run against dbt's artifact files (think <code>./target/manifest.json</code>) resulting in speedy tests. Conventions can be specified in a <code>.yml</code> file, allowing maximum customisation to the conventions you wish to follow (or create \ud83d\ude00).</p> <p>Check out our <code>Getting Started</code> guide.</p>"},{"location":"#terminology","title":"Terminology","text":"<ul> <li>Check: A check is a rule run against a dbt artifact.</li> <li>Config file: A <code>.yml</code> file that specifies which checks to run along with any parameters.</li> <li>dbt artifacts directory: The directory that contains the dbt artifacts (<code>manifest.json</code>, etc.), generally this is <code>./target</code>.</li> </ul>"},{"location":"#aims","title":"Aims","text":"<p><code>dbt-bouncer</code> aims to:</p> <ul> <li>Provide a 100% configurable way to enforce conventions in a dbt project.</li> <li>Be as fast as possible, running checks against dbt artifacts.</li> <li>Be as easy as possible to use, with a simple config file written in <code>YML</code>.</li> <li>Be as flexible as possible, allowing checks to be written in python.</li> <li>Provide immediate feedback when run as part of a CI pipeline.</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>dbt-bouncer</code> is free software, released under the MIT license. It originated at Xebia Data in Amsterdam, Netherlands. Source code is available on GitHub.</p> <p>All contributions, in the form of bug reports, pull requests, feedback or discussion are welcome. See the contributing guide for more information.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>dbt-bouncer</code>","text":"<p><code>dbt-bouncer</code> is open source software. Whether you are a seasoned open source contributor or a first-time committer, we welcome and encourage you to contribute code, documentation, ideas, or problem statements to this project.</p>"},{"location":"CONTRIBUTING/#about-this-document","title":"About this document","text":"<p>There are many ways to contribute to the ongoing development of <code>dbt-bouncer</code>, such as by participating in discussions and issues.</p> <p>The rest of this document serves as a more granular guide for contributing code changes to <code>dbt-bouncer</code> (this repository). It is not intended as a guide for using <code>dbt-bouncer</code>, and some pieces assume a level of familiarity with Python development (virtualenvs, <code>Poetry</code>, etc). Specific code snippets in this guide assume you are using macOS or Linux and are comfortable with the command line.</p> <p>If you get stuck, we're happy to help! Just open an issue or draft PR and we'll do our best to help out.</p>"},{"location":"CONTRIBUTING/#note","title":"Note","text":"<ul> <li>Branches: All pull requests from community contributors should target the <code>main</code> branch (default).</li> </ul>"},{"location":"CONTRIBUTING/#getting-the-code","title":"Getting the code","text":""},{"location":"CONTRIBUTING/#installing-git","title":"Installing git","text":"<p>You will need <code>git</code> in order to download and modify the <code>dbt-bouncer</code> source code. On macOS, the best way to download git is to just install Xcode.</p>"},{"location":"CONTRIBUTING/#contributors","title":"Contributors","text":"<p>You can contribute to <code>dbt-bouncer</code> by forking the <code>dbt-bouncer</code> repository. For a detailed overview on forking, check out the GitHub docs on forking. In short, you will need to:</p> <ol> <li>Fork the <code>dbt-bouncer</code> repository.</li> <li>Clone your fork locally.</li> <li>Check out a new branch for your proposed changes.</li> <li>Push changes to your fork.</li> <li>Open a pull request against <code>godatadriven/dbt-bouncer</code> from your forked repository.</li> </ol>"},{"location":"CONTRIBUTING/#setting-up-an-environment","title":"Setting up an environment","text":"<p>There are some tools that will be helpful to you in developing locally. While this is the list relevant for <code>dbt-bouncer</code> development, many of these tools are used commonly across open-source python projects.</p>"},{"location":"CONTRIBUTING/#tools","title":"Tools","text":"<p>These are the tools used in <code>dbt-bouncer</code> development and testing:</p> <ul> <li><code>click</code> to create our CLI interface.</li> <li>GitHub Actions for automating tests and checks, once a PR is pushed to the <code>dbt-bouncer</code> repository.</li> <li><code>make</code> to run multiple setup or test steps in combination.</li> <li><code>mypy</code> for static type checking.</li> <li><code>Poetry</code> to manage our python virtual environment.</li> <li><code>pre-commit</code> to easily run those checks.</li> <li><code>Pydantic</code> to validate our configuration file.</li> <li><code>pytest</code> to define, discover, and run tests.</li> <li><code>Ruff</code> to lint and format python code.</li> </ul> <p>A deep understanding of these tools in not required to effectively contribute to <code>dbt-bouncer</code>, but we recommend checking out the attached documentation if you're interested in learning more about each one.</p>"},{"location":"CONTRIBUTING/#virtual-environments","title":"Virtual environments","text":"<p>We strongly recommend using virtual environments when developing code in <code>dbt-bouncer</code>. We recommend creating this virtualenv in the root of the <code>dbt-bouncer</code> repository. To create a new virtualenv, run:</p> <pre><code>poetry shell\n</code></pre> <p>This will create a new Python virtual environment.</p>"},{"location":"CONTRIBUTING/#setting-environment-variables","title":"Setting environment variables","text":"<p>Set required environment variables by copying <code>.env.example</code> to <code>.env</code> and updating the values.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer-in-development","title":"Running <code>dbt-bouncer</code> in development","text":""},{"location":"CONTRIBUTING/#installation","title":"Installation","text":"<p>First make sure that you set up your <code>virtualenv</code> as described in Setting up an environment. Next, install <code>dbt-bouncer</code>, its dependencies and <code>pre-commit</code>:</p> <pre><code>poetry install\npoetry run pre-commit install\n</code></pre> <p>When installed in this way, any changes you make to your local copy of the source code will be reflected immediately in your next <code>dbt-bouncer</code> run.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer","title":"Running <code>dbt-bouncer</code>","text":"<p>With your virtualenv activated, the <code>dbt-bouncer</code> script should point back to the source code you've cloned on your machine. You can verify this by running <code>which dbt-bouncer</code>. This command should show you a path to an executable in your virtualenv. You can run <code>dbt-bouncer</code> using the provided example configuration file via:</p> <pre><code>poetry run dbt-bouncer --config-file dbt-bouncer-example.yml\n</code></pre>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Once you're able to manually test that your code change is working as expected, it's important to run existing automated tests, as well as adding some new ones. These tests will ensure that: - Your code changes do not unexpectedly break other established functionality - Your code changes can handle all known edge cases - The functionality you're adding will keep working in the future</p>"},{"location":"CONTRIBUTING/#note_1","title":"Note","text":"<ul> <li>Generating dbt artifacts: If you change the configuration of the dbt project located in <code>dbt_project</code> then you will need to re-generate the dbt artifacts used in testing. To do so, run:</li> </ul> <pre><code>make build-artifacts\n</code></pre>"},{"location":"CONTRIBUTING/#test-commands","title":"Test commands","text":"<p>There are a few methods for running tests locally.</p>"},{"location":"CONTRIBUTING/#makefile","title":"<code>makefile</code>","text":"<p>There are multiple targets in the <code>makefile</code> to run common test suites, most notably:</p> <pre><code># Runs unit tests\nmake test-unit\n\n# Runs integration tests\nmake test-integration\n\n# Runs all tests\nmake test\n</code></pre>"},{"location":"CONTRIBUTING/#pre-commit","title":"<code>pre-commit</code>","text":"<p><code>pre-commit</code> takes care of running all code-checks for formatting and linting. Run <code>poetry run pre-commit install</code> to install <code>pre-commit</code> in your local environment. Once this is done you can use the git pre-commit hooks to ensure proper formatting and linting.</p>"},{"location":"CONTRIBUTING/#pytest","title":"<code>pytest</code>","text":"<p>Finally, you can also run a specific test or group of tests using <code>pytest</code> directly. With a virtualenv active and dev dependencies installed you can do things like:</p> <pre><code># run all unit tests in a file\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py\n\n# run a specific unit test\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py::test_check_columns_are_documented_in_public_models\n</code></pre> <p>See pytest usage docs for an overview of useful command-line options.</p>"},{"location":"CONTRIBUTING/#assorted-development-tips","title":"Assorted development tips","text":"<ul> <li>Append <code># type: ignore</code> to the end of a line if you need to disable <code>mypy</code> on that line, preferably with the specific rule to ignore such as <code># type: ignore[union-attr]</code>.</li> </ul>"},{"location":"CONTRIBUTING/#adding-a-new-check","title":"Adding a new check","text":"<p>To add a new check follow the below steps:</p> <ol> <li>In <code>./src/dbt_bouncer/checks</code> choose the appropriate directory for your check. For example, if your check only requires the <code>manifest.json</code> then use the <code>manifest</code> directory, if your check requires the <code>catalog.json</code> then use the <code>catalog</code> directory.</li> <li>Within the chosen directory assess if a suitable file already exists. For example, if your check applies to a model then <code>manifest/check_models.py</code> is a suitable location.</li> <li> <p>Within the chosen file, add a Pydantic model, this object must meet the following criteria:</p> <ul> <li>Start with \"Check\".</li> <li>Inherit from <code>dbt_bouncer.check_base.BaseCheck</code>.</li> <li>Have a <code>name</code> attribute that is a string whose value is the snake case equivalent of the class name.</li> <li>A <code>default</code> value provided for optional input arguments and arguments that are received at execution time.</li> <li>Have a doc string that includes a description of the check, a list of possible input parameters and at least one example.</li> <li>A clear message in the event of a failure.</li> </ul> </li> <li> <p>After the check is added, add the check to <code>dbt-bouncer-example.yml</code> and run <code>dbt-bouncer --config-file dbt-bouncer-example.yml</code> to ensure the check succeeds.</p> </li> <li>(Optional) If the dbt project located in <code>./dbt_project</code> needs to be updated then do so and also run <code>make build-artifacts</code> to generate the new test artifacts.</li> <li>Add at least one happy path and one unhappy path test to <code>./tests</code>. The appropriate test file will be the one matching the directory of the check. For example, if the check is in <code>./src/dbt_bouncer/checks/catalog/check_columns.py</code> then the test file will be <code>./tests/unit/checks/catalog/test_columns.py</code>.</li> <li>Run <code>make test</code> to ensure the tests pass.</li> <li>Open a PR \ud83c\udf89!</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>Code can be merged into the current development branch <code>main</code> by opening a pull request. If the proposal looks like it's on the right track, then a <code>dbt-bouncer</code> maintainer will review the PR. They may suggest code revision for style or clarity, or request that you add unit or integration test(s). These are good things! We believe that, with a little bit of help, anyone can contribute high-quality code. Once merged, your contribution will be available for the next release of <code>dbt-bouncer</code>.</p> <p>Automated tests run via GitHub Actions. If you're a first-time contributor, all tests will require a maintainer to approve.</p> <p>Once all tests are passing and your PR has been approved, a <code>dbt-bouncer</code> maintainer will merge your changes into the active development branch. And that's it! Happy developing :tada:</p>"},{"location":"cli/","title":"CLI","text":"<p>This page provides documentation for the <code>dbt-bouncer</code> CLI.</p>"},{"location":"cli/#dbt-bouncer","title":"dbt-bouncer","text":"<p>Entrypoint for dbt-bouncer.</p> <p>Raises:     RuntimeError: If output file has an invalid extension.</p> <p>Usage:</p> <pre><code>dbt-bouncer [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --config-file PUREPATH  Location of the YML config file.\n  --output-file PATH      Location of the json file where check metadata will\n                          be saved.\n  -v, --verbosity         Verbosity.\n  --version               Show the version and exit.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"cli/#exit-codes","title":"Exit codes","text":"<p><code>dbt-bouncer</code> returns the following exit codes:</p> <ul> <li> <p><code>0</code>: All checks have succeeded.</p> </li> <li> <p><code>1</code>:</p> <ul> <li>At least one check has failed. Check the logs for more information.</li> <li>A fatal error occurred during check setup or check execution. Check the logs for more information.</li> </ul> </li> </ul>"},{"location":"config_file/","title":"Config file","text":"<p><code>dbt-bouncer</code> requires a config file which determines what checks are run. The following options are available, in order of priority:</p> <ol> <li>A file passed via the <code>--config-file</code> CLI flag.</li> <li>A file named <code>dbt-bouncer.yml</code> in the current working directory.</li> <li>A <code>[tool.dbt-bouncer]</code> section in <code>pyproject.toml</code>.</li> </ol> <p>Here is an example config file in <code>yaml</code>:</p> <pre><code># [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `./target`.\ndbt_artifacts_dir: target\n\nmanifest_checks:\n  - name: check_macro_name_matches_file_name\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <p>And the same config in <code>toml</code>:</p> <pre><code>[tool.dbt-bouncer]\n# [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `./target`.\ndbt_artifacts_dir = \"target\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_macro_name_matches_file_name\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_model_names\"\ninclude = \"^models/staging\"\nmodel_name_pattern = \"^stg_\"\n</code></pre> <p>For more example config files, see here.</p>"},{"location":"config_file/#common-arguments","title":"Common arguments","text":""},{"location":"config_file/#exclude-and-include","title":"Exclude and Include","text":"<p>Most (but not all) checks accept the following optional arguments:</p> <ul> <li><code>exclude</code>: Regexp to match which original file paths to exclude.</li> <li><code>include</code>: Regexp to match which original file paths to include.</li> </ul> <p>Example per resource type:</p> <ul> <li><code>Exposures</code>: The original file path to the properties file where the source is defined, e.g. <code>^models/marts/finance</code> will match exposures defined in <code>./models/marts/finance/_exposures.yml</code>.</li> <li><code>Macros</code>: The original file path to the macro file, e.g. <code>^macros/system</code> will match files like <code>./macros/system/generate_schema_name.sql</code>.</li> <li><code>Models</code>: The original file path to the model file, e.g. <code>^marts</code> will match files like <code>./models/marts/customers.sql</code>.</li> <li><code>Run results</code>: The original file path to the file associated with the resource, e.g. <code>^seeds/finance</code> will match seeds in <code>./seeds/finance</code>, <code>^models/staging</code> will match models and tests in <code>./models/staging</code>.</li> <li><code>Semantic models</code>: The original file path to the properties file where the semantic model is defined, e.g. <code>^models/marts/finance</code> will match semantic models defined in <code>./models/marts/finance/_finance__semantic_models.yml</code>.</li> <li><code>Sources</code>: The original file path to the properties file where the source is defined, e.g. <code>^models/staging/crm</code> will match sources defined in <code>./models/staging/crm/_crm__sources.yml</code>.</li> <li><code>Unit tests</code>: The original file path to the properties file where the unit test is defined, e.g. <code>^models/staging/crm</code> will match unit tests defined in <code>^staging/crm/_stg_crm__unit_tests.yml</code>.</li> </ul> <p>To determine if a check accepts these arguments view the Checks page.</p> <p>Note</p> <p><code>exclude</code> and <code>include</code> can be specified at both the check level and the global level. Should both levels be specified, then the check level is applied. All the below examples result in the <code>check_model_names</code> check being run on all models in <code>./models/staging</code>:</p> <pre><code># Specify `include` at the check level only\nmanifest_checks:\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the check and global levels\ninclude: ^models/marts\nmanifest_checks:\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the global level only\ninclude: ^models/staging\nmanifest_checks:\n  - name: check_model_names\n    model_name_pattern: ^stg_\n</code></pre> <p>Note</p> <p>When compiled on Windows machines, keys such as <code>original_file_path</code>, <code>patch_path</code> and <code>path</code> take the form:</p> <pre><code>models\\\\staging\\\\crm\\\\model_1.sql\n</code></pre> <p>When compiled on Linux and Mac machines, these same keys take the form:</p> <pre><code>models/staging/crm/model_1.sql\n</code></pre> <p><code>dbt-bouncer</code> converts all of these paths to the Linux/Mac form, hence when you are supplying values to <code>exclude</code> and <code>include</code> you should use the Linux/Mac form.</p>"},{"location":"config_file/#severity","title":"Severity","text":"<p>All checks accept a <code>severity</code> argument, valid values are:</p> <ul> <li><code>error</code>: If the check fails then <code>dbt-bouncer</code> will return a non-zero exit code.</li> <li><code>warn</code>: If the check fails then <code>dbt-bouncer</code> will return a non-zero exit code.</li> </ul> <p><code>severity</code> can also be specified globally, this is useful when applying <code>dbt-bouncer</code> to a pre-existing dbt project. It allows you to run <code>dbt-bouncer</code>, identify the checks that fail and address the failures in your own time without receiving non-zero exit codes:</p> <pre><code># Specify `severity` at the global levels: all checks will have a `warn` severity, avoiding non-zero exit codes.\nseverity: warn\n\nmanifest_checks:\n  - name: check_exposure_based_on_view\n  ...\n</code></pre> <p>Note</p> <p><code>severity</code> can be specified at both the check level and the global level. Should both levels be specified, then the global level is applied.</p> <pre><code># No `severity` specified: check will have an `error` severity.\nmanifest_checks:\n  - name: check_exposure_based_on_view\n</code></pre> <pre><code># Specify `severity` at the check level only: check will have a `warn` severity.\nmanifest_checks:\n  - name: check_exposure_based_on_view\n    severity: warn\n</code></pre> <pre><code># Specify `severity` at the check and global levels: check will have a `warn` severity.\nseverity: warn\nmanifest_checks:\n  - name: check_exposure_based_on_view\n    severity: error\n</code></pre> <pre><code># Specify `severity` at the global level only: check will have a `warn` severity.\nseverity: warn\nmanifest_checks:\n  - name: check_exposure_based_on_view\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#can-other-tools-perform-the-same-checks-as-dbt-bouncer","title":"Can other tools perform the same checks as <code>dbt-bouncer</code>?","text":"<p>There are several other tools that perform similar tasks as <code>dbt-bouncer</code>.</p> <ul> <li>dbt-checkpoint: A collection of <code>pre-commit</code> hooks for dbt projects. Tests are written in python. Configuration is performed via <code>.pre-commit-config.yaml</code>. Provided the dbt artifacts have already been generated, <code>dbt-checkpoint</code> does not need access to the underlying database. The hooks execute when a new commit is made, as such <code>dbt-checkpoint</code> is designed to be run only as part of <code>pre-commit</code>.</li> <li>dbt-project-evaluator: This is a dbt package from dbt Labs. Tests are written in <code>.sql</code> files using a combination of Jinja and SQL. Configuration is performed via <code>dbt_project.yml</code> and seed files (i.e. csv files). Requires a connection to underlying database. Designed to be run both in a CI pipeline and also during active development.</li> <li>dbt-score: This is a python package installable via <code>pip</code>. A collection of tests that apply only to dbt models. Tests can be executed from the command line. Tests are written in python. Configuration is performed via a <code>pyproject.toml</code> file. Provided the dbt artifacts have already been generated, <code>dbt-score</code> does not need access to the underlying database. Designed to be run during development.</li> </ul> <p>While the above tools inhabit the same space as <code>dbt-bouncer</code> they do not provide what we consider to be the optimum experience that <code>dbt-bouncer</code> provides:</p> <ul> <li>Designed to run both locally and in a CI pipeline.</li> <li>Configurable via a file format, <code>YML</code>, that dbt developers are already familiar with.</li> <li>Does not require database access.</li> <li>Can run tests against any of dbt's artifacts.</li> <li>Allows tests to be written in python.</li> </ul> <p>As such we consider <code>dbt-bouncer</code> to be the best tool to enforce conventions in a dbt project.</p> <p>Tip</p> <p><code>dbt-bouncer</code> can perform all the tests currently included in <code>dbt-checkpoint</code>, <code>dbt-project-evaluator</code> and <code>dbt-score</code>. If you see an existing test that is not possible with <code>dbt-bouncer</code>, open an issue and we'll add it!</p>"},{"location":"faq/#does-dbt-bouncer-work-with-dbt-cloud","title":"Does <code>dbt-bouncer</code> work with dbt Cloud?","text":"<p>Yes! As <code>dbt-bouncer</code> runs on the artifacts generated by dbt, it can be used with dbt Cloud as long as the artifacts generated by the CI job in dbt Cloud are available.</p> <p>For GitHub this can be achieved using the pgoslatara/dbt-cloud-download-artifacts-action action: <pre><code>name: CI pipeline\n\non:\n  pull_request:\n      branches:\n          - main\n\njobs:\n    download-artifacts:\n        runs-on: ubuntu-latest\n        permissions:\n            pull-requests: write\n        steps:\n          - name: Checkout\n            uses: actions/checkout@v4\n\n          - name: Download dbt artifacts\n            uses: pgoslatara/dbt-cloud-download-artifacts-action@v1\n            with:\n              commit-sha: ${{ github.event.pull_request.head.sha }}\n              dbt-cloud-api-token: ${{ secrets.DBT_CLOUD_API_TOKEN }}\n\n          - name: Run dbt-bouncer\n            uses: godatadriven/dbt-bouncer@vX.X\n</code></pre></p> <p>Warning</p> <p>dbt Cloud now supports a \"versionless\" option, which allows dbt projects to be run with the latest version of dbt. One effect of choosing this option is that dbt artifacts may receive non-breaking changes (source), these may or may not be compatible with <code>dbt-bouncer</code>. If you encounter a bug as a result of this, please open an issue and we'll investigate.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-in-a-monorepo","title":"How to set up <code>dbt-bouncer</code> in a monorepo?","text":"<p>A monorepo may consist of one directory with a dbt project and other directories with unrelated code. It may be desired for <code>dbt-bouncer</code> to be configured from the root directory. Sample directory tree:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 dbt-project\n\u2502   \u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 dbt_project.yml\n\u2502   \u2514\u2500\u2500 profiles.yml\n\u2514\u2500\u2500 package-a\n    \u251c\u2500\u2500 src\n    \u251c\u2500\u2500 tests\n    \u2514\u2500\u2500 package.json\n</code></pre> <p>To ease configuration you can use <code>exclude</code> or <code>include</code> at the global level (see Config File for more details). For the above example <code>dbt-bouncer.yml</code> could be configured as:</p> <pre><code>dbt_artifacts_dir: dbt-project/target\ninclude: ^dbt-project\n\nmanifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre> <p><code>dbt-bouncer</code> can now be run from the root directory.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-in-a-dbt-mesh","title":"How to set up <code>dbt-bouncer</code> in a dbt Mesh?","text":"<p>A dbt Mesh is a collection of dbt projects in an organisation, some of which can read models from other dbt projects. Natively supported by dbt Cloud, a dbt Mesh can also be set up with dbt Core using a plugin such as dbt-loom.</p> <p>One challenge in a dbt Mesh is the large number of developers working across multiple dbt projects leading to differing conventions being implemented. There are multiple approaches to using <code>dbt-bouncer</code> in a dbt Mesh, two are outlined below.</p>"},{"location":"faq/#approach-1-individual-dbt-bounceryml-configuration-file","title":"Approach 1: Individual <code>dbt-bouncer.yml</code> configuration file","text":"<p>Each dbt project can have its own <code>dbt-bouncer.yml</code> configuration file. This allows each project to adopt and implement its own conventions in addition to any conventions to be shared across all dbt projects. Should a breaking change be required to the config file then each dbt project can be updated independently at a time that makes sense.</p> <p>This is the recommended approach due to its simplicity and ability to update each dbt project independently.</p>"},{"location":"faq/#approach-2-centralised-dbt-bounceryml-configuration-file-shared-via-git-submodule","title":"Approach 2: Centralised <code>dbt-bouncer.yml</code> configuration file shared via git submodule","text":"<p>Warning</p> <p>With this approach, a change to the centralised <code>dbt-bouncer.yml</code> file may result in CI pipelines in dbt projects failing despite no changes being made to these projects. As such we recommend implementing this approach only after extensive discussion with all dbt project developers so that all dbt projects can be brought into line before <code>dbt-bouncer</code> is enforced in the CI pipeline.</p> <p>Should it be necessary for a breaking change to be made to the centralised <code>dbt-bouncer.yml</code> configuration file, we recommend setting the <code>severity</code> of the relevant check to <code>warn</code> so that CI pipelines in dbt projects will not fail and maintainers have sufficient time to make the necessary changes.</p> <p>Git submodules allow the contents from one repository to be accessible from a different repository. Such a setup for <code>dbt-bouncer</code> can be achieved as follows (this example uses GitHub, similar setups can be achieved with other providers):</p> <ol> <li> <p>Set up a dedicated repository to store a centralised <code>dbt-bouncer.yml</code> configuration file that will be used by all dbt projects. Let's call this repository <code>dbt-bouncer-config</code>.</p> </li> <li> <p>The contents of the <code>dbt-bouncer.yml</code> file in <code>dbt-bouncer-config</code> should contain the following configuration for <code>dbt_artifacts_dir</code>:</p> <pre><code>dbt_artifacts_dir: ../target\n\nmanifest_checks:\n  - name: check_model_directories\n    include: ^models\n    permitted_sub_directories:\n      - intermediate\n      - marts\n      - staging\n      - utilities\n  ...\n</code></pre> </li> <li> <p>In every repository add a git submodule via:</p> <pre><code>git submodule add git@github.com:&lt;YOUR_ORG&gt;/dbt-bouncer-config.git\n</code></pre> </li> <li> <p>Run <code>dbt-bouncer</code>:</p> <pre><code>dbt-bouncer --config-file dbt-bouncer-config/dbt-bouncer.yml\n</code></pre> </li> </ol> <p>Your directory tree should look like this:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer-config\n\u2502   \u2514\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 macros\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 models\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 profiles.yml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 target\n    \u251c\u2500\u2500 catalog.json\n    \u251c\u2500\u2500 manifest.json\n    \u2514\u2500\u2500 run_results.json\n</code></pre> <p>Note: if you update your central <code>dbt-bouncer.yml</code> file, you will need to run <code>git submodule update --remote</code> in every repository to update the submodule.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-with-pre-commit","title":"How to set up <code>dbt-bouncer</code> with <code>pre-commit</code>?","text":"<p>You can use a local hook to run automatically run <code>dbt-bouncer</code> before your commits get added to the git tree.</p> <pre><code>- repo: local\n  hooks:\n    - id: dbt-bouncer\n      name: dbt-bouncer\n      entry: dbt-bouncer # --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n      language: system\n      pass_filenames: false\n      always_run: true\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#how-to-run-dbt-bouncer","title":"How to run <code>dbt-bouncer</code>","text":"<ol> <li> <p>Generate dbt artifacts by running a dbt command:</p> <ul> <li><code>dbt parse</code> to generate a <code>manifest.json</code> artifact.</li> <li><code>dbt docs generate</code> to generate a <code>catalog.json</code> artifact (necessary if you are using catalog checks).</li> <li><code>dbt run</code> (or any other command that implies it e.g. <code>dbt build</code>) to generate a <code>run_results.json</code> artifact (necessary if you are using run results checks).</li> </ul> </li> <li> <p>Create a <code>dbt-bouncer.yml</code> config file, details here.</p> </li> <li> <p>Run <code>dbt-bouncer</code> to validate that your conventions are being maintained.</p> </li> </ol>"},{"location":"getting_started/#installing-with-python","title":"Installing with Python","text":"<p>Install from pypi.org:</p> <pre><code>pip install dbt-bouncer # or via any other package manager\n</code></pre> <p>Run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nLoaded config from dbt-bouncer-example.yml...\nValidating conf...\n</code></pre> <p><code>dbt-bouncer</code> also supports a verbose mode, run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt; -v\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nconfig_file=PosixPath('dbt-bouncer-example.yml')\nconfig_file_source='COMMANDLINE'\nConfig file passed via command line: dbt-bouncer-example.yml\nLoading config from /home/pslattery/repos/dbt-bouncer/dbt-bouncer-example.yml...\nLoading config from dbt-bouncer-example.yml...\nLoaded config from dbt-bouncer-example.yml...\nconf={'dbt_artifacts_dir': 'dbt_project/target', 'catalog_checks': [{'name': 'check_column_name_complies_to_column_type', 'column_name_pattern': '^is_.*', 'exclude': '^staging', 'types': ['BOOLEAN']}]}\nValidating conf...\n</code></pre>"},{"location":"getting_started/#running-as-an-executable-using-uv","title":"Running as an executable using uv","text":"<p>Run <code>dbt-bouncer</code> as a standalone Python executable using <code>uv</code>:</p> <pre><code>uvx dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#github-actions","title":"GitHub Actions","text":"<p>Run <code>dbt-bouncer</code> as part of your CI pipeline: <pre><code>name: CI pipeline\n\non:\n  pull_request:\n      branches:\n          - main\n\njobs:\n    run-dbt-bouncer:\n        permissions:\n            pull-requests: write # Required to write a comment on the PR\n        runs-on: ubuntu-latest\n        steps:\n            - name: Checkout\n              uses: actions/checkout@v4\n\n            - name: Generate or fetch dbt artifacts\n              run: ...\n\n            - uses: godatadriven/dbt-bouncer@vX.X\n              with:\n                config-file: ./&lt;PATH_TO_CONFIG_FILE&gt;\n                output-file: results.json # optional, default does not save a results file\n                send-pr-comment: true # optional, defaults to true\n                verbose: false # optional, defaults to false\n</code></pre></p> <p>We recommend pinning both a major and minor version number.</p>"},{"location":"getting_started/#docker","title":"Docker","text":"<p>Run <code>dbt-bouncer</code> via Docker:</p> <pre><code>docker run --rm \\\n    --volume \"$PWD\":/app \\\n    ghcr.io/godatadriven/dbt-bouncer:vX.X.X \\\n    --config-file /app/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#pex","title":"Pex","text":"<p>You can also run the <code>.pex</code> (Python EXecutable) artifact directly once you have a python executable (3.9 -&gt; 3.13) installed:</p> <pre><code>wget https://github.com/godatadriven/dbt-bouncer/releases/download/vX.X.X/dbt-bouncer.pex -O dbt-bouncer.pex\n\npython dbt-bouncer.pex --config-file $PWD/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#how-to-contribute-a-check-to-dbt-bouncer","title":"How to contribute a check to <code>dbt-bouncer</code>","text":"<p>See Adding a new check.</p>"},{"location":"getting_started/#how-to-add-a-custom-check-to-dbt-bouncer","title":"How to add a custom check to <code>dbt-bouncer</code>","text":"<p>In addition to the checks built into <code>dbt-bouncer</code>, the ability to add custom checks is supported. This allows users to write checks that are specific to the conventions of their projects. To add a custom check:</p> <ol> <li>Create an empty directory and add a <code>custom_checks_dir</code> key to your config file. The value of this key should be the path to the directory you just created, relative to where the config file is located.</li> <li>In this directory create an empty <code>__init__.py</code> file.</li> <li>In this directory create a subdirectory named <code>catalog</code>, <code>manifest</code> or <code>run_results</code> depending on the type of artifact you want to check.</li> <li> <p>In this subdirectory create a python file that defines a check. The check must meet the following criteria:</p> <ul> <li>Start with \"Check\".</li> <li>Inherit from dbt_bouncer.check_base.BaseCheck.</li> <li>Have a name attribute that is a string whose value is the snake case equivalent of the class name.</li> <li>A default value provided for optional input arguments and arguments that are received at execution time.</li> <li>Have a doc string that includes a description of the check, a list of possible input parameters and at least one example.</li> <li>A clear message in the event of a failure.</li> </ul> </li> <li> <p>In your config file, add the name of the check and any desired arguments.</p> </li> <li>Run <code>dbt-bouncer</code>, your custom check will be executed.</li> </ol> <p>An example:</p> <ul> <li> <p>Directory tree:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 my_custom_checks\n|   \u251c\u2500\u2500 __init__.py\n|   \u2514\u2500\u2500 manifest\n|       \u2514\u2500\u2500 check_custom_to_me.py\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 manifest.json\n</code></pre> </li> <li> <p>Contents of <code>check_custom_to_me.py</code>:</p> <pre><code>from typing import TYPE_CHECKING, Literal\n\nfrom pydantic import Field\n\nfrom dbt_bouncer.check_base import BaseCheck\n\nif TYPE_CHECKING:\n    import warnings\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        from dbt_bouncer.parsers import DbtBouncerModelBase\n\n\nclass CheckModelDepcrecationDate(BaseCheck):\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_deprecation_date\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n\n        assert self.model.deprecation_date is not None, f\"`{self.model.name}` requires a `deprecation_date` to be set.\"\n</code></pre> </li> <li> <p>Contents of <code>dbt-bouncer.yml</code>:</p> <pre><code>custom_checks_dir: my_custom_checks\n\nmanifest_checks:\n    - name: check_model_deprecation_date\n      include: ^models/staging/legacy_erp\n</code></pre> </li> </ul>"},{"location":"users/","title":"Our users","text":"<p>A list of companies using <code>dbt-bouncer</code>.</p> <p>To add your company:</p> <ol> <li>Fork the dbt-bouncer repository.</li> <li>Add your company to the <code>Users</code> section in users.md, retaining alphabetical order.</li> <li>Open a pull request.</li> </ol>"},{"location":"users/#users","title":"Users","text":"<p> Xebia Data </p>"},{"location":"users/#dbt-bouncer-in-the-wild","title":"<code>dbt-bouncer</code> in the wild","text":""},{"location":"users/#blogs","title":"Blogs:","text":"<ul> <li>Maintaining conventions in dbt projects with dbt-bouncer</li> </ul>"},{"location":"users/#repos","title":"Repos","text":"<ul> <li>dbt-beyond-the-basics</li> </ul>"},{"location":"users/#talks","title":"Talks","text":"<ul> <li>\"Maintaining your conventions amid the chaos of dbt\" @ Belgium dbt Meetup #8, slides available here.</li> <li>\"Maintaining your conventions amid the chaos of dbt\" @ Cologne dbt Meetup, slides available here.</li> </ul>"},{"location":"checks/","title":"Checks","text":"<p><code>dbt-bouncer</code> runs checks against artifacts from dbt. These checks fall into three categories:</p> <ul> <li>Catalog checks:<ul> <li>Catalog Sources</li> <li>Columns</li> </ul> </li> <li>Manifest checks:<ul> <li>Exposures</li> <li>Lineage</li> <li>Macros</li> <li>Metadata</li> <li>Models</li> <li>Semantic Models</li> <li>Sources</li> <li>Unit Tests</li> </ul> </li> <li>Run Results checks:<ul> <li>Run Results</li> </ul> </li> </ul>"},{"location":"checks/catalog/check_catalog_sources/","title":"Catalog Checks: Catalog Sources","text":"<p>Note</p> <p>The below checks require both <code>catalog.json</code> and <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSourceColumnsAreAllDocumented</code> <p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p>"},{"location":"checks/catalog/check_catalog_sources/#catalog.check_catalog_sources.CheckSourceColumnsAreAllDocumented","title":"<code>CheckSourceColumnsAreAllDocumented</code>","text":"<p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_source</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>sources</code> <code>List[DbtBouncerSourceBase]</code> <p>List of DbtBouncerSourceBase objects parsed from <code>catalog.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_source_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_catalog_sources.py</code> <pre><code>class CheckSourceColumnsAreAllDocumented(BaseCheck):\n    \"\"\"All columns in a source should be included in the source's properties file, i.e. `.yml` file.\n\n    Receives:\n        catalog_source (CatalogNodes): The CatalogNodes object to check.\n        sources (List[DbtBouncerSourceBase]): List of DbtBouncerSourceBase objects parsed from `catalog.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_source_columns_are_all_documented\n        ```\n\n    \"\"\"\n\n    catalog_source: \"CatalogNodes\" = Field(default=None)\n    name: Literal[\"check_source_columns_are_all_documented\"]\n    sources: List[\"DbtBouncerSourceBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        source = next(\n            s for s in self.sources if s.unique_id == self.catalog_source.unique_id\n        )\n        undocumented_columns = [\n            v.name\n            for _, v in self.catalog_source.columns.items()\n            if v.name not in source.columns\n        ]\n        assert not undocumented_columns, (\n            f\"`{self.catalog_source.unique_id}` has columns that are not included in the sources properties file: {undocumented_columns}\"\n        )\n</code></pre>"},{"location":"checks/catalog/check_columns/","title":"Catalog Checks: Columns","text":"<p>Note</p> <p>The below checks require both <code>catalog.json</code> and <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckColumnDescriptionPopulated</code> <p>Columns must have a populated description.</p> <code>CheckColumnHasSpecifiedTest</code> <p>Columns that match the specified regexp pattern must have a specified test.</p> <code>CheckColumnNameCompliesToColumnType</code> <p>Columns with specified data types must comply to the specified regexp naming pattern.</p> <code>CheckColumnsAreAllDocumented</code> <p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> <code>CheckColumnsAreDocumentedInPublicModels</code> <p>Columns should have a populated description in public models.</p>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnDescriptionPopulated","title":"<code>CheckColumnDescriptionPopulated</code>","text":"<p>Columns must have a populated description.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_column_description_populated\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnDescriptionPopulated(BaseCheck):\n    \"\"\"Columns must have a populated description.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_column_description_populated\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_column_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if self.catalog_node.unique_id.split(\".\")[0] == \"model\":\n            model = next(\n                m for m in self.models if m.unique_id == self.catalog_node.unique_id\n            )\n            non_complying_columns = []\n            for _, v in self.catalog_node.columns.items():\n                if (\n                    model.columns.get(v.name) is None\n                    or len(model.columns[v.name].description.strip()) &lt;= 4\n                ):\n                    non_complying_columns.append(v.name)\n\n            assert not non_complying_columns, (\n                f\"`{self.catalog_node.unique_id.split('.')[-1]}` has columns that do not have a populated description: {non_complying_columns}\"\n            )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnHasSpecifiedTest","title":"<code>CheckColumnHasSpecifiedTest</code>","text":"<p>Columns that match the specified regexp pattern must have a specified test.</p> <p>Parameters:</p> Name Type Description Default <code>column_name_pattern</code> <code>str</code> <p>Regex pattern to match the column name.</p> required <code>test_name</code> <code>str</code> <p>Name of the test to check for.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>tests</code> <code>List[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_column_has_specified_test\n      column_name_pattern: ^is_.*\n      test_name: not_null\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnHasSpecifiedTest(BaseCheck):\n    \"\"\"Columns that match the specified regexp pattern must have a specified test.\n\n    Parameters:\n        column_name_pattern (str): Regex pattern to match the column name.\n        test_name (str): Name of the test to check for.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        tests (List[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_column_has_specified_test\n              column_name_pattern: ^is_.*\n              test_name: not_null\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes\" = Field(default=None)\n    column_name_pattern: str\n    name: Literal[\"check_column_has_specified_test\"]\n    test_name: str\n    tests: List[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        columns_to_check = [\n            v.name\n            for _, v in self.catalog_node.columns.items()\n            if re.compile(self.column_name_pattern.strip()).match(v.name) is not None\n        ]\n        relevant_tests = [\n            t\n            for t in self.tests\n            if hasattr(t, \"test_metadata\") is True\n            and hasattr(t, \"attached_node\") is True\n            and t.test_metadata.name == self.test_name\n            and t.attached_node == self.catalog_node.unique_id\n        ]\n        non_complying_columns = [\n            c\n            for c in columns_to_check\n            if f\"{self.catalog_node.unique_id}.{c}\"\n            not in [f\"{t.attached_node}.{t.column_name}\" for t in relevant_tests]\n        ]\n\n        assert not non_complying_columns, (\n            f\"`{self.catalog_node.unique_id.split('.')[-1]}` has columns that should have a `{self.test_name}` test: {non_complying_columns}\"\n        )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnNameCompliesToColumnType","title":"<code>CheckColumnNameCompliesToColumnType</code>","text":"<p>Columns with specified data types must comply to the specified regexp naming pattern.</p> <p>Parameters:</p> Name Type Description Default <code>column_name_pattern</code> <code>str</code> <p>Regex pattern to match the model name.</p> required <code>types</code> <code>List[str]</code> <p>List of data types to check.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    # DATE columns must end with \"_date\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: .*_date$\n      types:\n        - DATE\n</code></pre> <pre><code>catalog_checks:\n    # BOOLEAN columns must start with \"is_\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^is_.*\n      types:\n        - BOOLEAN\n</code></pre> <pre><code>catalog_checks:\n    # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^[a-z_]*$\n      types:\n        - BIGINT\n        - BOOLEAN\n        - DATE\n        - DOUBLE\n        - INTEGER\n        - VARCHAR\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnNameCompliesToColumnType(BaseCheck):\n    \"\"\"Columns with specified data types must comply to the specified regexp naming pattern.\n\n    Parameters:\n        column_name_pattern (str): Regex pattern to match the model name.\n        types (List[str]): List of data types to check.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            # DATE columns must end with \"_date\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: .*_date$\n              types:\n                - DATE\n        ```\n        ```yaml\n        catalog_checks:\n            # BOOLEAN columns must start with \"is_\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^is_.*\n              types:\n                - BOOLEAN\n        ```\n        ```yaml\n        catalog_checks:\n            # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^[a-z_]*$\n              types:\n                - BIGINT\n                - BOOLEAN\n                - DATE\n                - DOUBLE\n                - INTEGER\n                - VARCHAR\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes\" = Field(default=None)\n    column_name_pattern: str\n    name: Literal[\"check_column_name_complies_to_column_type\"]\n    types: List[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        non_complying_columns = [\n            v.name\n            for _, v in self.catalog_node.columns.items()\n            if v.type in self.types\n            and re.compile(self.column_name_pattern.strip()).match(v.name) is None\n        ]\n\n        assert not non_complying_columns, (\n            f\"`{self.catalog_node.unique_id.split('.')[-1]}` has columns that don't comply with the specified regexp pattern (`{self.column_name_pattern}`): {non_complying_columns}\"\n        )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnsAreAllDocumented","title":"<code>CheckColumnsAreAllDocumented</code>","text":"<p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>models</code> <code>List[DbtBouncerModel]</code> <p>List of DbtBouncerModel objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreAllDocumented(BaseCheck):\n    \"\"\"All columns in a model should be included in the model's properties file, i.e. `.yml` file.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        models (List[DbtBouncerModel]): List of DbtBouncerModel objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_all_documented\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_columns_are_all_documented\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if self.catalog_node.unique_id.split(\".\")[0] == \"model\":\n            model = next(\n                m for m in self.models if m.unique_id == self.catalog_node.unique_id\n            )\n            undocumented_columns = [\n                v.name\n                for _, v in self.catalog_node.columns.items()\n                if v.name not in model.columns\n            ]\n            assert not undocumented_columns, (\n                f\"`{self.catalog_node.unique_id.split('.')[-1]}` has columns that are not included in the models properties file: {undocumented_columns}\"\n            )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnsAreDocumentedInPublicModels","title":"<code>CheckColumnsAreDocumentedInPublicModels</code>","text":"<p>Columns should have a populated description in public models.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>models</code> <code>List[DbtBouncerModel]</code> <p>List of DbtBouncerModel objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_documented_in_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreDocumentedInPublicModels(BaseCheck):\n    \"\"\"Columns should have a populated description in public models.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        models (List[DbtBouncerModel]): List of DbtBouncerModel objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_documented_in_public_models\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_columns_are_documented_in_public_models\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if self.catalog_node.unique_id.split(\".\")[0] == \"model\":\n            model = next(\n                m for m in self.models if m.unique_id == self.catalog_node.unique_id\n            )\n            non_complying_columns = []\n            for _, v in self.catalog_node.columns.items():\n                if model.access.value == \"public\":\n                    column_config = model.columns.get(v.name)\n                    if (\n                        column_config is None\n                        or len(column_config.description.strip()) &lt; 4\n                    ):\n                        non_complying_columns.append(v.name)\n\n            assert not non_complying_columns, (\n                f\"`{self.catalog_node.unique_id.split('.')[-1]}` is a public model but has columns that don't have a populated description: {non_complying_columns}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_exposures/","title":"Manifest Checks: Exposures","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckExposureOnNonPublicModels</code> <p>Exposures should be based on public models only.</p> <code>CheckExposureOnView</code> <p>Exposures should not be based on views.</p>"},{"location":"checks/manifest/check_exposures/#manifest.check_exposures.CheckExposureOnNonPublicModels","title":"<code>CheckExposureOnNonPublicModels</code>","text":"<p>Exposures should be based on public models only.</p> <p>Receives at execution time:</p> Name Type Description <code>exposure</code> <code>DbtBouncerExposureBase</code> <p>The DbtBouncerExposureBase object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnNonPublicModels(BaseCheck):\n    \"\"\"Exposures should be based on public models only.\n\n    Receives:\n        exposure (DbtBouncerExposureBase): The DbtBouncerExposureBase object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_non_public_models\n        ```\n\n    \"\"\"\n\n    exposure: \"DbtBouncerExposureBase\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_exposure_based_on_non_public_models\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        non_public_upstream_dependencies = []\n        for model in self.exposure.depends_on.nodes:\n            if (\n                model.split(\".\")[0] == \"model\"\n                and model.split(\".\")[1] == self.exposure.package_name\n            ):\n                model = next(m for m in self.models if m.unique_id == model)\n                if model.access.value != \"public\":\n                    non_public_upstream_dependencies.append(model.name)\n\n        assert not non_public_upstream_dependencies, (\n            f\"`{self.exposure.name}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_exposures/#manifest.check_exposures.CheckExposureOnView","title":"<code>CheckExposureOnView</code>","text":"<p>Exposures should not be based on views.</p> <p>Parameters:</p> Name Type Description Default <code>materializations_to_include</code> <code>Optional[List[str]]</code> <p>List of materializations to include in the check.</p> required <p>Receives at execution time:</p> Name Type Description <code>exposure</code> <code>DbtBouncerExposureBase</code> <p>The DbtBouncerExposureBase object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n</code></pre> <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnView(BaseCheck):\n    \"\"\"Exposures should not be based on views.\n\n    Parameters:\n        materializations_to_include (Optional[List[str]]): List of materializations to include in the check.\n\n    Receives:\n        exposure (DbtBouncerExposureBase): The DbtBouncerExposureBase object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n        ```\n\n    \"\"\"\n\n    exposure: \"DbtBouncerExposureBase\" = Field(default=None)\n    materializations_to_include: List[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n    )\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_exposure_based_on_view\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        non_table_upstream_dependencies = []\n        for model in self.exposure.depends_on.nodes:\n            if (\n                model.split(\".\")[0] == \"model\"\n                and model.split(\".\")[1] == self.exposure.package_name\n            ):\n                model = next(m for m in self.models if m.unique_id == model)\n                if model.config.materialized in self.materializations_to_include:\n                    non_table_upstream_dependencies.append(model.name)\n\n        assert not non_table_upstream_dependencies, (\n            f\"`{self.exposure.name}` is based on a model that is not a table: {non_table_upstream_dependencies}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_lineage/","title":"Manifest Checks: Lineage","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckLineagePermittedUpstreamModels</code> <p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> <code>CheckLineageSeedCannotBeUsed</code> <p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <code>CheckLineageSourceCannotBeUsed</code> <p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineagePermittedUpstreamModels","title":"<code>CheckLineagePermittedUpstreamModels</code>","text":"<p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_path_pattern</code> <code>str</code> <p>Regexp pattern to match the upstream model(s) path.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The manifest object.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/staging\n      upstream_path_pattern: $^\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/intermediate\n      upstream_path_pattern: ^models/staging|^models/intermediate\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/marts\n      upstream_path_pattern: ^models/staging|^models/intermediate\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineagePermittedUpstreamModels(BaseCheck):\n    \"\"\"Upstream models must have a path that matches the provided `upstream_path_pattern`.\n\n    Parameters:\n        upstream_path_pattern (str): Regexp pattern to match the upstream model(s) path.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The manifest object.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/staging\n              upstream_path_pattern: $^\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/intermediate\n              upstream_path_pattern: ^models/staging|^models/intermediate\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/marts\n              upstream_path_pattern: ^models/staging|^models/intermediate\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_lineage_permitted_upstream_models\"]\n    upstream_path_pattern: str\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        upstream_models = [\n            x\n            for x in self.model.depends_on.nodes\n            if x.split(\".\")[0] == \"model\"\n            and x.split(\".\")[1] == self.manifest_obj.manifest.metadata.project_name\n        ]\n        not_permitted_upstream_models = [\n            upstream_model\n            for upstream_model in upstream_models\n            if re.compile(self.upstream_path_pattern.strip()).match(\n                clean_path_str(\n                    next(\n                        m for m in self.models if m.unique_id == upstream_model\n                    ).original_file_path\n                ),\n            )\n            is None\n        ]\n        assert not not_permitted_upstream_models, (\n            f\"`{self.model.name}` references upstream models that are not permitted: {[m.split('.')[-1] for m in not_permitted_upstream_models]}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineageSeedCannotBeUsed","title":"<code>CheckLineageSeedCannotBeUsed</code>","text":"<p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_seed_cannot_be_used\n      include: ^models/intermediate|^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSeedCannotBeUsed(BaseCheck):\n    \"\"\"Seed cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_seed_cannot_be_used\n              include: ^models/intermediate|^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_lineage_seed_cannot_be_used\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert not [\n            x for x in self.model.depends_on.nodes if x.split(\".\")[0] == \"seed\"\n        ], f\"`{self.model.name}` references a seed even though this is not permitted.\"\n</code></pre>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineageSourceCannotBeUsed","title":"<code>CheckLineageSourceCannotBeUsed</code>","text":"<p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_source_cannot_be_used\n      include: ^models/intermediate|^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSourceCannotBeUsed(BaseCheck):\n    \"\"\"Sources cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_source_cannot_be_used\n              include: ^models/intermediate|^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_lineage_source_cannot_be_used\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert not [\n            x for x in self.model.depends_on.nodes if x.split(\".\")[0] == \"source\"\n        ], f\"`{self.model.name}` references a source even though this is not permitted.\"\n</code></pre>"},{"location":"checks/manifest/check_macros/","title":"Manifest Checks: Macros","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckMacroArgumentsDescriptionPopulated</code> <p>Macro arguments must have a populated description.</p> <code>CheckMacroCodeDoesNotContainRegexpPattern</code> <p>The raw code for a macro must not match the specified regexp pattern.</p> <code>CheckMacroDescriptionPopulated</code> <p>Macros must have a populated description.</p> <code>CheckMacroMaxNumberOfLines</code> <p>Macros may not have more than the specified number of lines.</p> <code>CheckMacroNameMatchesFileName</code> <p>Macros names must be the same as the file they are contained in.</p> <code>CheckMacroPropertyFileLocation</code> <p>Macro properties files must follow the guidance provided by dbt here.</p>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroArgumentsDescriptionPopulated","title":"<code>CheckMacroArgumentsDescriptionPopulated</code>","text":"<p>Macro arguments must have a populated description.</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_arguments_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have their arguments populated\nmanifest_checks:\n    - name: check_macro_arguments_description_populated\n      include: ^macros/common\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroArgumentsDescriptionPopulated(BaseCheck):\n    \"\"\"Macro arguments must have a populated description.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have their arguments populated\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n              include: ^macros/common\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_arguments_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        environment = Environment(autoescape=True, extensions=[TagExtension])\n        ast = environment.parse(self.macro.macro_sql)\n\n        if hasattr(ast.body[0], \"args\"):\n            # Assume macro is a \"true\" macro\n            macro_arguments = [a.name for a in ast.body[0].args]\n        else:\n            if \"materialization\" in [\n                x.value.value\n                for x in ast.body[0].nodes[0].kwargs  # type: ignore[attr-defined]\n                if isinstance(x.value, nodes.Const)\n            ]:\n                # Materializations don't have arguments\n                macro_arguments = []\n            else:\n                # Macro is a test\n                test_macro = next(\n                    x\n                    for x in ast.body\n                    if not isinstance(x.nodes[0], nodes.Call)  # type: ignore[attr-defined]\n                )\n                macro_arguments = [\n                    x.name\n                    for x in test_macro.nodes  # type: ignore[attr-defined]\n                    if isinstance(x, nodes.Name)\n                ]\n\n        # macro_arguments: List of args parsed from macro SQL\n        # macro.arguments: List of args manually added to the properties file\n\n        non_complying_args = []\n        for arg in macro_arguments:\n            macro_doc_raw = [x for x in self.macro.arguments if x.name == arg]\n            if macro_doc_raw == [] or (\n                arg not in [x.name for x in self.macro.arguments]\n                or len(macro_doc_raw[0].description.strip()) &lt;= 4\n            ):\n                non_complying_args.append(arg)\n\n        assert non_complying_args == [], (\n            f\"Macro `{self.macro.name}` does not have a populated description for the following argument(s): {non_complying_args}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroCodeDoesNotContainRegexpPattern","title":"<code>CheckMacroCodeDoesNotContainRegexpPattern</code>","text":"<p>The raw code for a macro must not match the specified regexp pattern.</p> <p>Parameters:</p> Name Type Description Default <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the macro code.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n    - name: check_macro_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroCodeDoesNotContainRegexpPattern(BaseCheck):\n    \"\"\"The raw code for a macro must not match the specified regexp pattern.\n\n    Parameters:\n        regexp_pattern (str): The regexp pattern that should not be matched by the macro code.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n            - name: check_macro_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (\n            re.compile(self.regexp_pattern.strip(), flags=re.DOTALL).match(\n                self.macro.macro_sql\n            )\n            is None\n        ), (\n            f\"Macro `{self.macro.name}` contains a banned string: `{self.regexp_pattern.strip()}`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroDescriptionPopulated","title":"<code>CheckMacroDescriptionPopulated</code>","text":"<p>Macros must have a populated description.</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have a populated description\nmanifest_checks:\n    - name: check_macro_description_populated\n      include: ^macros/common\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroDescriptionPopulated(BaseCheck):\n    \"\"\"Macros must have a populated description.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have a populated description\n        manifest_checks:\n            - name: check_macro_description_populated\n              include: ^macros/common\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert len(self.macro.description.strip()) &gt; 4, (\n            f\"Macro `{self.macro.name}` does not have a populated description.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroMaxNumberOfLines","title":"<code>CheckMacroMaxNumberOfLines</code>","text":"<p>Macros may not have more than the specified number of lines.</p> <p>Parameters:</p> Name Type Description Default <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n      max_number_of_lines: 100\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroMaxNumberOfLines(BaseCheck):\n    \"\"\"Macros may not have more than the specified number of lines.\n\n    Parameters:\n        max_number_of_lines (int): The maximum number of permitted lines.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n              max_number_of_lines: 100\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_max_number_of_lines\"]\n    max_number_of_lines: int = Field(default=50)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        actual_number_of_lines = self.macro.macro_sql.count(\"\\n\") + 1\n\n        assert actual_number_of_lines &lt;= self.max_number_of_lines, (\n            f\"Macro `{self.macro.name}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({self.max_number_of_lines}).\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroNameMatchesFileName","title":"<code>CheckMacroNameMatchesFileName</code>","text":"<p>Macros names must be the same as the file they are contained in.</p> <p>Generic tests are also macros, however to document these tests the \"name\" value must be preceded with \"test_\".</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_name_matches_file_name\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroNameMatchesFileName(BaseCheck):\n    \"\"\"Macros names must be the same as the file they are contained in.\n\n    Generic tests are also macros, however to document these tests the \"name\" value must be preceded with \"test_\".\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_name_matches_file_name\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_name_matches_file_name\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if self.macro.name.startswith(\"test_\"):\n            assert (\n                self.macro.name[5:]\n                == clean_path_str(self.macro.original_file_path)\n                .split(\"/\")[-1]\n                .split(\".\")[0]\n            ), (\n                f\"Macro `{self.macro.unique_id}` is not in a file named `{self.macro.name[5:]}.sql`.\"\n            )\n        else:\n            assert (\n                self.macro.name\n                == clean_path_str(self.macro.original_file_path)\n                .split(\"/\")[-1]\n                .split(\".\")[0]\n            ), f\"Macro `{self.macro.name}` is not in a file of the same name.\"\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroPropertyFileLocation","title":"<code>CheckMacroPropertyFileLocation</code>","text":"<p>Macro properties files must follow the guidance provided by dbt here.</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroPropertyFileLocation(BaseCheck):\n    \"\"\"Macro properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/5-the-rest-of-the-project#how-we-use-the-other-folders).\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_property_file_location\n        ```\n\n    \"\"\"\n\n    macro: \"Macros\" = Field(default=None)\n    name: Literal[\"check_macro_property_file_location\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        expected_substr = \"_\".join(\n            clean_path_str(self.macro.original_file_path)[6:].split(\"/\")[:-1]\n        )\n\n        assert clean_path_str(self.macro.patch_path) is not None, (\n            f\"Macro `{self.macro.name}` is not defined in a `.yml` properties file.\"\n        )\n        properties_yml_name = clean_path_str(self.macro.patch_path).split(\"/\")[-1]\n\n        if clean_path_str(self.macro.original_file_path).startswith(\n            \"tests/\",\n        ):  # Do not check generic tests (which are also macros)\n            pass\n        elif expected_substr == \"\":  # i.e. macro in ./macros\n            assert properties_yml_name == \"_macros.yml\", (\n                f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) should be `_macros.yml`.\"\n            )\n        else:\n            assert properties_yml_name.startswith(\n                \"_\",\n            ), (\n                f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n            )\n            assert expected_substr in properties_yml_name, (\n                f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n            )\n            assert properties_yml_name.endswith(\n                \"__macros.yml\",\n            ), (\n                f\"The properties file for `{self.macro.name.name}` (`{properties_yml_name}`) does not end with `__macros.yml`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_metadata/","title":"Manifest Checks: Metadata","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckProjectName</code> <p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p>"},{"location":"checks/manifest/check_metadata/#manifest.check_metadata.CheckProjectName","title":"<code>CheckProjectName</code>","text":"<p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project_name_pattern</code> <code>str</code> <p>Regex pattern to match the project name.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The manifest object.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_project_name\n      project_name_pattern: ^awesome_company_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_metadata.py</code> <pre><code>class CheckProjectName(BaseModel):\n    \"\"\"Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  `company_&lt;DOMAIN&gt;`.\n\n    Parameters:\n        project_name_pattern (str): Regex pattern to match the project name.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The manifest object.\n\n    Other Parameters:\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_project_name\n              project_name_pattern: ^awesome_company_\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    index: Optional[int] = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    name: Literal[\"check_project_name\"]\n    project_name_pattern: str\n    severity: Optional[Literal[\"error\", \"warn\"]] = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (\n            re.compile(self.project_name_pattern.strip()).match(\n                self.manifest_obj.manifest.metadata.project_name,\n            )\n            is not None\n        ), (\n            f\"Project name (`{self.manifest_obj.manifest.metadata.project_name}`) does not conform to the supplied regex `({self.project_name_pattern.strip()})`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/","title":"Manifest Checks: Models","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckModelAccess</code> <p>Models must have the specified access attribute. Requires dbt 1.7+.</p> <code>CheckModelCodeDoesNotContainRegexpPattern</code> <p>The raw code for a model must not match the specified regexp pattern.</p> <code>CheckModelContractsEnforcedForPublicModel</code> <p>Public models must have contracts enforced.</p> <code>CheckModelDependsOnMultipleSources</code> <p>Models cannot reference more than one source.</p> <code>CheckModelDescriptionPopulated</code> <p>Models must have a populated description.</p> <code>CheckModelDirectories</code> <p>Only specified sub-directories are permitted.</p> <code>CheckModelDocumentedInSameDirectory</code> <p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> <code>CheckModelHasContractsEnforced</code> <p>Model must have contracts enforced.</p> <code>CheckModelHasMetaKeys</code> <p>The <code>meta</code> config for models must have the specified keys.</p> <code>CheckModelHasNoUpstreamDependencies</code> <p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> <code>CheckModelHasTags</code> <p>Models must have the specified tags.</p> <code>CheckModelHasUniqueTest</code> <p>Models must have a test for uniqueness of a column.</p> <code>CheckModelHasUnitTests</code> <p>Models must have more than the specified number of unit tests.</p> <code>CheckModelMaxChainedViews</code> <p>Models cannot have more than the specified number of upstream dependents that are not tables.</p> <code>CheckModelMaxFanout</code> <p>Models cannot have more than the specified number of downstream models.</p> <code>CheckModelMaxNumberOfLines</code> <p>Models may not have more than the specified number of lines.</p> <code>CheckModelMaxUpstreamDependencies</code> <p>Limit the number of upstream dependencies a model has.</p> <code>CheckModelNames</code> <p>Models must have a name that matches the supplied regex.</p> <code>CheckModelPropertyFileLocation</code> <p>Model properties files must follow the guidance provided by dbt here.</p> <code>CheckModelsDocumentationCoverage</code> <p>Set the minimum percentage of models that have a populated description.</p> <code>CheckModelsTestCoverage</code> <p>Set the minimum percentage of models that have at least one test.</p>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelAccess","title":"<code>CheckModelAccess</code>","text":"<p>Models must have the specified access attribute. Requires dbt 1.7+.</p> <p>Parameters:</p> Name Type Description Default <code>access</code> <code>Literal['private', 'protected', 'public']</code> <p>The access level to check for.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n    - name: check_model_access\n      access: protected\n      include: ^models/intermediate\n    - name: check_model_access\n      access: public\n      include: ^models/marts\n    - name: check_model_access\n      access: protected\n      include: ^models/staging\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelAccess(BaseCheck):\n    \"\"\"Models must have the specified access attribute. Requires dbt 1.7+.\n\n    Parameters:\n        access (Literal[\"private\", \"protected\", \"public\"]): The access level to check for.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n            - name: check_model_access\n              access: protected\n              include: ^models/intermediate\n            - name: check_model_access\n              access: public\n              include: ^models/marts\n            - name: check_model_access\n              access: protected\n              include: ^models/staging\n        ```\n\n    \"\"\"\n\n    access: Literal[\"private\", \"protected\", \"public\"]\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_access\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert self.model.access.value == self.access, (\n            f\"`{self.model.name}` has `{self.model.access.value}` access, it should have access `{self.access}`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelCodeDoesNotContainRegexpPattern","title":"<code>CheckModelCodeDoesNotContainRegexpPattern</code>","text":"<p>The raw code for a model must not match the specified regexp pattern.</p> <p>Parameters:</p> Name Type Description Default <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the model code.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n    - name: check_model_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelCodeDoesNotContainRegexpPattern(BaseCheck):\n    \"\"\"The raw code for a model must not match the specified regexp pattern.\n\n    Parameters:\n        regexp_pattern (str): The regexp pattern that should not be matched by the model code.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n            - name: check_model_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (\n            re.compile(self.regexp_pattern.strip(), flags=re.DOTALL).match(\n                self.model.raw_code\n            )\n            is None\n        ), (\n            f\"`{self.model.name}` contains a banned string: `{self.regexp_pattern.strip()}`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelContractsEnforcedForPublicModel","title":"<code>CheckModelContractsEnforcedForPublicModel</code>","text":"<p>Public models must have contracts enforced.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_contract_enforced_for_public_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelContractsEnforcedForPublicModel(BaseCheck):\n    \"\"\"Public models must have contracts enforced.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_contract_enforced_for_public_model\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_contract_enforced_for_public_model\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if self.model.access.value == \"public\":\n            assert self.model.contract.enforced is True, (\n                f\"`{self.model.name}` is a public model but does not have contracts enforced.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDependsOnMultipleSources","title":"<code>CheckModelDependsOnMultipleSources</code>","text":"<p>Models cannot reference more than one source.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_depends_on_multiple_sources\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDependsOnMultipleSources(BaseCheck):\n    \"\"\"Models cannot reference more than one source.\n\n    Parameters:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_depends_on_multiple_sources\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_depends_on_multiple_sources\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_reffed_sources = sum(\n            x.split(\".\")[0] == \"source\" for x in self.model.depends_on.nodes\n        )\n        assert num_reffed_sources &lt;= 1, (\n            f\"`{self.model.name}` references more than one source.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDescriptionPopulated","title":"<code>CheckModelDescriptionPopulated</code>","text":"<p>Models must have a populated description.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_description_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDescriptionPopulated(BaseCheck):\n    \"\"\"Models must have a populated description.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_populated\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert len(self.model.description.strip()) &gt; 4, (\n            f\"`{self.model.name}` does not have a populated description.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDirectories","title":"<code>CheckModelDirectories</code>","text":"<p>Only specified sub-directories are permitted.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>str</code> <p>Regex pattern to the directory to check.</p> required <code>permitted_sub_directories</code> <code>List[str]</code> <p>List of permitted sub-directories.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Example(s):     <pre><code>manifest_checks:\n- name: check_model_directories\n  include: models\n  permitted_sub_directories:\n    - intermediate\n    - marts\n    - staging\n</code></pre> <pre><code># Restrict sub-directories within `./models/staging`\n- name: check_model_directories\n  include: ^models/staging\n  permitted_sub_directories:\n    - crm\n    - payments\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDirectories(BaseCheck):\n    \"\"\"Only specified sub-directories are permitted.\n\n    Parameters:\n        include (str): Regex pattern to the directory to check.\n        permitted_sub_directories (List[str]): List of permitted sub-directories.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Raises:\n        AssertionError: If the model directory does not contain a permitted sub-directory.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n        - name: check_model_directories\n          include: models\n          permitted_sub_directories:\n            - intermediate\n            - marts\n            - staging\n        ```\n        ```yaml\n        # Restrict sub-directories within `./models/staging`\n        - name: check_model_directories\n          include: ^models/staging\n          permitted_sub_directories:\n            - crm\n            - payments\n        ```\n\n    \"\"\"\n\n    include: str\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_directories\"]\n    permitted_sub_directories: List[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            AssertionError: If model located in `./models`.\n\n        \"\"\"\n        matched_path = re.compile(self.include.strip()).match(\n            clean_path_str(self.model.original_file_path)\n        )\n        path_after_match = clean_path_str(self.model.original_file_path)[\n            matched_path.end() + 1 :\n        ]\n        directory_to_check = path_after_match.split(\"/\")[0]\n\n        if directory_to_check.replace(\".sql\", \"\") == self.model.name:\n            raise AssertionError(\n                f\"`{self.model.name}` is not located in a valid sub-directory ({self.permitted_sub_directories}).\"\n            )\n        else:\n            assert directory_to_check in self.permitted_sub_directories, (\n                f\"`{self.model.name}` is located in the `{directory_to_check}` sub-directory, this is not a valid sub-directory ({self.permitted_sub_directories}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDocumentedInSameDirectory","title":"<code>CheckModelDocumentedInSameDirectory</code>","text":"<p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_documented_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDocumentedInSameDirectory(BaseCheck):\n    \"\"\"Models must be documented in the same directory where they are defined (i.e. `.yml` and `.sql` files are in the same directory).\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_documented_in_same_directory\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_documented_in_same_directory\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        model_sql_dir = clean_path_str(self.model.original_file_path).split(\"/\")[:-1]\n        assert (  # noqa: PT018\n            hasattr(self.model, \"patch_path\")\n            and clean_path_str(self.model.patch_path) is not None\n        ), f\"`{self.model.name}` is not documented.\"\n\n        model_doc_dir = clean_path_str(\n            self.model.patch_path[\n                clean_path_str(self.model.patch_path).find(\"models\") :\n            ]\n        ).split(\"/\")[:-1]\n\n        assert model_doc_dir == model_sql_dir, (\n            f\"`{self.model.name}` is documented in a different directory to the `.sql` file: `{'/'.join(model_doc_dir)}` vs `{'/'.join(model_sql_dir)}`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasContractsEnforced","title":"<code>CheckModelHasContractsEnforced</code>","text":"<p>Model must have contracts enforced.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_contracts_enforced\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasContractsEnforced(BaseCheck):\n    \"\"\"Model must have contracts enforced.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_contracts_enforced\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_contracts_enforced\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert self.model.contract.enforced is True, (\n            f\"`{self.model.name}` does not have contracts enforced.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasMetaKeys","title":"<code>CheckModelHasMetaKeys</code>","text":"<p>The <code>meta</code> config for models must have the specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_meta_keys\n      keys:\n        - maturity\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasMetaKeys(BaseCheck):\n    \"\"\"The `meta` config for models must have the specified keys.\n\n    Parameters:\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_meta_keys\n              keys:\n                - maturity\n                - owner\n        ```\n\n    \"\"\"\n\n    keys: NestedDict\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_meta_keys\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        missing_keys = find_missing_meta_keys(\n            meta_config=self.model.meta,\n            required_keys=self.keys.model_dump(),\n        )\n        assert missing_keys == [], (\n            f\"`{self.model.name}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasNoUpstreamDependencies","title":"<code>CheckModelHasNoUpstreamDependencies</code>","text":"<p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_no_upstream_dependencies\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasNoUpstreamDependencies(BaseCheck):\n    \"\"\"Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_no_upstream_dependencies\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_no_upstream_dependencies\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert len(self.model.depends_on.nodes) &gt; 0, (\n            f\"`{self.model.name}` has no upstream dependencies, this likely indicates hard-coded tables references.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasTags","title":"<code>CheckModelHasTags</code>","text":"<p>Models must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <code>tags</code> <code>List[str]</code> <p>List of tags to check for.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasTags(BaseCheck):\n    \"\"\"Models must have the specified tags.\n\n    Parameters:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        tags (List[str]): List of tags to check for.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_tags\"]\n    tags: List[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        missing_tags = [tag for tag in self.tags if tag not in self.model.tags]\n        assert not missing_tags, (\n            f\"`{self.model.name}` is missing required tags: {missing_tags}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasUniqueTest","title":"<code>CheckModelHasUniqueTest</code>","text":"<p>Models must have a test for uniqueness of a column.</p> <p>Parameters:</p> Name Type Description Default <code>accepted_uniqueness_tests</code> <code>Optional[List[str]]</code> <p>List of tests that are accepted as uniqueness tests.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <code>tests</code> <code>List[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_unique_test\n      include: ^models/marts\n</code></pre> <pre><code>manifest_checks:\n# Example of allowing a custom uniqueness test\n    - name: check_model_has_unique_test\n      accepted_uniqueness_tests:\n        - expect_compound_columns_to_be_unique\n        - my_custom_uniqueness_test\n        - unique\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasUniqueTest(BaseCheck):\n    \"\"\"Models must have a test for uniqueness of a column.\n\n    Parameters:\n        accepted_uniqueness_tests (Optional[List[str]]): List of tests that are accepted as uniqueness tests.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        tests (List[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unique_test\n              include: ^models/marts\n        ```\n        ```yaml\n        manifest_checks:\n        # Example of allowing a custom uniqueness test\n            - name: check_model_has_unique_test\n              accepted_uniqueness_tests:\n                - expect_compound_columns_to_be_unique\n                - my_custom_uniqueness_test\n                - unique\n        ```\n\n    \"\"\"\n\n    accepted_uniqueness_tests: Optional[List[str]] = Field(\n        default=[\n            \"expect_compound_columns_to_be_unique\",\n            \"dbt_utils.unique_combination_of_columns\",\n            \"unique\",\n        ],\n    )\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_unique_test\"]\n    tests: List[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_unique_tests = sum(\n            test.attached_node == self.model.unique_id\n            and test.test_metadata.name in self.accepted_uniqueness_tests  # type: ignore[operator]\n            for test in self.tests\n            if hasattr(test, \"test_metadata\")\n        )\n        assert num_unique_tests &gt;= 1, (\n            f\"`{self.model.name}` does not have a test for uniqueness of a column.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasUnitTests","title":"<code>CheckModelHasUnitTests</code>","text":"<p>Models must have more than the specified number of unit tests.</p> <p>Parameters:</p> Name Type Description Default <code>min_number_of_unit_tests</code> <code>Optional[int]</code> <p>The minimum number of unit tests that a model must have.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>unit_tests</code> <code>List[UnitTests]</code> <p>List of UnitTests objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      include: ^models/marts\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      min_number_of_unit_tests: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasUnitTests(BaseCheck):\n    \"\"\"Models must have more than the specified number of unit tests.\n\n    Parameters:\n        min_number_of_unit_tests (Optional[int]): The minimum number of unit tests that a model must have.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        unit_tests (List[UnitTests]): List of UnitTests objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              include: ^models/marts\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              min_number_of_unit_tests: 2\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    min_number_of_unit_tests: int = Field(default=1)\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_has_unit_tests\"]\n    unit_tests: List[\"UnitTests\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            num_unit_tests = len(\n                [\n                    t.unique_id\n                    for t in self.unit_tests\n                    if t.depends_on.nodes[0] == self.model.unique_id\n                ],\n            )\n            assert num_unit_tests &gt;= self.min_number_of_unit_tests, (\n                f\"`{self.model.name}` has {num_unit_tests} unit tests, this is less than the minimum of {self.min_number_of_unit_tests}.\"\n            )\n        else:\n            logging.warning(\n                \"The `check_model_has_unit_tests` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxChainedViews","title":"<code>CheckModelMaxChainedViews</code>","text":"<p>Models cannot have more than the specified number of upstream dependents that are not tables.</p> <p>Parameters:</p> Name Type Description Default <code>materializations_to_include</code> <code>Optional[List[str]]</code> <p>List of materializations to include in the check.</p> required <code>max_chained_views</code> <code>Optional[int]</code> <p>The maximum number of upstream dependents that are not tables.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n      max_chained_views: 5\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxChainedViews(BaseCheck):\n    \"\"\"Models cannot have more than the specified number of upstream dependents that are not tables.\n\n    Parameters:\n        materializations_to_include (Optional[List[str]]): List of materializations to include in the check.\n        max_chained_views (Optional[int]): The maximum number of upstream dependents that are not tables.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n              max_chained_views: 5\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    materializations_to_include: List[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n    )\n    max_chained_views: int = Field(\n        default=3,\n    )\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_max_chained_views\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n\n        def return_upstream_view_models(\n            materializations,\n            max_chained_views,\n            models,\n            model_unique_ids_to_check,\n            package_name,\n            depth=0,\n        ):\n            \"\"\"Recursive function to return model unique_id's of upstream models that are views. Depth of recursion can be specified. If no models meet the criteria then an empty list is returned.\n\n            Returns\n            -\n                List[str]: List of model unique_id's of upstream models that are views.\n\n            \"\"\"\n            if depth == max_chained_views or model_unique_ids_to_check == []:\n                return model_unique_ids_to_check\n\n            relevant_upstream_models = []\n            for model in model_unique_ids_to_check:\n                upstream_nodes = list(\n                    next(m2 for m2 in models if m2.unique_id == model).depends_on.nodes,\n                )\n                if upstream_nodes != []:\n                    upstream_models = [\n                        m\n                        for m in upstream_nodes\n                        if m.split(\".\")[0] == \"model\"\n                        and m.split(\".\")[1] == package_name\n                    ]\n                    for i in upstream_models:\n                        if (\n                            next(\n                                m for m in models if m.unique_id == i\n                            ).config.materialized\n                            in materializations\n                        ):\n                            relevant_upstream_models.append(i)\n\n            depth += 1\n            return return_upstream_view_models(\n                materializations=materializations,\n                max_chained_views=max_chained_views,\n                models=models,\n                model_unique_ids_to_check=relevant_upstream_models,\n                package_name=package_name,\n                depth=depth,\n            )\n\n        assert (\n            len(\n                return_upstream_view_models(\n                    materializations=self.materializations_to_include,\n                    max_chained_views=self.max_chained_views,\n                    models=self.models,\n                    model_unique_ids_to_check=[self.model.unique_id],\n                    package_name=self.manifest_obj.manifest.metadata.project_name,\n                ),\n            )\n            == 0\n        ), (\n            f\"`{self.model.name}` has more than {self.max_chained_views} upstream dependents that are not tables.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxFanout","title":"<code>CheckModelMaxFanout</code>","text":"<p>Models cannot have more than the specified number of downstream models.</p> <p>Parameters:</p> Name Type Description Default <code>max_downstream_models</code> <code>Optional[int]</code> <p>The maximum number of permitted downstream models.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_fanout\n      max_downstream_models: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxFanout(BaseCheck):\n    \"\"\"Models cannot have more than the specified number of downstream models.\n\n    Parameters:\n        max_downstream_models (Optional[int]): The maximum number of permitted downstream models.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_fanout\n              max_downstream_models: 2\n        ```\n\n    \"\"\"\n\n    max_downstream_models: int = Field(default=3)\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_max_fanout\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_downstream_models = sum(\n            self.model.unique_id in m.depends_on.nodes for m in self.models\n        )\n\n        assert num_downstream_models &lt;= self.max_downstream_models, (\n            f\"`{self.model.name}` has {num_downstream_models} downstream models, which is more than the permitted maximum of {self.max_downstream_models}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxNumberOfLines","title":"<code>CheckModelMaxNumberOfLines</code>","text":"<p>Models may not have more than the specified number of lines.</p> <p>Parameters:</p> Name Type Description Default <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n      max_number_of_lines: 150\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxNumberOfLines(BaseCheck):\n    \"\"\"Models may not have more than the specified number of lines.\n\n    Parameters:\n        max_number_of_lines (int): The maximum number of permitted lines.\n\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n              max_number_of_lines: 150\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_max_number_of_lines\"]\n    max_number_of_lines: int = Field(default=100)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        actual_number_of_lines = self.model.raw_code.count(\"\\n\") + 1\n\n        assert actual_number_of_lines &lt;= self.max_number_of_lines, (\n            f\"`{self.model.name}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({self.max_number_of_lines}).\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxUpstreamDependencies","title":"<code>CheckModelMaxUpstreamDependencies</code>","text":"<p>Limit the number of upstream dependencies a model has.</p> <p>Parameters:</p> Name Type Description Default <code>max_upstream_macros</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream macros.</p> required <code>max_upstream_models</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream models.</p> required <code>max_upstream_sources</code> <code>Optional[int]</code> <p>The maximum number of permitted upstream sources.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_upstream_dependencies\n      max_upstream_models: 3\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxUpstreamDependencies(BaseCheck):\n    \"\"\"Limit the number of upstream dependencies a model has.\n\n    Parameters:\n        max_upstream_macros (Optional[int]): The maximum number of permitted upstream macros.\n        max_upstream_models (Optional[int]): The maximum number of permitted upstream models.\n        max_upstream_sources (Optional[int]): The maximum number of permitted upstream sources.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_upstream_dependencies\n              max_upstream_models: 3\n        ```\n\n    \"\"\"\n\n    max_upstream_macros: int = Field(\n        default=5,\n    )\n    max_upstream_models: int = Field(\n        default=5,\n    )\n    max_upstream_sources: int = Field(\n        default=1,\n    )\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_max_upstream_dependencies\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_upstream_macros = len(list(self.model.depends_on.macros))\n        num_upstream_models = len(\n            [m for m in self.model.depends_on.nodes if m.split(\".\")[0] == \"model\"],\n        )\n        num_upstream_sources = len(\n            [m for m in self.model.depends_on.nodes if m.split(\".\")[0] == \"source\"],\n        )\n\n        assert num_upstream_macros &lt;= self.max_upstream_macros, (\n            f\"`{self.model.name}` has {num_upstream_macros} upstream macros, which is more than the permitted maximum of {self.max_upstream_macros}.\"\n        )\n        assert num_upstream_models &lt;= self.max_upstream_models, (\n            f\"`{self.model.name}` has {num_upstream_models} upstream models, which is more than the permitted maximum of {self.max_upstream_models}.\"\n        )\n        assert num_upstream_sources &lt;= self.max_upstream_sources, (\n            f\"`{self.model.name}` has {num_upstream_sources} upstream sources, which is more than the permitted maximum of {self.max_upstream_sources}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelNames","title":"<code>CheckModelNames</code>","text":"<p>Models must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>model_name_pattern</code> <code>str</code> <p>Regexp the model name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_names\n      include: ^models/intermediate\n      model_name_pattern: ^int_\n    - name: check_model_names\n      include: ^models/staging\n      model_name_pattern: ^stg_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelNames(BaseCheck):\n    \"\"\"Models must have a name that matches the supplied regex.\n\n    Parameters:\n        model_name_pattern (str): Regexp the model name must match.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_names\n              include: ^models/intermediate\n              model_name_pattern: ^int_\n            - name: check_model_names\n              include: ^models/staging\n              model_name_pattern: ^stg_\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_names\"]\n    model_name_pattern: str\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (\n            re.compile(self.model_name_pattern.strip()).match(self.model.name)\n            is not None\n        ), (\n            f\"`{self.model.name}` does not match the supplied regex `{self.model_name_pattern.strip()})`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelPropertyFileLocation","title":"<code>CheckModelPropertyFileLocation</code>","text":"<p>Model properties files must follow the guidance provided by dbt here.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelPropertyFileLocation(BaseCheck):\n    \"\"\"Model properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Parameters:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_property_file_location\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_property_file_location\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (  # noqa: PT018\n            hasattr(self.model, \"patch_path\")\n            and clean_path_str(self.model.patch_path) is not None\n        ), f\"`{self.model.name}` is not documented.\"\n\n        expected_substr = (\n            \"_\".join(clean_path_str(self.model.original_file_path).split(\"/\")[1:-1])\n            .replace(\"staging\", \"stg\")\n            .replace(\"intermediate\", \"int\")\n            .replace(\"marts\", \"\")\n        )\n        properties_yml_name = clean_path_str(self.model.patch_path).split(\"/\")[-1]\n\n        assert properties_yml_name.startswith(\n            \"_\",\n        ), (\n            f\"The properties file for `{self.model.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n        )\n        assert expected_substr in properties_yml_name, (\n            f\"The properties file for `{self.model.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n        )\n        assert properties_yml_name.endswith(\n            \"__models.yml\",\n        ), (\n            f\"The properties file for `{self.model.name}` (`{properties_yml_name}`) does not end with `__models.yml`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelsDocumentationCoverage","title":"<code>CheckModelsDocumentationCoverage</code>","text":"<p>Set the minimum percentage of models that have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_model_documentation_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have a populated description.</p> required <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_documentation_coverage\n      min_model_documentation_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsDocumentationCoverage(BaseModel):\n    \"\"\"Set the minimum percentage of models that have a populated description.\n\n    Parameters:\n        min_model_documentation_coverage_pct (float): The minimum percentage of models that must have a populated description.\n\n    Receives:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_documentation_coverage\n              min_model_documentation_coverage_pct: 90\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    index: Optional[int] = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    min_model_documentation_coverage_pct: int = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_documentation_coverage\"]\n    severity: Optional[Literal[\"error\", \"warn\"]] = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_models = len(self.models)\n        models_with_description = []\n        for model in self.models:\n            if len(model.description.strip()) &gt; 4:\n                models_with_description.append(model.unique_id)\n\n        num_models_with_descriptions = len(models_with_description)\n        model_description_coverage_pct = (\n            num_models_with_descriptions / num_models\n        ) * 100\n\n        assert (\n            model_description_coverage_pct &gt;= self.min_model_documentation_coverage_pct\n        ), (\n            f\"Only {model_description_coverage_pct}% of models have a populated description, this is less than the permitted minimum of {self.min_model_documentation_coverage_pct}%.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelsTestCoverage","title":"<code>CheckModelsTestCoverage</code>","text":"<p>Set the minimum percentage of models that have at least one test.</p> <p>Parameters:</p> Name Type Description Default <code>min_model_test_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have at least one test.</p> required <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> required <code>tests</code> <code>List[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_test_coverage\n      min_model_test_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsTestCoverage(BaseModel):\n    \"\"\"Set the minimum percentage of models that have at least one test.\n\n    Parameters:\n        min_model_test_coverage_pct (float): The minimum percentage of models that must have at least one test.\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        tests (List[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_test_coverage\n              min_model_test_coverage_pct: 90\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    index: Optional[int] = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    name: Literal[\"check_model_test_coverage\"]\n    min_model_test_coverage_pct: float = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    severity: Optional[Literal[\"error\", \"warn\"]] = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n    tests: List[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_models = len(self.models)\n        models_with_tests = []\n        for model in self.models:\n            for test in self.tests:\n                if model.unique_id in test.depends_on.nodes:\n                    models_with_tests.append(model.unique_id)\n        num_models_with_tests = len(set(models_with_tests))\n        model_test_coverage_pct = (num_models_with_tests / num_models) * 100\n\n        assert model_test_coverage_pct &gt;= self.min_model_test_coverage_pct, (\n            f\"Only {model_test_coverage_pct}% of models have at least one test, this is less than the permitted minimum of {self.min_model_test_coverage_pct}%.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_semantic_models/","title":"Manifest Checks: Semantic Models","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSemanticModelOnNonPublicModels</code> <p>Semantic models should be based on public models only.</p>"},{"location":"checks/manifest/check_semantic_models/#manifest.check_semantic_models.CheckSemanticModelOnNonPublicModels","title":"<code>CheckSemanticModelOnNonPublicModels</code>","text":"<p>Semantic models should be based on public models only.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>semantic_model</code> <code>DbtBouncerSemanticModelBase</code> <p>The DbtBouncerSemanticModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Semantic model paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Only semantic model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_semantic_model_based_on_non_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_semantic_models.py</code> <pre><code>class CheckSemanticModelOnNonPublicModels(BaseCheck):\n    \"\"\"Semantic models should be based on public models only.\n\n    Receives:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        semantic_model (DbtBouncerSemanticModelBase): The DbtBouncerSemanticModelBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Semantic model paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Only semantic model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_semantic_model_based_on_non_public_models\n        ```\n\n    \"\"\"\n\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_semantic_model_based_on_non_public_models\"]\n    semantic_model: \"DbtBouncerSemanticModelBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        non_public_upstream_dependencies = []\n        for model in self.semantic_model.depends_on.nodes:\n            if (\n                model.split(\".\")[0] == \"model\"\n                and model.split(\".\")[1] == self.semantic_model.package_name\n            ):\n                model = next(m for m in self.models if m.unique_id == model)\n                if model.access.value != \"public\":\n                    non_public_upstream_dependencies.append(model.name)\n\n        assert not non_public_upstream_dependencies, (\n            f\"Semantic model `{self.semantic_model.name}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/","title":"Manifest Checks: Sources","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSourceDescriptionPopulated</code> <p>Sources must have a populated description.</p> <code>CheckSourceFreshnessPopulated</code> <p>Sources must have a populated freshness.</p> <code>CheckSourceHasMetaKeys</code> <p>The <code>meta</code> config for sources must have the specified keys.</p> <code>CheckSourceHasTags</code> <p>Sources must have the specified tags.</p> <code>CheckSourceLoaderPopulated</code> <p>Sources must have a populated loader.</p> <code>CheckSourceNames</code> <p>Sources must have a name that matches the supplied regex.</p> <code>CheckSourceNotOrphaned</code> <p>Sources must be referenced in at least one model.</p> <code>CheckSourcePropertyFileLocation</code> <p>Source properties files must follow the guidance provided by dbt here.</p> <code>CheckSourceUsedByModelsInSameDirectory</code> <p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> <code>CheckSourceUsedByOnlyOneModel</code> <p>Each source can be referenced by a maximum of one model.</p>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceDescriptionPopulated","title":"<code>CheckSourceDescriptionPopulated</code>","text":"<p>Sources must have a populated description.</p> <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSourceBase</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_description_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceDescriptionPopulated(BaseCheck):\n    \"\"\"Sources must have a populated description.\n\n    Receives:\n        source (DbtBouncerSourceBase): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_description_populated\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_description_populated\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert len(self.source.description.strip()) &gt; 4, (\n            f\"`{self.source.source_name}.{self.source.name}` does not have a populated description.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceFreshnessPopulated","title":"<code>CheckSourceFreshnessPopulated</code>","text":"<p>Sources must have a populated freshness.</p> <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_freshness_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceFreshnessPopulated(BaseCheck):\n    \"\"\"Sources must have a populated freshness.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_freshness_populated\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_freshness_populated\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        error_msg = f\"`{self.source.source_name}.{self.source.name}` does not have a populated freshness.\"\n        assert self.source.freshness is not None, error_msg\n        assert (\n            self.source.freshness.error_after.count is not None\n            and self.source.freshness.error_after.period is not None\n        ) or (\n            self.source.freshness.warn_after.count is not None\n            and self.source.freshness.warn_after.period is not None\n        ), error_msg\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceHasMetaKeys","title":"<code>CheckSourceHasMetaKeys</code>","text":"<p>The <code>meta</code> config for sources must have the specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> required <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_meta_keys\n      keys:\n        - contact:\n            - email\n            - slack\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasMetaKeys(BaseCheck):\n    \"\"\"The `meta` config for sources must have the specified keys.\n\n    Parameters:\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_meta_keys\n              keys:\n                - contact:\n                    - email\n                    - slack\n                - owner\n        ```\n\n    \"\"\"\n\n    keys: \"NestedDict\"\n    name: Literal[\"check_source_has_meta_keys\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        missing_keys = find_missing_meta_keys(\n            meta_config=self.source.meta,\n            required_keys=self.keys.model_dump(),\n        )\n\n        assert missing_keys == [], (\n            f\"`{self.source.source_name}.{self.source.name}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceHasTags","title":"<code>CheckSourceHasTags</code>","text":"<p>Sources must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <code>tags</code> <code>List[str]</code> <p>List of tags to check for.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasTags(BaseCheck):\n    \"\"\"Sources must have the specified tags.\n\n    Parameters:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n        tags (List[str]): List of tags to check for.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_has_tags\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n    tags: List[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        missing_tags = [tag for tag in self.tags if tag not in self.source.tags]\n        assert not missing_tags, (\n            f\"`{self.source.source_name}.{self.source.name}` is missing required tags: {missing_tags}.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceLoaderPopulated","title":"<code>CheckSourceLoaderPopulated</code>","text":"<p>Sources must have a populated loader.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_loader_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceLoaderPopulated(BaseCheck):\n    \"\"\"Sources must have a populated loader.\n\n    Parameters:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_loader_populated\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_loader_populated\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert self.source.loader != \"\", (\n            f\"`{self.source.source_name}.{self.source.name}` does not have a populated loader.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceNames","title":"<code>CheckSourceNames</code>","text":"<p>Sources must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>source_name_pattern</code> <code>str</code> <p>Regexp the source name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_names\n      source_name_pattern: &gt;\n        ^[a-z0-9_]*$\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNames(BaseCheck):\n    \"\"\"Sources must have a name that matches the supplied regex.\n\n    Parameters:\n        source_name_pattern (str): Regexp the source name must match.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_names\n              source_name_pattern: &gt;\n                ^[a-z0-9_]*$\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_names\"]\n    source_name_pattern: str\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert (\n            re.compile(self.source_name_pattern.strip()).match(self.source.name)\n            is not None\n        ), (\n            f\"`{self.source.source_name}.{self.source.name}` does not match the supplied regex `({self.source_name_pattern.strip()})`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceNotOrphaned","title":"<code>CheckSourceNotOrphaned</code>","text":"<p>Sources must be referenced in at least one model.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_not_orphaned\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNotOrphaned(BaseCheck):\n    \"\"\"Sources must be referenced in at least one model.\n\n    Receives:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_not_orphaned\n        ```\n\n    \"\"\"\n\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_not_orphaned\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_refs = sum(\n            self.source.unique_id in model.depends_on.nodes for model in self.models\n        )\n        assert num_refs &gt;= 1, (\n            f\"Source `{self.source.source_name}.{self.source.name}` is orphaned, i.e. not referenced by any model.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourcePropertyFileLocation","title":"<code>CheckSourcePropertyFileLocation</code>","text":"<p>Source properties files must follow the guidance provided by dbt here.</p> <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourcePropertyFileLocation(BaseCheck):\n    \"\"\"Source properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_property_file_location\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_property_file_location\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        path_cleaned = clean_path_str(self.source.original_file_path).replace(\n            \"models/staging\", \"\"\n        )\n        expected_substring = \"_\".join(path_cleaned.split(\"/\")[:-1])\n\n        assert path_cleaned.split(\n            \"/\",\n        )[-1].startswith(\n            \"_\",\n        ), (\n            f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{path_cleaned}`) does not start with an underscore.\"\n        )\n        assert expected_substring in path_cleaned, (\n            f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{path_cleaned}`) does not contain the expected substring (`{expected_substring}`).\"\n        )\n        assert path_cleaned.split(\n            \"/\",\n        )[-1].endswith(\n            \"__sources.yml\",\n        ), (\n            f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{path_cleaned}`) does not end with `__sources.yml`.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceUsedByModelsInSameDirectory","title":"<code>CheckSourceUsedByModelsInSameDirectory</code>","text":"<p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> required <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_models_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByModelsInSameDirectory(BaseCheck):\n    \"\"\"Sources can only be referenced by models that are located in the same directory where the source is defined.\n\n    Parameters:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_models_in_same_directory\n        ```\n\n    \"\"\"\n\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_used_by_models_in_same_directory\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        reffed_models_not_in_same_dir = []\n        for model in self.models:\n            if (\n                self.source.unique_id in model.depends_on.nodes\n                and model.original_file_path.split(\"/\")[:-1]\n                != self.source.original_file_path.split(\"/\")[:-1]\n            ):\n                reffed_models_not_in_same_dir.append(model.unique_id.split(\".\")[0])\n\n        assert len(reffed_models_not_in_same_dir) == 0, (\n            f\"Source `{self.source.source_name}.{self.source.name}` is referenced by models defined in a different directory: {reffed_models_not_in_same_dir}\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceUsedByOnlyOneModel","title":"<code>CheckSourceUsedByOnlyOneModel</code>","text":"<p>Each source can be referenced by a maximum of one model.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_only_one_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByOnlyOneModel(BaseCheck):\n    \"\"\"Each source can be referenced by a maximum of one model.\n\n    Receives:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_only_one_model\n        ```\n\n    \"\"\"\n\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_used_by_only_one_model\"]\n    source: \"DbtBouncerSourceBase\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        num_refs = sum(\n            self.source.unique_id in model.depends_on.nodes for model in self.models\n        )\n        assert num_refs &lt;= 1, (\n            f\"Source `{self.source.source_name}.{self.source.name}` is referenced by more than one model.\"\n        )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/","title":"Manifest Checks: Unit Tests","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckUnitTestCoverage</code> <p>Set the minimum percentage of models that have a unit test.</p> <code>CheckUnitTestExpectFormats</code> <p>Unit tests can only use the specified formats.</p> <code>CheckUnitTestGivenFormats</code> <p>Unit tests can only use the specified formats.</p>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestCoverage","title":"<code>CheckUnitTestCoverage</code>","text":"<p>Set the minimum percentage of models that have a unit test.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>min_unit_test_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>List[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>unit_tests</code> <code>List[UnitTests]</code> <p>List of UnitTests objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_coverage\n      min_unit_test_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestCoverage(BaseModel):\n    \"\"\"Set the minimum percentage of models that have a unit test.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        min_unit_test_coverage_pct (float): The minimum percentage of models that must have a unit test.\n\n    Receives:\n        models (List[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        unit_tests (List[UnitTests]): List of UnitTests objects parsed from `manifest.json`.\n\n    Other Parameters:\n        include (Optional[str]): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_coverage\n              min_unit_test_coverage_pct: 90\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n    include: Optional[str] = Field(\n        default=None,\n        description=\"Regexp to match which paths to include.\",\n    )\n    index: Optional[int] = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    min_unit_test_coverage_pct: int = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: List[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_unit_test_coverage\"]\n    severity: Optional[Literal[\"error\", \"warn\"]] = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n    unit_tests: List[\"UnitTests\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            relevant_models = [\n                m.unique_id\n                for m in self.models\n                if object_in_path(self.include, m.original_file_path)\n            ]\n            models_with_unit_test = []\n            for unit_test in self.unit_tests:\n                for node in unit_test.depends_on.nodes:\n                    if node in relevant_models:\n                        models_with_unit_test.append(node)\n\n            num_models_with_unit_tests = len(set(models_with_unit_test))\n            unit_test_coverage_pct = (\n                num_models_with_unit_tests / len(relevant_models)\n            ) * 100\n\n            assert unit_test_coverage_pct &gt;= self.min_unit_test_coverage_pct, (\n                f\"Only {unit_test_coverage_pct}% of models have a unit test, this is less than the permitted minimum of {self.min_unit_test_coverage_pct}%.\"\n            )\n        else:\n            logging.warning(\n                \"The `check_unit_test_expect_format` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestExpectFormats","title":"<code>CheckUnitTestExpectFormats</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>permitted_formats</code> <code>Optional[List[Literal['csv', 'dict', 'sql']]]</code> <p>A list of formats that are allowed to be used for <code>expect</code> input in a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_expect_format\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestExpectFormats(BaseCheck):\n    \"\"\"Unit tests can only use the specified formats.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        permitted_formats (Optional[List[Literal[\"csv\", \"dict\", \"sql\"]]]): A list of formats that are allowed to be used for `expect` input in a unit test.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_expect_format\n              permitted_formats:\n                - csv\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    name: Literal[\"check_unit_test_expect_format\"]\n    permitted_formats: List[Literal[\"csv\", \"dict\", \"sql\"]] = Field(\n        default=[\"csv\", \"dict\", \"sql\"],\n    )\n    unit_test: \"UnitTests\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            assert self.unit_test.expect.format.value in self.permitted_formats, (\n                f\"Unit test `{self.unit_test.name}` has an `expect` format that is not permitted. Permitted formats are: {self.permitted_formats}.\"\n            )\n        else:\n            logging.warning(\n                \"The `check_unit_test_expect_format` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestGivenFormats","title":"<code>CheckUnitTestGivenFormats</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>permitted_formats</code> <code>Optional[List[Literal['csv', 'dict', 'sql']]]</code> <p>A list of formats that are allowed to be used for <code>expect</code> input in a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_given_formats\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestGivenFormats(BaseCheck):\n    \"\"\"Unit tests can only use the specified formats.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        permitted_formats (Optional[List[Literal[\"csv\", \"dict\", \"sql\"]]]): A list of formats that are allowed to be used for `expect` input in a unit test.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_given_formats\n              permitted_formats:\n                - csv\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest\" = Field(default=None)\n    name: Literal[\"check_unit_test_given_formats\"]\n    permitted_formats: List[Literal[\"csv\", \"dict\", \"sql\"]] = Field(\n        default=[\"csv\", \"dict\", \"sql\"],\n    )\n    unit_test: \"UnitTests\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            given_formats = [i.format.value for i in self.unit_test.given]\n            assert all(e in self.permitted_formats for e in given_formats), (\n                f\"Unit test `{self.unit_test.name}` has given formats which are not permitted. Permitted formats are: {self.permitted_formats}.\"\n            )\n        else:\n            logging.warning(\n                \"The `check_unit_test_given_formats` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/run_results/check_run_results/","title":"Run Results Checks","text":"<p>Note</p> <p>The below checks require both <code>manifest.json</code> and <code>run_results.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckRunResultsMaxExecutionTime</code> <p>Each result can take a maximum duration (seconds).</p> <code>CheckRunResultsMaxGigabytesBilled</code> <p>Each result can have a maximum number of gigabytes billed.</p>"},{"location":"checks/run_results/check_run_results/#run_results.check_run_results.CheckRunResultsMaxExecutionTime","title":"<code>CheckRunResultsMaxExecutionTime</code>","text":"<p>Each result can take a maximum duration (seconds).</p> <p>Parameters:</p> Name Type Description Default <code>max_execution_time_seconds</code> <code>float</code> <p>The maximum execution time (seconds) allowed for a node.</p> required <p>Receives at execution time:</p> Name Type Description <code>run_result</code> <code>DbtBouncerRunResult</code> <p>The DbtBouncerRunResult object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      max_execution_time_seconds: 60\n</code></pre> <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      include: ^models/staging # Not a good idea, here for demonstration purposes only\n      max_execution_time_seconds: 10\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxExecutionTime(BaseCheck):\n    \"\"\"Each result can take a maximum duration (seconds).\n\n    Parameters:\n        max_execution_time_seconds (float): The maximum execution time (seconds) allowed for a node.\n\n    Receives:\n        run_result (DbtBouncerRunResult): The DbtBouncerRunResult object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              max_execution_time_seconds: 60\n        ```\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              include: ^models/staging # Not a good idea, here for demonstration purposes only\n              max_execution_time_seconds: 10\n        ```\n\n    \"\"\"\n\n    max_execution_time_seconds: float\n    name: Literal[\"check_run_results_max_execution_time\"]\n    run_result: Optional[\"DbtBouncerRunResultBase\"] = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n        assert self.run_result.execution_time &lt;= self.max_execution_time_seconds, (\n            f\"`{self.run_result.unique_id.split('.')[-1]}` has an execution time ({self.run_result.execution_time} greater than permitted ({self.max_execution_time_seconds}s).\"\n        )\n</code></pre>"},{"location":"checks/run_results/check_run_results/#run_results.check_run_results.CheckRunResultsMaxGigabytesBilled","title":"<code>CheckRunResultsMaxGigabytesBilled</code>","text":"<p>Each result can have a maximum number of gigabytes billed.</p> <p>Note</p> <p>Note that this check only works for the <code>dbt-bigquery</code> adapter.</p> <p>Parameters:</p> Name Type Description Default <code>max_gigabytes_billed</code> <code>float</code> <p>The maximum number of gigabytes billed.</p> required <code>run_result</code> <code>DbtBouncerRunResult</code> <p>The DbtBouncerRunResult object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>exclude</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>Optional[str]</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>severity</code> <code>Optional[Literal['error', 'warn']]</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_gigabytes_billed\n      max_gigabytes_billed: 100\n      exclude: ^seeds\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxGigabytesBilled(BaseCheck):\n    \"\"\"Each result can have a maximum number of gigabytes billed.\n\n    !!! note\n\n        Note that this check only works for the `dbt-bigquery` adapter.\n\n    Parameters:\n        max_gigabytes_billed (float): The maximum number of gigabytes billed.\n        run_result (DbtBouncerRunResult): The DbtBouncerRunResult object to check.\n\n    Other Parameters:\n        exclude (Optional[str]): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (Optional[str]): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        severity (Optional[Literal[\"error\", \"warn\"]]): Severity level of the check. Default: `error`.\n\n    Raises: # noqa:DOC502\n        KeyError: If the `dbt-bigquery` adapter is not used.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_gigabytes_billed\n              max_gigabytes_billed: 100\n              exclude: ^seeds\n        ```\n\n    \"\"\"\n\n    max_gigabytes_billed: float\n    name: Literal[\"check_run_results_max_gigabytes_billed\"]\n    run_result: Optional[\"DbtBouncerRunResultBase\"] = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            RuntimeError: If running with adapter other than `dbt-bigquery`.\n\n        \"\"\"\n        try:\n            gigabytes_billed = self.run_result.adapter_response[\"bytes_billed\"] / (\n                1000**3\n            )\n        except KeyError as e:\n            raise RuntimeError(\n                \"`bytes_billed` not found in adapter response. Are you using the `dbt-bigquery` adapter?\",\n            ) from e\n\n        assert gigabytes_billed &lt; self.max_gigabytes_billed, (\n            f\"`{self.run_result.unique_id.split('.')[-2]}` results in ({gigabytes_billed} billed bytes, this is greater than permitted ({self.max_gigabytes_billed}).\"\n        )\n</code></pre>"}]}