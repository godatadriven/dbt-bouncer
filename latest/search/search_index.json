{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-dbt-bouncer","title":"Welcome to dbt-bouncer","text":"<p><code>dbt-bouncer</code> is an open-source tool that allows you to configure and enforce conventions for your dbt project. The conventions are run against dbt's artifact files (think <code>./target/manifest.json</code>) resulting in speedy tests. Conventions can be specified in a <code>.yml</code> file, allowing maximum customisation to the conventions you wish to follow (or create \ud83d\ude00).</p> <p>Check out our <code>Getting Started</code> guide.</p>"},{"location":"#terminology","title":"Terminology","text":"<ul> <li>Check: A check is a rule run against a dbt artifact.</li> <li>Config file: A <code>.yml</code> file that specifies which checks to run along with any parameters.</li> <li>dbt artifacts directory: The directory that contains the dbt artifacts (<code>manifest.json</code>, etc.), generally this is <code>./target</code>.</li> </ul>"},{"location":"#aims","title":"Aims","text":"<p><code>dbt-bouncer</code> aims to:</p> <ul> <li>Provide a 100% configurable way to enforce conventions in a dbt project.</li> <li>Be as fast as possible, running checks against dbt artifacts.</li> <li>Be as easy as possible to use, with a simple config file written in <code>YML</code>.</li> <li>Be as flexible as possible, allowing checks to be written in python.</li> <li>Provide immediate feedback when run as part of a CI pipeline.</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>dbt-bouncer</code> is free software, released under the MIT license. It originated at Xebia Data in Amsterdam, Netherlands. Source code is available on GitHub.</p> <p>All contributions, in the form of bug reports, pull requests, feedback or discussion are welcome. See the contributing guide for more information.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>dbt-bouncer</code>","text":"<p><code>dbt-bouncer</code> is open source software. Whether you are a seasoned open source contributor or a first-time committer, we welcome and encourage you to contribute code, documentation, ideas, or problem statements to this project.</p>"},{"location":"CONTRIBUTING/#about-this-document","title":"About this document","text":"<p>There are many ways to contribute to the ongoing development of <code>dbt-bouncer</code>, such as by participating in discussions and issues.</p> <p>The rest of this document serves as a more granular guide for contributing code changes to <code>dbt-bouncer</code> (this repository). It is not intended as a guide for using <code>dbt-bouncer</code>, and some pieces assume a level of familiarity with Python development (virtualenvs, <code>uv</code>, etc). Specific code snippets in this guide assume you are using macOS or Linux and are comfortable with the command line.</p> <p>If you get stuck, we're happy to help! Just open an issue or draft PR and we'll do our best to help out.</p>"},{"location":"CONTRIBUTING/#note","title":"Note","text":"<ul> <li>Branches: All pull requests from community contributors should target the <code>main</code> branch (default).</li> </ul>"},{"location":"CONTRIBUTING/#getting-the-code","title":"Getting the code","text":""},{"location":"CONTRIBUTING/#installing-git","title":"Installing git","text":"<p>You will need <code>git</code> in order to download and modify the <code>dbt-bouncer</code> source code. On macOS, the best way to download git is to just install Xcode.</p>"},{"location":"CONTRIBUTING/#contributors","title":"Contributors","text":"<p>You can contribute to <code>dbt-bouncer</code> by forking the <code>dbt-bouncer</code> repository. For a detailed overview on forking, check out the GitHub docs on forking. In short, you will need to:</p> <ol> <li>Fork the <code>dbt-bouncer</code> repository.</li> <li>Clone your fork locally.</li> <li>Check out a new branch for your proposed changes.</li> <li>Push changes to your fork.</li> <li>Open a pull request against <code>godatadriven/dbt-bouncer</code> from your forked repository.</li> </ol>"},{"location":"CONTRIBUTING/#setting-up-an-environment","title":"Setting up an environment","text":"<p>The easiest way to contribute is to open this repo as a Dev Container in VSCode by simply clicking one of the buttons below. Everything you need will already be there!</p> <p></p> <p> </p> <p> </p> <p>Alternatively, you can follow the steps below to set up your local development environment.</p> <p>There are some tools that will be helpful to you in developing locally. While this is the list relevant for <code>dbt-bouncer</code> development, many of these tools are used commonly across open-source python projects.</p>"},{"location":"CONTRIBUTING/#tools","title":"Tools","text":"<p>These are the tools used in <code>dbt-bouncer</code> development and testing:</p> <ul> <li><code>bandit</code> to check for security issues.</li> <li><code>click</code> to create our CLI interface.</li> <li>GitHub Actions for automating tests and checks, once a PR is pushed to the <code>dbt-bouncer</code> repository.</li> <li><code>make</code> to run multiple setup or test steps in combination.</li> <li><code>prek</code> to easily run those checks.</li> <li><code>Pydantic</code> to validate our configuration file.</li> <li><code>pytest</code> to define, discover, and run tests.</li> <li><code>Ruff</code> to lint and format python code.</li> <li><code>ty</code> for type checking.</li> <li><code>uv</code> to manage our python virtual environment.</li> </ul> <p>A deep understanding of these tools in not required to effectively contribute to <code>dbt-bouncer</code>, but we recommend checking out the attached documentation if you're interested in learning more about each one.</p>"},{"location":"CONTRIBUTING/#virtual-environments","title":"Virtual environments","text":"<p>We strongly recommend using virtual environments when developing code in <code>dbt-bouncer</code>. We recommend creating this virtualenv in the root of the <code>dbt-bouncer</code> repository. To create a new virtualenv, run:</p> <pre><code>uv venv\n</code></pre> <p>This will create a new Python virtual environment.</p>"},{"location":"CONTRIBUTING/#setting-environment-variables","title":"Setting environment variables","text":"<p>Set required environment variables by copying <code>.env.example</code> to <code>.env</code> and updating the values.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer-in-development","title":"Running <code>dbt-bouncer</code> in development","text":""},{"location":"CONTRIBUTING/#installation","title":"Installation","text":"<p>First make sure that you set up your <code>virtualenv</code> as described in Setting up an environment. Next, install <code>dbt-bouncer</code>, its dependencies and <code>prek</code>:</p> <pre><code>make install\nuv run prek install\n</code></pre> <p>When installed in this way, any changes you make to your local copy of the source code will be reflected immediately in your next <code>dbt-bouncer</code> run.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer","title":"Running <code>dbt-bouncer</code>","text":"<p>With your virtualenv activated, the <code>dbt-bouncer</code> script should point back to the source code you've cloned on your machine. You can verify this by running <code>which dbt-bouncer</code>. This command should show you a path to an executable in your virtualenv. You can run <code>dbt-bouncer</code> using the provided example configuration file via:</p> <pre><code>uv run dbt-bouncer --config-file dbt-bouncer-example.yml\n</code></pre>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Once you're able to manually test that your code change is working as expected, it's important to run existing automated tests, as well as adding some new ones. These tests will ensure that:</p> <ul> <li>Your code changes do not unexpectedly break other established functionality</li> <li>Your code changes can handle all known edge cases</li> <li>The functionality you're adding will keep working in the future</li> </ul>"},{"location":"CONTRIBUTING/#notice","title":"Notice","text":"<ul> <li>Generating dbt artifacts: If you change the configuration of the dbt project located in <code>dbt_project</code> then you will need to re-generate the dbt artifacts used in testing. To do so, run:</li> </ul> <pre><code>make build-artifacts\n</code></pre>"},{"location":"CONTRIBUTING/#test-commands","title":"Test commands","text":"<p>There are a few methods for running tests locally.</p>"},{"location":"CONTRIBUTING/#makefile","title":"<code>makefile</code>","text":"<p>There are multiple targets in the <code>makefile</code> to run common test suites, most notably:</p> <pre><code># Runs unit tests\nmake test-unit\n\n# Runs integration tests\nmake test-integration\n\n# Runs all tests\nmake test\n\n# Alternative for dev containers only\nmake test-dev-container\n</code></pre>"},{"location":"CONTRIBUTING/#performance-tests","title":"Performance tests","text":"<p>To test the performance on the <code>dbt-bouncer</code> CLI, we use bencher and hyperfine. Provided both are installed, you can run performance tests via:</p> <pre><code>make test-perf\n</code></pre>"},{"location":"CONTRIBUTING/#prek","title":"<code>prek</code>","text":"<p><code>prek</code> takes care of running all code-checks for formatting and linting. Run <code>uv run prek install</code> to install <code>prek</code> in your local environment. Once this is done you can use the git pre-commit hooks to ensure proper formatting and linting.</p>"},{"location":"CONTRIBUTING/#pytest","title":"<code>pytest</code>","text":"<p>Finally, you can also run a specific test or group of tests using <code>pytest</code> directly. With a virtualenv active and dev dependencies installed you can do things like:</p> <pre><code># run all unit tests in a file\nuv run pytest ./tests/unit/checks/catalog/test_columns.py\n\n# run a specific unit test\nuv run pytest ./tests/unit/checks/catalog/test_columns.py::test_check_columns_are_documented_in_public_models\n</code></pre> <p>See pytest usage docs for an overview of useful command-line options.</p>"},{"location":"CONTRIBUTING/#assorted-development-tips","title":"Assorted development tips","text":"<ul> <li>Append <code># ty: ignore</code> to the end of a line if you need to disable <code>ty</code> on that line, preferably with the specific rule to ignore such as <code># ty: ignore[invalid-argument-type]</code>.</li> </ul>"},{"location":"CONTRIBUTING/#adding-a-new-check","title":"Adding a new check","text":"<p>To add a new check follow the below steps:</p> <ol> <li>In <code>./src/dbt_bouncer/checks</code> choose the appropriate directory for your check. For example, if your check only requires the <code>manifest.json</code> then use the <code>manifest</code> directory, if your check requires the <code>catalog.json</code> then use the <code>catalog</code> directory.</li> <li>Within the chosen directory assess if a suitable file already exists. For example, if your check applies to a model then <code>manifest/check_models.py</code> is a suitable location.</li> <li> <p>Within the chosen file, add a Pydantic model, this object must meet the following criteria:</p> <ul> <li>Start with \"Check\".</li> <li>Inherit from <code>dbt_bouncer.check_base.BaseCheck</code>.</li> <li>Have a <code>name</code> attribute that is a string whose value is the snake case equivalent of the class name.</li> <li>A <code>default</code> value provided for optional input arguments and arguments that are received at execution time.</li> <li>Have a doc string that includes a description of the check, a list of possible input parameters and at least one example.</li> <li>A clear message in the event of a failure.</li> </ul> </li> <li> <p>After the check is added, add the check to <code>dbt-bouncer-example.yml</code> and run <code>dbt-bouncer --config-file dbt-bouncer-example.yml</code> to ensure the check succeeds.</p> </li> <li>(Optional) If the dbt project located in <code>./dbt_project</code> needs to be updated then do so and also run <code>make build-artifacts</code> to generate the new test artifacts.</li> <li>Add at least one happy path and one unhappy path test to <code>./tests</code>. The appropriate test file will be the one matching the directory of the check. For example, if the check is in <code>./src/dbt_bouncer/checks/catalog/check_columns.py</code> then the test file will be <code>./tests/unit/checks/catalog/test_columns.py</code>.</li> <li>Run <code>make test</code> to ensure the tests pass.</li> <li>Open a PR \ud83c\udf89!</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>Code can be merged into the current development branch <code>main</code> by opening a pull request. If the proposal looks like it's on the right track, then a <code>dbt-bouncer</code> maintainer will review the PR. They may suggest code revision for style or clarity, or request that you add unit or integration test(s). These are good things! We believe that, with a little bit of help, anyone can contribute high-quality code. Once merged, your contribution will be available for the next release of <code>dbt-bouncer</code>.</p> <p>Automated tests run via GitHub Actions. If you're a first-time contributor, all tests will require a maintainer to approve.</p> <p>Once all tests are passing and your PR has been approved, a <code>dbt-bouncer</code> maintainer will merge your changes into the active development branch. And that's it! Happy developing :tada:</p>"},{"location":"cli/","title":"CLI","text":"<p>This page provides documentation for the <code>dbt-bouncer</code> CLI.</p>"},{"location":"cli/#dbt-bouncer","title":"dbt-bouncer","text":"<p>Entrypoint for dbt-bouncer.</p> <p>Usage:</p> <pre><code>dbt-bouncer [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --config-file PUREPATH          Location of the YML config file.\n  --check TEXT                    Limit the checks run to specific check\n                                  names, comma-separated. Examples:\n                                  'check_model_has_unique_test', 'check_model_\n                                  names,check_source_freshness_populated'.\n  --only TEXT                     Limit the checks run to specific categories,\n                                  comma-separated. Examples:\n                                  'manifest_checks',\n                                  'catalog_checks,manifest_checks'.\n  --output-file PATH              Location of the file where check metadata\n                                  will be saved.\n  --output-format [csv|json|junit|sarif|tap]\n                                  Format for the output file or stdout when no\n                                  output file is specified. Choices: csv,\n                                  json, junit, sarif, tap. Defaults to json.\n  --output-only-failures          If passed then only failures will be\n                                  included in the output file.\n  --show-all-failures             If passed then all failures will be printed\n                                  to the console.\n  -v, --verbosity                 Verbosity.\n  --version                       Show the version and exit.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#init","title":"init","text":"<p>Create a basic dbt-bouncer.yml file.</p> <p>Raises:     RuntimeError: If the config file already exists.</p> <p>Usage:</p> <pre><code>dbt-bouncer init [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/#list","title":"list","text":"<p>List all available dbt-bouncer checks, grouped by category.</p> <p>Usage:</p> <pre><code>dbt-bouncer list [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/#validate","title":"validate","text":"<p>Validate the dbt-bouncer configuration file.</p> <p>Checks for YAML syntax errors and common configuration issues, reporting line numbers for any issues found.</p> <p>Raises:     RuntimeError: If the config file is not found.</p> <p>Usage:</p> <pre><code>dbt-bouncer validate [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --config-file PUREPATH  Location of the YML config file.\n  --help                  Show this message and exit.\n</code></pre>"},{"location":"cli/#validate-command","title":"Validate command","text":"<p>The <code>validate</code> subcommand checks your configuration file for common issues:</p> <pre><code>dbt-bouncer validate --config-file dbt-bouncer.yml\n</code></pre> <p>It will report:</p> <ul> <li>YAML syntax errors with line numbers</li> <li>Missing required fields (like <code>name</code> in checks)</li> <li>Incorrect configuration types (e.g., if a check category is not a list)</li> </ul> <p>Example output for a valid config:</p> <pre><code>Config file is valid!\n</code></pre> <p>Example output for issues:</p> <pre><code>Found 2 issue(s) in config file:\n  Line 1: Check is missing required 'name' field\n  Line 3: YAML syntax error: ...\n</code></pre>"},{"location":"cli/#exit-codes","title":"Exit codes","text":"<p><code>dbt-bouncer</code> returns the following exit codes:</p> <ul> <li> <p><code>0</code>: All checks have succeeded.</p> </li> <li> <p><code>1</code>:</p> <ul> <li>At least one check has failed. Check the logs for more information.</li> <li>A fatal error occurred during check setup or check execution. Check the logs for more information.</li> </ul> </li> </ul>"},{"location":"config_file/","title":"Config file","text":"<p><code>dbt-bouncer</code> requires a config file which determines what checks are run. The following options are available, in order of priority:</p> <ol> <li>A file passed via the <code>--config-file</code> CLI flag.</li> <li>A file path passed via the <code>DBT_BOUNCER_CONFIG_FILE</code> environment variable.</li> <li>A file named <code>dbt-bouncer.yml</code> in the current working directory.</li> <li>A <code>[tool.dbt-bouncer]</code> section in <code>pyproject.toml</code>.</li> </ol> <p>Here is an example config file in <code>yaml</code>:</p> <pre><code># [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `$DBT_PROJECT_DIR/target` if $DBT_PROJECT_DIR is set, else `./target`.\ndbt_artifacts_dir: target\n\nmanifest_checks:\n  - name: check_macro_name_matches_file_name\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <p>And the same config in <code>toml</code>:</p> <pre><code>[tool.dbt-bouncer]\n# [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `$DBT_PROJECT_DIR/target` if $DBT_PROJECT_DIR is set, else `./target`.\ndbt_artifacts_dir = \"target\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_macro_name_matches_file_name\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_model_names\"\ninclude = \"^models/staging\"\nmodel_name_pattern = \"^stg_\"\n</code></pre> <p>For more example config files, see here. For a detailed description of how to use <code>dbt-bouncer</code> in a CI pipeline see here.</p>"},{"location":"config_file/#common-arguments","title":"Common arguments","text":""},{"location":"config_file/#description","title":"Description","text":"<p>All checks support a <code>description</code> argument, this can be used to provide more context about the purpose of a check and why it is implemented. The description is included in the failure message. For example, this check:</p> <pre><code>manifest_checks:\n  - name: check_model_names\n    description: Models in the staging layer should always start with \"stg_\".\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <p>Produces this failure message:</p> <pre><code>`dbt-bouncer` failed. Please see below for more details or run `dbt-bouncer` with the `-v` flag.\nFailed checks:\n| Check name                         | Severity   | Failure message                                                                                                                           |\n|------------------------------------|------------|-------------------------------------------------------------------------------------------------------------------------------------------|\n| check_model_names:36:orders        | error      | Models in the staging layer should always start with \"stg_\". - AssertionError: `orders` does not match the supplied regex `^stg_`.       |\nDone. SUCCESS=250 WARN=0 ERROR=1\n</code></pre>"},{"location":"config_file/#exclude-and-include","title":"Exclude and Include","text":"<p>Most (but not all) checks accept the following optional arguments:</p> <ul> <li><code>exclude</code>: Regexp to match which original file paths to exclude.</li> <li><code>include</code>: Regexp to match which original file paths to include.</li> </ul> <p>Example per resource type:</p> <ul> <li><code>Exposures</code>: The original file path to the properties file where the source is defined, e.g. <code>^models/marts/finance</code> will match exposures defined in <code>./models/marts/finance/_exposures.yml</code>.</li> <li><code>Macros</code>: The original file path to the macro file, e.g. <code>^macros/system</code> will match files like <code>./macros/system/generate_schema_name.sql</code>.</li> <li><code>Models</code>: The original file path to the model file, e.g. <code>^marts</code> will match files like <code>./models/marts/customers.sql</code>.</li> <li><code>Run results</code>: The original file path to the file associated with the resource, e.g. <code>^seeds/finance</code> will match seeds in <code>./seeds/finance</code>, <code>^models/staging</code> will match models and tests in <code>./models/staging</code>.</li> <li><code>Seeds</code>: The original file path to the properties file where the seed is defined, e.g. <code>^seeds</code> will match seeds defined in <code>./seeds/_seeds.yml</code>.</li> <li><code>Semantic models</code>: The original file path to the properties file where the semantic model is defined, e.g. <code>^models/marts/finance</code> will match semantic models defined in <code>./models/marts/finance/_finance__semantic_models.yml</code>.</li> <li><code>Sources</code>: The original file path to the properties file where the source is defined, e.g. <code>^models/staging/crm</code> will match sources defined in <code>./models/staging/crm/_crm__sources.yml</code>.</li> <li><code>Unit tests</code>: The original file path to the properties file where the unit test is defined, e.g. <code>^models/staging/crm</code> will match unit tests defined in <code>^staging/crm/_stg_crm__unit_tests.yml</code>.</li> </ul> <p>To determine if a check accepts these arguments view the Checks page.</p> <p>Note</p> <p><code>exclude</code> and <code>include</code> can be specified at both the check level and the global level. Should both levels be specified, then the check level is applied. All the below examples result in the <code>check_model_names</code> check being run on all models in <code>./models/staging</code>:</p> <pre><code># Specify `include` at the check level only\nmanifest_checks:\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the check and global levels\ninclude: ^models/marts\nmanifest_checks:\n  - name: check_model_names\n    include: ^models/staging\n    model_name_pattern: ^stg_\n</code></pre> <pre><code># Specify `include` at the global level only\ninclude: ^models/staging\nmanifest_checks:\n  - name: check_model_names\n    model_name_pattern: ^stg_\n</code></pre> <p>Note</p> <p>When compiled on Windows machines, keys such as <code>original_file_path</code>, <code>patch_path</code> and <code>path</code> take the form:</p> <pre><code>models\\\\staging\\\\crm\\\\model_1.sql\n</code></pre> <p>When compiled on Linux and Mac machines, these same keys take the form:</p> <pre><code>models/staging/crm/model_1.sql\n</code></pre> <p><code>dbt-bouncer</code> converts all of these paths to the Linux/Mac form, hence when you are supplying values to <code>exclude</code> and <code>include</code> you should use the Linux/Mac form.</p>"},{"location":"config_file/#only","title":"Only","text":"<p><code>dbt-bouncer</code> has checks for three categories: catalog_checks, manifest_checks and run_results_checks. Running <code>dbt-bouncer</code> runs all checks for all categories. If you want to limit <code>dbt-bouncer</code> to a subset of check categories then you can use the <code>--only</code> CLI flag. It takes a command-separated list of check categories to run. Examples:</p> <pre><code>dbt-bouncer --only manifest_checks\ndbt-bouncer --only catalog_checks,manifest_checks\n</code></pre> <p>For a detailed description see here.</p>"},{"location":"config_file/#severity","title":"Severity","text":"<p>All checks accept a <code>severity</code> argument, valid values are:</p> <ul> <li><code>error</code>: If the check fails then <code>dbt-bouncer</code> will return a non-zero exit code.</li> <li><code>warn</code>: If the check fails then <code>dbt-bouncer</code> will return a non-zero exit code.</li> </ul> <p><code>severity</code> can also be specified globally, this is useful when applying <code>dbt-bouncer</code> to a pre-existing dbt project. It allows you to run <code>dbt-bouncer</code>, identify the checks that fail and address the failures in your own time without receiving non-zero exit codes:</p> <pre><code># Specify `severity` at the global levels: all checks will have a `warn` severity, avoiding non-zero exit codes.\nseverity: warn\n\nmanifest_checks:\n  - name: check_exposure_based_on_view\n  ...\n</code></pre> <p>Note</p> <p><code>severity</code> can be specified at both the check level and the global level. Should both levels be specified, then the global level is applied.</p> <pre><code># No `severity` specified: check will have an `error` severity.\nmanifest_checks:\n  - name: check_exposure_based_on_view\n</code></pre> <pre><code># Specify `severity` at the check level only: check will have a `warn` severity.\nmanifest_checks:\n  - name: check_exposure_based_on_view\n    severity: warn\n</code></pre> <pre><code># Specify `severity` at the check and global levels: check will have a `warn` severity.\nseverity: warn\nmanifest_checks:\n  - name: check_exposure_based_on_view\n    severity: error\n</code></pre> <pre><code># Specify `severity` at the global level only: check will have a `warn` severity.\nseverity: warn\nmanifest_checks:\n  - name: check_exposure_based_on_view\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#can-other-tools-perform-the-same-checks-as-dbt-bouncer","title":"Can other tools perform the same checks as <code>dbt-bouncer</code>?","text":"<p>There are several other tools that perform similar tasks as <code>dbt-bouncer</code>.</p> <ul> <li>dbt-checkpoint: A collection of <code>pre-commit</code> hooks for dbt projects. Tests are written in python. Configuration is performed via <code>.pre-commit-config.yaml</code>. Provided the dbt artifacts have already been generated, <code>dbt-checkpoint</code> does not need access to the underlying database. The hooks execute when a new commit is made, as such <code>dbt-checkpoint</code> is designed to be run only as part of <code>pre-commit</code> (or <code>prek</code>).</li> <li>dbt-project-evaluator: This is a dbt package from dbt Labs. Tests are written in <code>.sql</code> files using a combination of Jinja and SQL. Configuration is performed via <code>dbt_project.yml</code> and seed files (i.e. csv files). Requires a connection to underlying database. Designed to be run both in a CI pipeline and also during active development.</li> <li>dbt-score: This is a python package installable via <code>pip</code>. A collection of tests that apply only to dbt models. Tests can be executed from the command line. Tests are written in python. Configuration is performed via a <code>pyproject.toml</code> file. Provided the dbt artifacts have already been generated, <code>dbt-score</code> does not need access to the underlying database. Designed to be run during development.</li> </ul> <p>While the above tools inhabit the same space as <code>dbt-bouncer</code> they do not provide what we consider to be the optimum experience that <code>dbt-bouncer</code> provides:</p> <ul> <li>Designed to run both locally and in a CI pipeline.</li> <li>Configurable via a file format, <code>YML</code>, that dbt developers are already familiar with.</li> <li>Does not require database access.</li> <li>Can run tests against any of dbt's artifacts.</li> <li>Allows tests to be written in python.</li> </ul> <p>As such we consider <code>dbt-bouncer</code> to be the best tool to enforce conventions in a dbt project.</p> <p>Tip</p> <p><code>dbt-bouncer</code> can perform all the tests currently included in <code>dbt-checkpoint</code>, <code>dbt-project-evaluator</code> and <code>dbt-score</code>. If you see an existing test that is not possible with <code>dbt-bouncer</code>, open an issue and we'll add it!</p>"},{"location":"faq/#does-dbt-bouncer-work-with-dbt-cloud","title":"Does <code>dbt-bouncer</code> work with dbt Cloud?","text":"<p>Yes! As <code>dbt-bouncer</code> runs on the artifacts generated by dbt, it can be used with dbt Cloud as long as the artifacts generated by the CI job in dbt Cloud are available.</p> <p>For GitHub this can be achieved using the pgoslatara/dbt-cloud-download-artifacts-action action:</p> <pre><code>name: CI pipeline\n\non:\n  pull_request:\n      branches:\n          - main\n\njobs:\n    download-artifacts:\n        runs-on: ubuntu-latest\n        permissions:\n            pull-requests: write\n        steps:\n          - name: Checkout\n            uses: actions/checkout@v4\n\n          - name: Download dbt artifacts\n            uses: pgoslatara/dbt-cloud-download-artifacts-action@v1\n            with:\n              commit-sha: ${{ github.event.pull_request.head.sha }}\n              dbt-cloud-api-token: ${{ secrets.DBT_CLOUD_API_TOKEN }}\n\n          - name: Run dbt-bouncer\n            uses: godatadriven/dbt-bouncer@vX.X\n</code></pre> <p>Warning</p> <p>dbt Cloud now supports a \"versionless\" option, which allows dbt projects to be run with the latest version of dbt. One effect of choosing this option is that dbt artifacts may receive non-breaking changes (source), these may or may not be compatible with <code>dbt-bouncer</code>. If you encounter a bug as a result of this, please open an issue and we'll investigate.</p>"},{"location":"faq/#how-to-configure-dbt-bouncer-for-use-in-a-ci-pipeline","title":"How to configure <code>dbt-bouncer</code> for use in a CI pipeline?","text":"<p><code>dbt-bouncer</code> is designed to be use primarily in a CI pipeline such as GitHub Actions or Azure DevOps. To do this we create a config file such as:</p> <pre><code>catalog_checks:\n  - name: check_column_description_populated\n    include: ^models/marts\n\nmanifest_checks:\n  - name: check_model_directories\n    include: ^models\n    permitted_sub_directories:\n      - intermediate\n      - marts\n      - staging\n      - utilities\n\nrun_results_checks:\n  - name: check_run_results_max_execution_time\n    max_execution_time_seconds: 10\n</code></pre> <p>The goal of a CI pipeline is to test the changes in a pull request but also to provide feedback to the developer as quickly as possible without incurring unnecessary costs (time, financial, compute, etc.). To achieve this we can combine several features of dbt and <code>dbt-bouncer</code>:</p> <ol> <li> <p>By running <code>dbt parse</code>, dbt can generate a <code>manifest.json</code> without a database connection. We can then run our manifest checks via:</p> <pre><code>dbt-bouncer --only manifest_checks\n</code></pre> </li> <li> <p>dbt requires models to be materialised before it can generate a <code>catalog.json</code> file. By running <code>dbt run --empty</code> we can materialise every model without processing any data. Once these materialisations are performed we can run our catalog checks via:</p> <pre><code>dbt-bouncer --only catalog_checks\n</code></pre> </li> <li> <p>Typically a CI pipeline will run a <code>dbt build</code> command with flags such as <code>--state</code> and/or <code>--defer</code>. After this command has completed we can run our run results checks via:</p> <pre><code>dbt-bouncer --only run_results_checks\n</code></pre> <p>Additionally, you can use the <code>--check</code> flag to run only specific checks by name. This is useful for debugging or validating a single convention:</p> <pre><code>dbt-bouncer --check check_model_has_unique_test\n</code></pre> <p>Multiple checks can be specified as a comma-separated list:</p> <pre><code>dbt-bouncer --check check_model_has_unique_test,check_model_description_populated\n</code></pre> <p>The <code>--check</code> and <code>--only</code> flags can be combined: <code>--only</code> restricts to the specified categories, then <code>--check</code> further narrows to only the named checks within those categories.</p> </li> </ol> <p>By using this approach, and combining with your own unique constraints and desires, <code>dbt-bouncer</code> can be used efficiently as part of your CI pipeline.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-in-a-monorepo","title":"How to set up <code>dbt-bouncer</code> in a monorepo?","text":"<p>A monorepo may consist of one directory with a dbt project and other directories with unrelated code. It may be desired for <code>dbt-bouncer</code> to be configured from the root directory. Sample directory tree:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 dbt-project\n\u2502   \u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 dbt_project.yml\n\u2502   \u2514\u2500\u2500 profiles.yml\n\u2514\u2500\u2500 package-a\n    \u251c\u2500\u2500 src\n    \u251c\u2500\u2500 tests\n    \u2514\u2500\u2500 package.json\n</code></pre> <p>To ease configuration you can use <code>exclude</code> or <code>include</code> at the global level (see Config File for more details). For the above example <code>dbt-bouncer.yml</code> could be configured as:</p> <pre><code>dbt_artifacts_dir: dbt-project/target\ninclude: ^dbt-project\n\nmanifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre> <p><code>dbt-bouncer</code> can now be run from the root directory.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-in-a-dbt-mesh","title":"How to set up <code>dbt-bouncer</code> in a dbt Mesh?","text":"<p>A dbt Mesh is a collection of dbt projects in an organisation, some of which can read models from other dbt projects. Natively supported by dbt Cloud, a dbt Mesh can also be set up with dbt Core using a plugin such as dbt-loom.</p> <p>One challenge in a dbt Mesh is the large number of developers working across multiple dbt projects leading to differing conventions being implemented. There are multiple approaches to using <code>dbt-bouncer</code> in a dbt Mesh, two are outlined below.</p>"},{"location":"faq/#approach-1-individual-dbt-bounceryml-configuration-file","title":"Approach 1: Individual <code>dbt-bouncer.yml</code> configuration file","text":"<p>Each dbt project can have its own <code>dbt-bouncer.yml</code> configuration file. This allows each project to adopt and implement its own conventions in addition to any conventions to be shared across all dbt projects. Should a breaking change be required to the config file then each dbt project can be updated independently at a time that makes sense.</p> <p>This is the recommended approach due to its simplicity and ability to update each dbt project independently.</p>"},{"location":"faq/#approach-2-centralised-dbt-bounceryml-configuration-file-shared-via-git-submodule","title":"Approach 2: Centralised <code>dbt-bouncer.yml</code> configuration file shared via git submodule","text":"<p>Warning</p> <p>With this approach, a change to the centralised <code>dbt-bouncer.yml</code> file may result in CI pipelines in dbt projects failing despite no changes being made to these projects. As such we recommend implementing this approach only after extensive discussion with all dbt project developers so that all dbt projects can be brought into line before <code>dbt-bouncer</code> is enforced in the CI pipeline.</p> <p>Should it be necessary for a breaking change to be made to the centralised <code>dbt-bouncer.yml</code> configuration file, we recommend setting the <code>severity</code> of the relevant check to <code>warn</code> so that CI pipelines in dbt projects will not fail and maintainers have sufficient time to make the necessary changes.</p> <p>Git submodules allow the contents from one repository to be accessible from a different repository. Such a setup for <code>dbt-bouncer</code> can be achieved as follows (this example uses GitHub, similar setups can be achieved with other providers):</p> <ol> <li> <p>Set up a dedicated repository to store a centralised <code>dbt-bouncer.yml</code> configuration file that will be used by all dbt projects. Let's call this repository <code>dbt-bouncer-config</code>.</p> </li> <li> <p>The contents of the <code>dbt-bouncer.yml</code> file in <code>dbt-bouncer-config</code> should contain the following configuration for <code>dbt_artifacts_dir</code>:</p> <pre><code>dbt_artifacts_dir: ../target\n\nmanifest_checks:\n  - name: check_model_directories\n    include: ^models\n    permitted_sub_directories:\n      - intermediate\n      - marts\n      - staging\n      - utilities\n  ...\n</code></pre> </li> <li> <p>In every repository add a git submodule via:</p> <pre><code>git submodule add git@github.com:&lt;YOUR_ORG&gt;/dbt-bouncer-config.git\n</code></pre> </li> <li> <p>Run <code>dbt-bouncer</code>:</p> <pre><code>dbt-bouncer --config-file dbt-bouncer-config/dbt-bouncer.yml\n</code></pre> </li> </ol> <p>Your directory tree should look like this:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer-config\n\u2502   \u2514\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 macros\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 models\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 profiles.yml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 target\n    \u251c\u2500\u2500 catalog.json\n    \u251c\u2500\u2500 manifest.json\n    \u2514\u2500\u2500 run_results.json\n</code></pre> <p>Note: if you update your central <code>dbt-bouncer.yml</code> file, you will need to run <code>git submodule update --remote</code> in every repository to update the submodule.</p>"},{"location":"faq/#how-to-set-up-dbt-bouncer-with-prekpre-commit","title":"How to set up <code>dbt-bouncer</code> with <code>prek</code>/<code>pre-commit</code>?","text":"<p>You can use the official pre-commit hook, in your <code>.pre-commit-config.yaml</code> file:</p> <pre><code>repos:\n  - repo: https://github.com/godatadriven/dbt-bouncer\n    rev: v1.19.0 # Check https://github.com/godatadriven/dbt-bouncer/releases for latest version\n    hooks:\n      - id: dbt-bouncer\n        args: [\"--config-file\", \"&lt;PATH_TO_CONFIG_FILE&gt;\"] # Optional\n</code></pre> <p>Alternatively, you can use a local hook to run automatically run <code>dbt-bouncer</code> before your commits get added to the git tree.</p> <pre><code>- repo: local\n  hooks:\n    - id: dbt-bouncer\n      name: dbt-bouncer\n      entry: dbt-bouncer # --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n      language: system\n      pass_filenames: false\n      always_run: true\n</code></pre>"},{"location":"faq/#can-i-skip-specific-checks-for-an-exposuremodelsourceetc","title":"Can I skip specific checks for an exposure/model/source/etc.?","text":"<p>Yes! Many dbt objects permit adding a <code>meta</code> config field (docs), this can be used to skip checks for the object. For example, for a model:</p> <pre><code>models:\n  - name: my_model\n    config:\n      meta:\n        dbt-bouncer:\n          skip_checks:\n            - check_model_description_populated\n            - check_model_has_meta_keys\n          reason: We recommend documenting why these checks are being skipped.\n</code></pre> <p>And for a source:</p> <pre><code>version: 2\n\nsources:\n  - name: source_system\n    tables:\n      - name: source_1\n        config:\n          meta:\n            dbt-bouncer:\n              skip_checks:\n                - check_source_description_populated\n                - check_source_has_meta_keys\n                - check_source_has_tags\n                - check_source_names\n              reason: We recommend documenting why these checks are being skipped.\n</code></pre> <p>Similar can be done for other objects that support the <code>meta</code> value.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#how-to-run-dbt-bouncer","title":"How to run <code>dbt-bouncer</code>","text":"<ol> <li> <p>Generate dbt artifacts by running a dbt command:</p> <ul> <li><code>dbt parse</code> to generate a <code>manifest.json</code> artifact (no database connection required!).</li> <li><code>dbt docs generate</code> to generate a <code>catalog.json</code> artifact (necessary if you are using catalog checks).</li> <li><code>dbt run</code> (or any other command that implies it e.g. <code>dbt build</code>) to generate a <code>run_results.json</code> artifact (necessary if you are using run results checks).</li> </ul> </li> <li> <p>Create a <code>dbt-bouncer.yml</code> config file, details here. Alternatively, you can run <code>dbt-bouncer init</code> to generate a basic configuration file.</p> </li> <li> <p>Run <code>dbt-bouncer</code> to validate that your conventions are being maintained.</p> </li> </ol>"},{"location":"getting_started/#installing-with-python","title":"Installing with Python","text":"<p>Install from pypi.org:</p> <pre><code>pip install dbt-bouncer # or via any other package manager\n</code></pre> <p>Run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nLoaded config from dbt-bouncer-example.yml...\nValidating conf...\n</code></pre> <p><code>dbt-bouncer</code> also supports a verbose mode, run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt; -v\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nconfig_file=PosixPath('dbt-bouncer-example.yml')\nconfig_file_source='COMMANDLINE'\nConfig file passed via command line: dbt-bouncer-example.yml\nLoading config from /home/pslattery/repos/dbt-bouncer/dbt-bouncer-example.yml...\nLoading config from dbt-bouncer-example.yml...\nLoaded config from dbt-bouncer-example.yml...\nconf={'dbt_artifacts_dir': 'dbt_project/target', 'catalog_checks': [{'name': 'check_column_name_complies_to_column_type', 'column_name_pattern': '^is_.*', 'exclude': '^staging', 'types': ['BOOLEAN']}]}\nValidating conf...\n</code></pre>"},{"location":"getting_started/#running-as-an-executable-using-uv","title":"Running as an executable using uv","text":"<p>Run <code>dbt-bouncer</code> as a standalone Python executable using <code>uv</code>:</p> <pre><code>uvx dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#github-actions","title":"GitHub Actions","text":"<p>Run <code>dbt-bouncer</code> as part of your CI pipeline:</p> <pre><code>name: CI pipeline\n\non:\n  pull_request:\n      branches:\n          - main\n\njobs:\n    run-dbt-bouncer:\n        permissions:\n            pull-requests: write # Required to write a comment on the PR\n        runs-on: ubuntu-latest\n        steps:\n            - name: Checkout\n              uses: actions/checkout@v4\n\n            - name: Generate or fetch dbt artifacts\n              run: ...\n\n            - uses: godatadriven/dbt-bouncer@vX.X\n              with:\n                check: '' # optional, comma-separated check names to run\n                config-file: ./&lt;PATH_TO_CONFIG_FILE&gt;\n                only: manifest_checks # optional, defaults to running all checks\n                output-file: results.json # optional, default does not save a results file\n                output-format: json # optional, one of: csv, json, junit, sarif, tap. Defaults to json\n                output-only-failures: false # optional, defaults to true\n                send-pr-comment: true # optional, defaults to true\n                show-all-failures: false # optional, defaults to false\n                verbose: false # optional, defaults to false\n</code></pre> <p>We recommend pinning both a major and minor version number.</p>"},{"location":"getting_started/#docker","title":"Docker","text":"<p>Run <code>dbt-bouncer</code> via Docker:</p> <pre><code>docker run --rm \\\n    --volume \"$PWD\":/app \\\n    ghcr.io/godatadriven/dbt-bouncer:vX.X.X \\\n    --config-file /app/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#programmatic-invocation","title":"Programmatic invocation","text":"<p><code>dbt-bouncer</code> can be invoked programmatically. <code>run_bouncer</code> returns the exit code of the process.</p> <pre><code>from pathlib import Path\nfrom dbt_bouncer.main import run_bouncer\n\nexit_code = run_bouncer(\n    config_file=Path(\"path/to/dbt-bouncer.yml\"),\n    output_file=Path(\"results.json\"),  # optional\n    output_format=\"json\",  # optional, one of: \"csv\", \"json\", \"junit\", \"sarif\", \"tap\". Defaults to \"json\"\n)\n</code></pre>"},{"location":"getting_started/#how-to-contribute-a-check-to-dbt-bouncer","title":"How to contribute a check to <code>dbt-bouncer</code>","text":"<p>See Adding a new check.</p>"},{"location":"getting_started/#how-to-add-a-custom-check-to-dbt-bouncer","title":"How to add a custom check to <code>dbt-bouncer</code>","text":"<p>In addition to the checks built into <code>dbt-bouncer</code>, the ability to add custom checks is supported. This allows users to write checks that are specific to the conventions of their projects. To add a custom check:</p> <ol> <li>Create an empty directory and add a <code>custom_checks_dir</code> key to your config file. The value of this key should be the path to the directory you just created, relative to where the config file is located.</li> <li>In this directory create an empty <code>__init__.py</code> file.</li> <li>In this directory create a subdirectory named <code>catalog</code>, <code>manifest</code> or <code>run_results</code> depending on the type of artifact you want to check.</li> <li> <p>In this subdirectory create a python file that defines a check. The check must meet the following criteria:</p> <pre><code>    * Start with \"Check\".\n    * Inherit from dbt_bouncer.check_base.BaseCheck.\n    * Have a name attribute that is a string whose value is the snake case equivalent of the class name.\n    * A default value provided for optional input arguments and arguments that are received at execution time.\n    * Have a doc string that includes a description of the check, a list of possible input parameters and at least one example.\n    * A clear message in the event of a failure.\n</code></pre> </li> <li> <p>In your config file, add the name of the check and any desired arguments.</p> </li> <li>Run <code>dbt-bouncer</code>, your custom check will be executed.</li> </ol> <p>An example:</p> <ul> <li> <p>Directory tree:</p> <pre><code>.\n\u251c\u2500\u2500 dbt-bouncer.yml\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 my_custom_checks\n|   \u251c\u2500\u2500 __init__.py\n|   \u2514\u2500\u2500 manifest\n|       \u2514\u2500\u2500 check_custom_to_me.py\n\u2514\u2500\u2500 target\n    \u2514\u2500\u2500 manifest.json\n</code></pre> </li> <li> <p>Contents of <code>check_custom_to_me.py</code>:</p> <pre><code>from typing import TYPE_CHECKING, Literal\n\nfrom pydantic import Field\n\nfrom dbt_bouncer.check_base import BaseCheck\nfrom dbt_bouncer.utils import get_clean_model_name\n\nif TYPE_CHECKING:\n    import warnings\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning)\n        from dbt_bouncer.parsers import DbtBouncerModelBase\n\n\nclass CheckModelDepcrecationDate(BaseCheck):\n\n    model: \"DbtBouncerModelBase\" = Field(default=None)\n    name: Literal[\"check_model_deprecation_date\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\"\"\"\n\n        assert self.model.deprecation_date is not None, f\"`{get_clean_model_name(self.model.unique_id)}` requires a `deprecation_date` to be set.\"\n</code></pre> </li> <li> <p>Contents of <code>dbt-bouncer.yml</code>:</p> <pre><code>custom_checks_dir: my_custom_checks\n\nmanifest_checks:\n    - name: check_model_deprecation_date\n      include: ^models/staging/legacy_erp\n</code></pre> </li> </ul>"},{"location":"users/","title":"Our users","text":"<p>A list of companies using <code>dbt-bouncer</code>.</p> <p>To add your company:</p> <ol> <li>Fork the dbt-bouncer repository.</li> <li>Add your company to the <code>Users</code> section in users.md, retaining alphabetical order.</li> <li>Open a pull request.</li> </ol>"},{"location":"users/#users","title":"Users","text":"<p> Aurai </p> <p> Canon </p> <p> Dataroots </p> <p> Nationale Loterij </p> <p> Tiqets </p> <p> Xebia Data </p>"},{"location":"users/#dbt-bouncer-in-the-wild","title":"<code>dbt-bouncer</code> in the wild","text":""},{"location":"users/#blogs","title":"Blogs","text":"<ul> <li>Automate Sensitive Data Protection with Metadata-Driven Masking</li> <li>Maintaining conventions in dbt projects with dbt-bouncer</li> </ul>"},{"location":"users/#repos","title":"Repos","text":"<ul> <li>dbt-beyond-the-basics</li> </ul>"},{"location":"users/#talks","title":"Talks","text":"<ul> <li>\"Maintaining your conventions amid the chaos of dbt\" @ Belgium dbt Meetup #8, slides available here.</li> <li>\"Maintaining your conventions amid the chaos of dbt\" @ Cologne dbt Meetup, slides available here.</li> <li>\"Maintaining dbt project standards with dbt-bouncer\" @ GoDataFest 2025, slides available here, video available here.</li> </ul>"},{"location":"checks/","title":"Checks","text":"<p><code>dbt-bouncer</code> runs checks against artifacts from dbt. These checks fall into three categories:</p> <ul> <li>Catalog checks:<ul> <li>Catalog Sources</li> <li>Columns</li> </ul> </li> <li>Manifest checks:<ul> <li>Exposures</li> <li>Lineage</li> <li>Macros</li> <li>Metadata</li> <li>Models</li> <li>Seeds</li> <li>Semantic Models</li> <li>Snapshots</li> <li>Sources</li> <li>Tests</li> <li>Unit Tests</li> </ul> </li> <li>Run Results checks:<ul> <li>Run Results</li> </ul> </li> </ul>"},{"location":"checks/catalog/check_catalog_sources/","title":"Catalog Checks: Catalog Sources","text":"<p>Note</p> <p>The below checks require both <code>catalog.json</code> and <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSourceColumnsAreAllDocumented</code> <p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p>"},{"location":"checks/catalog/check_catalog_sources/#catalog.check_catalog_sources.CheckSourceColumnsAreAllDocumented","title":"<code>CheckSourceColumnsAreAllDocumented</code>","text":"<p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_source</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>sources</code> <code>list[DbtBouncerSourceBase]</code> <p>List of DbtBouncerSourceBase objects parsed from <code>catalog.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_source_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_catalog_sources.py</code> <pre><code>class CheckSourceColumnsAreAllDocumented(BaseCheck):\n    \"\"\"All columns in a source should be included in the source's properties file, i.e. `.yml` file.\n\n    Receives:\n        catalog_source (CatalogNodes): The CatalogNodes object to check.\n        sources (list[DbtBouncerSourceBase]): List of DbtBouncerSourceBase objects parsed from `catalog.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_source_columns_are_all_documented\n        ```\n\n    \"\"\"\n\n    catalog_source: \"CatalogNodes | None\" = Field(default=None)\n    name: Literal[\"check_source_columns_are_all_documented\"]\n    sources: list[\"DbtBouncerSourceBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If columns are undocumented.\n\n        \"\"\"\n        catalog_source = self._require_catalog_source()\n        source = next(\n            s for s in self.sources if s.unique_id == catalog_source.unique_id\n        )\n        undocumented_columns = [\n            v.name\n            for _, v in catalog_source.columns.items()\n            if v.name not in source.columns\n        ]\n        if undocumented_columns:\n            raise DbtBouncerFailedCheckError(\n                f\"`{catalog_source.unique_id}` has columns that are not included in the sources properties file: {undocumented_columns}\"\n            )\n</code></pre>"},{"location":"checks/catalog/check_columns/","title":"Catalog Checks: Columns","text":"<p>Note</p> <p>The below checks require both <code>catalog.json</code> and <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckColumnDescriptionPopulated</code> <p>Columns must have a populated description.</p> <code>CheckColumnHasSpecifiedTest</code> <p>Columns that match the specified regexp pattern must have a specified test.</p> <code>CheckColumnNameCompliesToColumnType</code> <p>Columns with the specified regexp naming pattern must have data types that comply to the specified regexp pattern or list of data types.</p> <code>CheckColumnNames</code> <p>Columns must have a name that matches the supplied regex.</p> <code>CheckColumnsAreAllDocumented</code> <p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> <code>CheckColumnsAreDocumentedInPublicModels</code> <p>Columns should have a populated description in public models.</p>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnDescriptionPopulated","title":"<code>CheckColumnDescriptionPopulated</code>","text":"<p>Columns must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_column_description_populated\n      include: ^models/marts\n</code></pre> <pre><code>manifest_checks:\n    - name: check_column_description_populated\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnDescriptionPopulated(BaseCheck):\n    \"\"\"Columns must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_column_description_populated\n              include: ^models/marts\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_column_description_populated\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    min_description_length: int | None = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_column_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If description is not populated.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        manifest_obj = self._require_manifest()\n        if self.is_catalog_node_a_model(catalog_node, self.models):\n            model = next(\n                m for m in self.models if m.unique_id == catalog_node.unique_id\n            )\n            non_complying_columns = []\n            for _, v in catalog_node.columns.items():\n                # Snowflake saves column descriptions in the 'comment' field in catalog.json\n                if manifest_obj.manifest.metadata.adapter_type in [\"snowflake\"]:\n                    description = getattr(v, \"comment\", \"\") or \"\"\n                else:\n                    columns = model.columns or {}\n                    column_from_manifest = columns.get(v.name)\n                    description = \"\"\n                    if column_from_manifest:\n                        description = column_from_manifest.description or \"\"\n\n                if not self._is_description_populated(\n                    description, self.min_description_length\n                ):\n                    non_complying_columns.append(v.name)\n\n            if non_complying_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns that do not have a populated description: {non_complying_columns}\"\n                )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnHasSpecifiedTest","title":"<code>CheckColumnHasSpecifiedTest</code>","text":"<p>Columns that match the specified regexp pattern must have a specified test.</p> <p>Parameters:</p> Name Type Description Default <code>column_name_pattern</code> <code>str</code> <p>Regex pattern to match the column name.</p> required <code>test_name</code> <code>str</code> <p>Name of the test to check for.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>tests</code> <code>list[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_column_has_specified_test\n      column_name_pattern: ^is_.*\n      test_name: not_null\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnHasSpecifiedTest(BaseCheck):\n    \"\"\"Columns that match the specified regexp pattern must have a specified test.\n\n    Parameters:\n        column_name_pattern (str): Regex pattern to match the column name.\n        test_name (str): Name of the test to check for.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        tests (list[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_column_has_specified_test\n              column_name_pattern: ^is_.*\n              test_name: not_null\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    column_name_pattern: str\n    name: Literal[\"check_column_has_specified_test\"]\n    test_name: str\n    tests: list[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    _compiled_column_name_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_column_name_pattern = compile_pattern(\n            self.column_name_pattern.strip()\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If column does not have specified test.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        columns_to_check = [\n            v.name\n            for _, v in catalog_node.columns.items()\n            if self._compiled_column_name_pattern.match(str(v.name)) is not None\n        ]\n        tested_columns = set()\n        for t in self.tests:\n            test_metadata = getattr(t, \"test_metadata\", None)\n            attached_node = getattr(t, \"attached_node\", None)\n            if (\n                test_metadata\n                and attached_node\n                and getattr(test_metadata, \"name\", None) == self.test_name\n                and attached_node == catalog_node.unique_id\n            ):\n                tested_columns.add(getattr(t, \"column_name\", \"\"))\n        non_complying_columns = [c for c in columns_to_check if c not in tested_columns]\n\n        if non_complying_columns:\n            raise DbtBouncerFailedCheckError(\n                f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns that should have a `{self.test_name}` test: {non_complying_columns}\"\n            )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnNameCompliesToColumnType","title":"<code>CheckColumnNameCompliesToColumnType</code>","text":"<p>Columns with the specified regexp naming pattern must have data types that comply to the specified regexp pattern or list of data types.</p> <p>Note: One of <code>type_pattern</code> or <code>types</code> must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>column_name_pattern</code> <code>str</code> <p>Regex pattern to match the model name.</p> required <code>type_pattern</code> <code>str | None</code> <p>Regex pattern to match the data types.</p> required <code>types</code> <code>list[str] | None</code> <p>List of data types to check.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    # DATE columns must end with \"_date\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: .*_date$\n      types:\n        - DATE\n</code></pre> <pre><code>catalog_checks:\n    # BOOLEAN columns must start with \"is_\"\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^is_.*\n      types:\n        - BOOLEAN\n</code></pre> <pre><code>catalog_checks:\n    # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^[a-z_]*$\n      types:\n        - BIGINT\n        - BOOLEAN\n        - DATE\n        - DOUBLE\n        - INTEGER\n        - VARCHAR\n</code></pre> <pre><code>catalog_checks:\n    # No STRUCT data types permitted.\n    - name: check_column_name_complies_to_column_type\n      column_name_pattern: ^[a-z_]*$\n      type_pattern: ^(?!STRUCT)\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnNameCompliesToColumnType(BaseCheck):\n    \"\"\"Columns with the specified regexp naming pattern must have data types that comply to the specified regexp pattern or list of data types.\n\n    Note: One of `type_pattern` or `types` must be specified.\n\n    Parameters:\n        column_name_pattern (str): Regex pattern to match the model name.\n        type_pattern (str | None): Regex pattern to match the data types.\n        types (list[str] | None): List of data types to check.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            # DATE columns must end with \"_date\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: .*_date$\n              types:\n                - DATE\n        ```\n        ```yaml\n        catalog_checks:\n            # BOOLEAN columns must start with \"is_\"\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^is_.*\n              types:\n                - BOOLEAN\n        ```\n        ```yaml\n        catalog_checks:\n            # Columns of all types must consist of lowercase letters and underscores. Note that the specified types depend on the underlying database.\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^[a-z_]*$\n              types:\n                - BIGINT\n                - BOOLEAN\n                - DATE\n                - DOUBLE\n                - INTEGER\n                - VARCHAR\n        ```\n        ```yaml\n        catalog_checks:\n            # No STRUCT data types permitted.\n            - name: check_column_name_complies_to_column_type\n              column_name_pattern: ^[a-z_]*$\n              type_pattern: ^(?!STRUCT)\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    column_name_pattern: str\n    name: Literal[\"check_column_name_complies_to_column_type\"]\n    type_pattern: str | None = None\n    types: list[str] | None = None\n\n    _compiled_column_name_pattern: re.Pattern[str] = PrivateAttr()\n    _compiled_type_pattern: re.Pattern[str] | None = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex patterns once at initialisation time.\"\"\"\n        self._compiled_column_name_pattern = compile_pattern(\n            self.column_name_pattern.strip()\n        )\n        if self.type_pattern:\n            self._compiled_type_pattern = compile_pattern(self.type_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If column name does not comply to column type.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        if self.type_pattern:\n            non_complying_columns = [\n                v.name\n                for _, v in catalog_node.columns.items()\n                if self._compiled_type_pattern.match(str(v.type)) is None\n                and self._compiled_column_name_pattern.match(str(v.name)) is not None\n            ]\n\n            if non_complying_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns that don't comply with the specified data type regexp pattern (`{self.column_name_pattern}`): {non_complying_columns}\"\n                )\n\n        elif self.types:\n            non_complying_columns = [\n                v.name\n                for _, v in catalog_node.columns.items()\n                if v.type in self.types\n                and self._compiled_column_name_pattern.match(str(v.name)) is None\n            ]\n\n            if non_complying_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns that don't comply with the specified regexp pattern (`{self.column_name_pattern}`): {non_complying_columns}\"\n                )\n\n    @model_validator(mode=\"after\")\n    def _check_type_pattern_or_types(self) -&gt; \"CheckColumnNameCompliesToColumnType\":\n        if not (self.type_pattern or self.types):\n            raise ValueError(\"Either 'type_pattern' or 'types' must be supplied.\")\n        if self.type_pattern is not None and self.types is not None:\n            raise ValueError(\"Only one of 'type_pattern' or 'types' can be supplied.\")\n        return self\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnNames","title":"<code>CheckColumnNames</code>","text":"<p>Columns must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>columns_name_pattern</code> <code>str</code> <p>Regexp the column name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_column_names\n      column_name_pattern: [a-z_] # Lowercase only, underscores allowed\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnNames(BaseCheck):\n    \"\"\"Columns must have a name that matches the supplied regex.\n\n    Parameters:\n        columns_name_pattern (str): Regexp the column name must match.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_column_names\n              column_name_pattern: [a-z_] # Lowercase only, underscores allowed\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    column_name_pattern: str\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_column_names\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If column name does not match regex.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        if self.is_catalog_node_a_model(catalog_node, self.models):\n            non_complying_columns: list[str] = []\n            non_complying_columns.extend(\n                v.name\n                for _, v in catalog_node.columns.items()\n                if re.fullmatch(self.column_name_pattern.strip(), str(v.name)) is None\n            )\n\n            if non_complying_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns ({non_complying_columns}) that do not match the supplied regex: `{self.column_name_pattern.strip()}`.\"\n                )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnsAreAllDocumented","title":"<code>CheckColumnsAreAllDocumented</code>","text":"<p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> <p>Receives at execution time:</p> Name Type Description <code>case_sensitive</code> <code>bool | None</code> <p>Whether the column names are case sensitive or not. Necessary for adapters like <code>dbt-snowflake</code> where the column in <code>catalog.json</code> is uppercase but the column in <code>manifest.json</code> can be lowercase. Defaults to <code>false</code> for <code>dbt-snowflake</code>, otherwise <code>true</code>.</p> <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_all_documented\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreAllDocumented(BaseCheck):\n    \"\"\"All columns in a model should be included in the model's properties file, i.e. `.yml` file.\n\n    Receives:\n        case_sensitive (bool | None): Whether the column names are case sensitive or not. Necessary for adapters like `dbt-snowflake` where the column in `catalog.json` is uppercase but the column in `manifest.json` can be lowercase. Defaults to `false` for `dbt-snowflake`, otherwise `true`.\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_all_documented\n        ```\n\n    \"\"\"\n\n    case_sensitive: bool | None = Field(default=True)\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_columns_are_all_documented\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If columns are undocumented.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        manifest_obj = self._require_manifest()\n        if self.is_catalog_node_a_model(catalog_node, self.models):\n            model = next(\n                m for m in self.models if m.unique_id == catalog_node.unique_id\n            )\n\n            if manifest_obj.manifest.metadata.adapter_type in [\"snowflake\"]:\n                self.case_sensitive = False\n\n            model_columns = model.columns or {}\n            if self.case_sensitive:\n                undocumented_columns = [\n                    v.name\n                    for _, v in catalog_node.columns.items()\n                    if v.name not in model_columns\n                ]\n            else:\n                model_columns_lower = {c.lower() for c in model_columns}\n                undocumented_columns = [\n                    v.name\n                    for _, v in catalog_node.columns.items()\n                    if v.name.lower() not in model_columns_lower\n                ]\n\n            if undocumented_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` has columns that are not included in the models properties file: {undocumented_columns}\"\n                )\n</code></pre>"},{"location":"checks/catalog/check_columns/#catalog.check_columns.CheckColumnsAreDocumentedInPublicModels","title":"<code>CheckColumnsAreDocumentedInPublicModels</code>","text":"<p>Columns should have a populated description in public models.</p> <p>Receives at execution time:</p> Name Type Description <code>catalog_node</code> <code>Nodes</code> <p>The CatalogNodes object to check.</p> <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>catalog_checks:\n    - name: check_columns_are_documented_in_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreDocumentedInPublicModels(BaseCheck):\n    \"\"\"Columns should have a populated description in public models.\n\n    Receives:\n        catalog_node (CatalogNodes): The CatalogNodes object to check.\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        catalog_checks:\n            - name: check_columns_are_documented_in_public_models\n        ```\n\n    \"\"\"\n\n    catalog_node: \"CatalogNodes | None\" = Field(default=None)\n    min_description_length: int | None = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_columns_are_documented_in_public_models\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If columns are undocumented in public model.\n\n        \"\"\"\n        catalog_node = self._require_catalog_node()\n        if self.is_catalog_node_a_model(catalog_node, self.models):\n            model = next(\n                m for m in self.models if m.unique_id == catalog_node.unique_id\n            )\n            non_complying_columns = []\n            for _, v in catalog_node.columns.items():\n                if model.access and model.access.value == \"public\":\n                    model_columns = model.columns or {}\n                    column_config = model_columns.get(v.name)\n                    if column_config is None or not self._is_description_populated(\n                        column_config.description or \"\", self.min_description_length\n                    ):\n                        non_complying_columns.append(v.name)\n\n            if non_complying_columns:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{str(catalog_node.unique_id).split('.')[-1]}` is a public model but has columns that don't have a populated description: {non_complying_columns}\"\n                )\n</code></pre>"},{"location":"checks/manifest/check_exposures/","title":"Manifest Checks: Exposures","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckExposureOnModel</code> <p>Exposures should depend on a model.</p> <code>CheckExposureOnNonPublicModels</code> <p>Exposures should be based on public models only.</p> <code>CheckExposureOnView</code> <p>Exposures should not be based on views.</p>"},{"location":"checks/manifest/check_exposures/#manifest.check_exposures.CheckExposureOnModel","title":"<code>CheckExposureOnModel</code>","text":"<p>Exposures should depend on a model.</p> <p>Parameters:</p> Name Type Description Default <code>maximum_number_of_models</code> <code>int | None</code> <p>The maximum number of models an exposure can depend on, defaults to 100.</p> required <code>minimum_number_of_models</code> <code>int | None</code> <p>The minimum number of models an exposure can depend on, defaults to 1.</p> required <p>Receives at execution time:</p> Name Type Description <code>exposure</code> <code>DbtBouncerExposureBase</code> <p>The DbtBouncerExposureBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_model\n</code></pre> <pre><code>manifest_checks:\n    - name: check_exposure_based_on_model\n      maximum_number_of_models: 3\n      minimum_number_of_models: 1\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnModel(BaseCheck):\n    \"\"\"Exposures should depend on a model.\n\n    Parameters:\n        maximum_number_of_models (int | None): The maximum number of models an exposure can depend on, defaults to 100.\n        minimum_number_of_models (int | None): The minimum number of models an exposure can depend on, defaults to 1.\n\n    Receives:\n        exposure (DbtBouncerExposureBase): The DbtBouncerExposureBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_model\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_model\n              maximum_number_of_models: 3\n              minimum_number_of_models: 1\n        ```\n\n    \"\"\"\n\n    exposure: \"DbtBouncerExposureBase | None\" = Field(default=None)\n    maximum_number_of_models: int = Field(default=100)\n    minimum_number_of_models: int = Field(default=1)\n    name: Literal[\"check_exposure_based_on_model\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If upstream models number is not within limits.\n\n        \"\"\"\n        exposure = self._require_exposure()\n        depends_on = exposure.depends_on\n        number_of_upstream_models = (\n            len(getattr(depends_on, \"nodes\", []) or []) if depends_on else 0\n        )\n\n        if number_of_upstream_models &lt; self.minimum_number_of_models:\n            raise DbtBouncerFailedCheckError(\n                f\"`{exposure.name}` is based on less models ({number_of_upstream_models}) than the minimum permitted ({self.minimum_number_of_models}).\"\n            )\n        if number_of_upstream_models &gt; self.maximum_number_of_models:\n            raise DbtBouncerFailedCheckError(\n                f\"`{exposure.name}` is based on more models ({number_of_upstream_models}) than the maximum permitted ({self.maximum_number_of_models}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_exposures/#manifest.check_exposures.CheckExposureOnNonPublicModels","title":"<code>CheckExposureOnNonPublicModels</code>","text":"<p>Exposures should be based on public models only.</p> <p>Receives at execution time:</p> Name Type Description <code>exposure</code> <code>DbtBouncerExposureBase</code> <p>The DbtBouncerExposureBase object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_non_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnNonPublicModels(BaseCheck):\n    \"\"\"Exposures should be based on public models only.\n\n    Receives:\n        exposure (DbtBouncerExposureBase): The DbtBouncerExposureBase object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_non_public_models\n        ```\n\n    \"\"\"\n\n    exposure: \"DbtBouncerExposureBase | None\" = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_exposure_based_on_non_public_models\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If exposure is based on non-public models.\n\n        \"\"\"\n        exposure = self._require_exposure()\n        models_by_id = (\n            self.models_by_unique_id\n            if self.models_by_unique_id\n            else {m.unique_id: m for m in self.models}\n        )\n        non_public_upstream_dependencies = []\n        for node_id in getattr(exposure.depends_on, \"nodes\", []) or []:\n            model_obj = models_by_id.get(node_id)\n            if (\n                model_obj\n                and model_obj.resource_type == \"model\"\n                and model_obj.package_name == exposure.package_name\n                and model_obj.access\n                and model_obj.access.value != \"public\"\n            ):\n                non_public_upstream_dependencies.append(model_obj.name)\n\n        if non_public_upstream_dependencies:\n            raise DbtBouncerFailedCheckError(\n                f\"`{exposure.name}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_exposures/#manifest.check_exposures.CheckExposureOnView","title":"<code>CheckExposureOnView</code>","text":"<p>Exposures should not be based on views.</p> <p>Parameters:</p> Name Type Description Default <code>materializations_to_include</code> <code>list[str] | None</code> <p>List of materializations to include in the check.</p> required <p>Receives at execution time:</p> Name Type Description <code>exposure</code> <code>DbtBouncerExposureBase</code> <p>The DbtBouncerExposureBase object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n</code></pre> <pre><code>manifest_checks:\n    - name: check_exposure_based_on_view\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnView(BaseCheck):\n    \"\"\"Exposures should not be based on views.\n\n    Parameters:\n        materializations_to_include (list[str] | None): List of materializations to include in the check.\n\n    Receives:\n        exposure (DbtBouncerExposureBase): The DbtBouncerExposureBase object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Exposure paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the exposure path (i.e the .yml file where the exposure is configured). Only exposure paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_exposure_based_on_view\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n        ```\n\n    \"\"\"\n\n    exposure: \"DbtBouncerExposureBase | None\" = Field(default=None)\n    materializations_to_include: list[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n    )\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_exposure_based_on_view\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If exposure is based on a model that is not a table.\n\n        \"\"\"\n        exposure = self._require_exposure()\n        models_by_id = (\n            self.models_by_unique_id\n            if self.models_by_unique_id\n            else {m.unique_id: m for m in self.models}\n        )\n        non_table_upstream_dependencies = []\n        for node_id in getattr(exposure.depends_on, \"nodes\", []) or []:\n            model_obj = models_by_id.get(node_id)\n            if (\n                model_obj\n                and model_obj.resource_type == \"model\"\n                and model_obj.package_name == exposure.package_name\n                and model_obj.config\n                and model_obj.config.materialized in self.materializations_to_include\n            ):\n                non_table_upstream_dependencies.append(model_obj.name)\n\n        if non_table_upstream_dependencies:\n            raise DbtBouncerFailedCheckError(\n                f\"`{exposure.name}` is based on a model that is not a table: {non_table_upstream_dependencies}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_lineage/","title":"Manifest Checks: Lineage","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckLineagePermittedUpstreamModels</code> <p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> <code>CheckLineageSeedCannotBeUsed</code> <p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <code>CheckLineageSourceCannotBeUsed</code> <p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineagePermittedUpstreamModels","title":"<code>CheckLineagePermittedUpstreamModels</code>","text":"<p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> <p>Parameters:</p> Name Type Description Default <code>upstream_path_pattern</code> <code>str</code> <p>Regexp pattern to match the upstream model(s) path.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The manifest object.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/staging\n      upstream_path_pattern: $^\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/intermediate\n      upstream_path_pattern: ^models/staging|^models/intermediate\n    - name: check_lineage_permitted_upstream_models\n      include: ^models/marts\n      upstream_path_pattern: ^models/staging|^models/intermediate\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineagePermittedUpstreamModels(BaseCheck):\n    \"\"\"Upstream models must have a path that matches the provided `upstream_path_pattern`.\n\n    Parameters:\n        upstream_path_pattern (str): Regexp pattern to match the upstream model(s) path.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The manifest object.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/staging\n              upstream_path_pattern: $^\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/intermediate\n              upstream_path_pattern: ^models/staging|^models/intermediate\n            - name: check_lineage_permitted_upstream_models\n              include: ^models/marts\n              upstream_path_pattern: ^models/staging|^models/intermediate\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_lineage_permitted_upstream_models\"]\n    package_name: str | None = Field(default=None)\n    upstream_path_pattern: str\n\n    _compiled_upstream_path_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_upstream_path_pattern = compile_pattern(\n            self.upstream_path_pattern.strip()\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If upstream models are not permitted.\n\n        \"\"\"\n        self._require_model()\n        self._require_manifest()\n        upstream_models = [\n            x\n            for x in getattr(self.model.depends_on, \"nodes\", []) or []\n            if x.split(\".\")[0] == \"model\"\n            and x.split(\".\")[1]\n            == (self.package_name or self.manifest_obj.manifest.metadata.project_name)\n        ]\n        models_by_id = (\n            self.models_by_unique_id\n            if self.models_by_unique_id\n            else {m.unique_id: m for m in self.models}\n        )\n        not_permitted_upstream_models = [\n            upstream_model\n            for upstream_model in upstream_models\n            if upstream_model in models_by_id\n            and self._compiled_upstream_path_pattern.match(\n                clean_path_str(models_by_id[upstream_model].original_file_path),\n            )\n            is None\n        ]\n        if not_permitted_upstream_models:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` references upstream models that are not permitted: {[m.split('.')[-1] for m in not_permitted_upstream_models]}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineageSeedCannotBeUsed","title":"<code>CheckLineageSeedCannotBeUsed</code>","text":"<p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_seed_cannot_be_used\n      include: ^models/intermediate|^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSeedCannotBeUsed(BaseCheck):\n    \"\"\"Seed cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_seed_cannot_be_used\n              include: ^models/intermediate|^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_lineage_seed_cannot_be_used\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If seed is referenced.\n\n        \"\"\"\n        self._require_model()\n        if [\n            x\n            for x in getattr(self.model.depends_on, \"nodes\", []) or []\n            if x.split(\".\")[0] == \"seed\"\n        ]:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` references a seed even though this is not permitted.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_lineage/#manifest.check_lineage.CheckLineageSourceCannotBeUsed","title":"<code>CheckLineageSourceCannotBeUsed</code>","text":"<p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_lineage_source_cannot_be_used\n      include: ^models/intermediate|^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSourceCannotBeUsed(BaseCheck):\n    \"\"\"Sources cannot be referenced in models with a path that matches the specified `include` config.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_lineage_source_cannot_be_used\n              include: ^models/intermediate|^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_lineage_source_cannot_be_used\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source is referenced.\n\n        \"\"\"\n        self._require_model()\n        if [\n            x\n            for x in getattr(self.model.depends_on, \"nodes\", []) or []\n            if x.split(\".\")[0] == \"source\"\n        ]:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` references a source even though this is not permitted.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_macros/","title":"Manifest Checks: Macros","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckMacroArgumentsDescriptionPopulated</code> <p>Macro arguments must have a populated description.</p> <code>CheckMacroCodeDoesNotContainRegexpPattern</code> <p>The raw code for a macro must not match the specified regexp pattern.</p> <code>CheckMacroDescriptionPopulated</code> <p>Macros must have a populated description.</p> <code>CheckMacroMaxNumberOfLines</code> <p>Macros may not have more than the specified number of lines.</p> <code>CheckMacroNameMatchesFileName</code> <p>Macros names must be the same as the file they are contained in.</p> <code>CheckMacroPropertyFileLocation</code> <p>Macro properties files must follow the guidance provided by dbt here.</p>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroArgumentsDescriptionPopulated","title":"<code>CheckMacroArgumentsDescriptionPopulated</code>","text":"<p>Macro arguments must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_arguments_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have their arguments populated\nmanifest_checks:\n    - name: check_macro_arguments_description_populated\n      include: ^macros/common\n</code></pre> <pre><code>manifest_checks:\n    - name: check_macro_arguments_description_populated\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroArgumentsDescriptionPopulated(BaseCheck):\n    \"\"\"Macro arguments must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have their arguments populated\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n              include: ^macros/common\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_macro_arguments_description_populated\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    min_description_length: int | None = Field(default=None)\n    macro: \"Macros | None\" = Field(default=None)\n    name: Literal[\"check_macro_arguments_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If macro arguments are not populated.\n\n        \"\"\"\n        self._require_macro()\n        environment = Environment(autoescape=True, extensions=[TagExtension])\n        ast = environment.parse(self.macro.macro_sql)\n\n        if hasattr(ast.body[0], \"args\"):\n            # Assume macro is a \"true\" macro\n            macro_arguments = [a.name for a in getattr(ast.body[0], \"args\", [])]\n        else:\n            if \"materialization\" in [\n                x.value.value\n                for x in ast.body[0].nodes[0].kwargs  # type: ignore[attr-defined]\n                if isinstance(x.value, nodes.Const)\n            ]:\n                # Materializations don't have arguments\n                macro_arguments = []\n            else:\n                # Macro is a test\n                test_macro = next(\n                    x\n                    for x in ast.body\n                    if not isinstance(x.nodes[0], nodes.Call)  # type: ignore[attr-defined]\n                )\n                macro_arguments = [\n                    x.name\n                    for x in test_macro.nodes  # type: ignore[attr-defined]\n                    if isinstance(x, nodes.Name)\n                ]\n\n        # macro_arguments: List of args parsed from macro SQL\n        # macro.arguments: List of args manually added to the properties file\n\n        non_complying_args = []\n        if self.macro.arguments:\n            for arg in macro_arguments:\n                macro_doc_raw = [x for x in self.macro.arguments if x.name == arg]\n                if macro_doc_raw == [] or (\n                    arg not in [x.name for x in self.macro.arguments]\n                    or not self._is_description_populated(\n                        str(macro_doc_raw[0].description or \"\"),\n                        self.min_description_length,\n                    )\n                ):\n                    non_complying_args.append(arg)\n\n        if non_complying_args != []:\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` does not have a populated description for the following argument(s): {non_complying_args}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroCodeDoesNotContainRegexpPattern","title":"<code>CheckMacroCodeDoesNotContainRegexpPattern</code>","text":"<p>The raw code for a macro must not match the specified regexp pattern.</p> <p>Parameters:</p> Name Type Description Default <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the macro code.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: [https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02](https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02)\n    - name: check_macro_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroCodeDoesNotContainRegexpPattern(BaseCheck):\n    \"\"\"The raw code for a macro must not match the specified regexp pattern.\n\n    Parameters:\n        regexp_pattern (str): The regexp pattern that should not be matched by the macro code.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: [https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02](https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02)\n            - name: check_macro_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n\n    \"\"\"\n\n    macro: \"Macros | None\" = Field(default=None)\n    name: Literal[\"check_macro_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(\n            self.regexp_pattern.strip(), flags=re.DOTALL\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If macro code contains banned string.\n\n        \"\"\"\n        self._require_macro()\n        if self._compiled_pattern.match(self.macro.macro_sql) is not None:\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` contains a banned string: `{self.regexp_pattern.strip()}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroDescriptionPopulated","title":"<code>CheckMacroDescriptionPopulated</code>","text":"<p>Macros must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_description_populated\n</code></pre> <pre><code># Only \"common\" macros need to have a populated description\nmanifest_checks:\n    - name: check_macro_description_populated\n      include: ^macros/common\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroDescriptionPopulated(BaseCheck):\n    \"\"\"Macros must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_description_populated\n        ```\n        ```yaml\n        # Only \"common\" macros need to have a populated description\n        manifest_checks:\n            - name: check_macro_description_populated\n              include: ^macros/common\n        ```\n\n    \"\"\"\n\n    macro: \"Macros | None\" = Field(default=None)\n    min_description_length: int | None = Field(default=None)\n    name: Literal[\"check_macro_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If macro description is not populated.\n\n        \"\"\"\n        self._require_macro()\n        if not self._is_description_populated(\n            str(self.macro.description or \"\"), self.min_description_length\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` does not have a populated description.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroMaxNumberOfLines","title":"<code>CheckMacroMaxNumberOfLines</code>","text":"<p>Macros may not have more than the specified number of lines.</p> <p>Parameters:</p> Name Type Description Default <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines.</p> required <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_macro_max_number_of_lines\n      max_number_of_lines: 100\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroMaxNumberOfLines(BaseCheck):\n    \"\"\"Macros may not have more than the specified number of lines.\n\n    Parameters:\n        max_number_of_lines (int): The maximum number of permitted lines.\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_macro_max_number_of_lines\n              max_number_of_lines: 100\n        ```\n\n    \"\"\"\n\n    macro: \"Macros | None\" = Field(default=None)\n    name: Literal[\"check_macro_max_number_of_lines\"]\n    max_number_of_lines: int = Field(default=50)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If max lines exceeded.\n\n        \"\"\"\n        self._require_macro()\n        actual_number_of_lines = self.macro.macro_sql.count(\"\\n\") + 1\n\n        if actual_number_of_lines &gt; self.max_number_of_lines:\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({self.max_number_of_lines}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroNameMatchesFileName","title":"<code>CheckMacroNameMatchesFileName</code>","text":"<p>Macros names must be the same as the file they are contained in.</p> <p>Generic tests are also macros, however to document these tests the \"name\" value must be preceded with \"test_\".</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_name_matches_file_name\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroNameMatchesFileName(BaseCheck):\n    \"\"\"Macros names must be the same as the file they are contained in.\n\n    Generic tests are also macros, however to document these tests the \"name\" value must be preceded with \"test_\".\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_name_matches_file_name\n        ```\n\n    \"\"\"\n\n    macro: \"Macros | None\" = Field(default=None)\n    name: Literal[\"check_macro_name_matches_file_name\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If macro name does not match file name.\n\n        \"\"\"\n        self._require_macro()\n        file_path = Path(clean_path_str(self.macro.original_file_path))\n        file_stem = file_path.stem\n\n        if self.macro.name.startswith(\"test_\"):\n            if self.macro.name[5:] != file_stem:\n                raise DbtBouncerFailedCheckError(\n                    f\"Macro `{self.macro.unique_id}` is not in a file named `{self.macro.name[5:]}.sql`.\"\n                )\n        else:\n            if self.macro.name != file_stem:\n                raise DbtBouncerFailedCheckError(\n                    f\"Macro `{self.macro.name}` is not in a file of the same name.\"\n                )\n</code></pre>"},{"location":"checks/manifest/check_macros/#manifest.check_macros.CheckMacroPropertyFileLocation","title":"<code>CheckMacroPropertyFileLocation</code>","text":"<p>Macro properties files must follow the guidance provided by dbt here.</p> <p>Receives at execution time:</p> Name Type Description <code>macro</code> <code>Macros</code> <p>The Macros object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_macro_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroPropertyFileLocation(BaseCheck):\n    \"\"\"Macro properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/5-the-rest-of-the-project#how-we-use-the-other-folders).\n\n    Receives:\n        macro (Macros): The Macros object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the macro path. Macro paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the macro path. Only macro paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_macro_property_file_location\n        ```\n\n    \"\"\"\n\n    macro: \"Macros | None\" = Field(default=None)\n    name: Literal[\"check_macro_property_file_location\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If property file location is incorrect.\n\n        \"\"\"\n        self._require_macro()\n        original_path = Path(clean_path_str(self.macro.original_file_path))\n\n        # Logic matches previous manual splitting:\n        # If path is `macros/utils/file.sql`, we want `_utils`.\n        # We assume the first part of the path is the root (e.g. 'macros' or 'tests').\n        subdir_parts = original_path.parent.parts[1:]\n        expected_substr = \"_\" + \"_\".join(subdir_parts) if subdir_parts else \"\"\n\n        if self.macro.patch_path is None:\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` is not defined in a `.yml` properties file.\"\n            )\n        clean_patch_path = clean_path_str(self.macro.patch_path)\n        if clean_patch_path is None:\n            raise DbtBouncerFailedCheckError(\n                f\"Macro `{self.macro.name}` has an invalid patch path.\"\n            )\n\n        patch_path = Path(clean_patch_path)\n        properties_yml_name = patch_path.name\n\n        if original_path.parts[0] == \"tests\":\n            # Do not check generic tests (which are also macros)\n            pass\n        elif expected_substr == \"\":  # i.e. macro in ./macros\n            if properties_yml_name != \"_macros.yml\":\n                raise DbtBouncerFailedCheckError(\n                    f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) should be `_macros.yml`.\"\n                )\n        else:\n            if not properties_yml_name.startswith(\"_\"):\n                raise DbtBouncerFailedCheckError(\n                    f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n                )\n            if expected_substr not in properties_yml_name:\n                raise DbtBouncerFailedCheckError(\n                    f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n                )\n            if not properties_yml_name.endswith(\"__macros.yml\"):\n                raise DbtBouncerFailedCheckError(\n                    f\"The properties file for `{self.macro.name}` (`{properties_yml_name}`) does not end with `__macros.yml`.\"\n                )\n</code></pre>"},{"location":"checks/manifest/check_metadata/","title":"Manifest Checks: Metadata","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckProjectName</code> <p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p>"},{"location":"checks/manifest/check_metadata/#manifest.check_metadata.CheckProjectName","title":"<code>CheckProjectName</code>","text":"<p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>project_name_pattern</code> <code>str</code> <p>Regex pattern to match the project name.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The manifest object.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_project_name\n      project_name_pattern: ^awesome_company_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_metadata.py</code> <pre><code>class CheckProjectName(BaseCheck):\n    \"\"\"Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  `company_&lt;DOMAIN&gt;`.\n\n    Parameters:\n        project_name_pattern (str): Regex pattern to match the project name.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The manifest object.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_project_name\n              project_name_pattern: ^awesome_company_\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    description: str | None = Field(\n        default=None,\n        description=\"Description of what the check does and why it is implemented.\",\n    )\n    index: int | None = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    name: Literal[\"check_project_name\"]\n    package_name: str | None = Field(default=None)\n    project_name_pattern: str\n    severity: Literal[\"error\", \"warn\"] | None = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n\n    _compiled_project_name_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_project_name_pattern = compile_pattern(\n            self.project_name_pattern.strip()\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If project name does not match regex.\n\n        \"\"\"\n        self._require_manifest()\n\n        package_name = (\n            self.package_name or self.manifest_obj.manifest.metadata.project_name\n        )\n        if (\n            self._compiled_project_name_pattern.match(\n                str(package_name),\n            )\n            is None\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"Project name (`{package_name}`) does not conform to the supplied regex `({self.project_name_pattern.strip()})`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/","title":"Manifest Checks: Models","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckModelAccess</code> <p>Models must have the specified access attribute. Requires dbt 1.7+.</p> <code>CheckModelCodeDoesNotContainRegexpPattern</code> <p>The raw code for a model must not match the specified regexp pattern.</p> <code>CheckModelColumnsHaveMetaKeys</code> <p>Columns defined for models must have the specified keys in the <code>meta</code> config.</p> <code>CheckModelColumnsHaveTypes</code> <p>Columns defined for models must have a <code>data_type</code> declared.</p> <code>CheckModelContractsEnforcedForPublicModel</code> <p>Public models must have contracts enforced.</p> <code>CheckModelDependsOnMacros</code> <p>Models must depend on the specified macros.</p> <code>CheckModelDependsOnMultipleSources</code> <p>Models cannot reference more than one source.</p> <code>CheckModelDescriptionContainsRegexPattern</code> <p>Models must have a description that matches the provided pattern.</p> <code>CheckModelDescriptionPopulated</code> <p>Models must have a populated description.</p> <code>CheckModelDirectories</code> <p>Only specified sub-directories are permitted.</p> <code>CheckModelDocumentedInSameDirectory</code> <p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> <code>CheckModelFileName</code> <p>Models must have a file name that matches the supplied regex.</p> <code>CheckModelGrantPrivilege</code> <p>Model can have grant privileges that match the specified pattern.</p> <code>CheckModelGrantPrivilegeRequired</code> <p>Model must have the specified grant privilege.</p> <code>CheckModelHasConstraints</code> <p>Table and incremental models must have the specified constraint types defined.</p> <code>CheckModelHasContractsEnforced</code> <p>Model must have contracts enforced.</p> <code>CheckModelHasExposure</code> <p>Models must have an exposure.</p> <code>CheckModelHasMetaKeys</code> <p>The <code>meta</code> config for models must have the specified keys.</p> <code>CheckModelHasNoUpstreamDependencies</code> <p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> <code>CheckModelHasSemiColon</code> <p>Model may not end with a semi-colon (<code>;</code>).</p> <code>CheckModelHasTags</code> <p>Models must have the specified tags.</p> <code>CheckModelHasUniqueTest</code> <p>Models must have a test for uniqueness of a column.</p> <code>CheckModelHasUnitTests</code> <p>Models must have more than the specified number of unit tests.</p> <code>CheckModelLatestVersionSpecified</code> <p>Check that the <code>latest_version</code> attribute of the model is set.</p> <code>CheckModelMaxChainedViews</code> <p>Models cannot have more than the specified number of upstream dependents that are not tables.</p> <code>CheckModelMaxFanout</code> <p>Models cannot have more than the specified number of downstream models.</p> <code>CheckModelMaxNumberOfLines</code> <p>Models may not have more than the specified number of lines.</p> <code>CheckModelMaxUpstreamDependencies</code> <p>Limit the number of upstream dependencies a model has.</p> <code>CheckModelNames</code> <p>Models must have a name that matches the supplied regex.</p> <code>CheckModelNumberOfGrants</code> <p>Model can have the specified number of privileges.</p> <code>CheckModelPropertyFileLocation</code> <p>Model properties files must follow the guidance provided by dbt here.</p> <code>CheckModelSchemaName</code> <p>Models must have a schema name that matches the supplied regex.</p> <code>CheckModelVersionAllowed</code> <p>Check that the version of the model matches the supplied regex pattern.</p> <code>CheckModelVersionPinnedInRef</code> <p>Check that the version of the model is always specified in downstream nodes.</p> <code>CheckModelsDocumentationCoverage</code> <p>Set the minimum percentage of models that have a populated description.</p> <code>CheckModelsTestCoverage</code> <p>Set the minimum percentage of models that have at least one test.</p>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelAccess","title":"<code>CheckModelAccess</code>","text":"<p>Models must have the specified access attribute. Requires dbt 1.7+.</p> <p>Parameters:</p> Name Type Description Default <code>access</code> <code>Literal['private', 'protected', 'public']</code> <p>The access level to check for.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n    - name: check_model_access\n      access: protected\n      include: ^models/intermediate\n    - name: check_model_access\n      access: public\n      include: ^models/marts\n    - name: check_model_access\n      access: protected\n      include: ^models/staging\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelAccess(BaseCheck):\n    \"\"\"Models must have the specified access attribute. Requires dbt 1.7+.\n\n    Parameters:\n        access (Literal[\"private\", \"protected\", \"public\"]): The access level to check for.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Align with dbt best practices that marts should be `public`, everything else should be `protected`\n            - name: check_model_access\n              access: protected\n              include: ^models/intermediate\n            - name: check_model_access\n              access: public\n              include: ^models/marts\n            - name: check_model_access\n              access: protected\n              include: ^models/staging\n        ```\n\n    \"\"\"\n\n    access: Literal[\"private\", \"protected\", \"public\"]\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_access\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If access is incorrect.\n\n        \"\"\"\n        self._require_model()\n        if self.model.access and self.model.access.value != self.access:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has `{self.model.access.value}` access, it should have access `{self.access}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelCodeDoesNotContainRegexpPattern","title":"<code>CheckModelCodeDoesNotContainRegexpPattern</code>","text":"<p>The raw code for a model must not match the specified regexp pattern.</p> <p>Parameters:</p> Name Type Description Default <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should not be matched by the model code.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n    - name: check_model_code_does_not_contain_regexp_pattern\n      regexp_pattern: .*[i][f][n][u][l][l].*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelCodeDoesNotContainRegexpPattern(BaseCheck):\n    \"\"\"The raw code for a model must not match the specified regexp pattern.\n\n    Parameters:\n        regexp_pattern (str): The regexp pattern that should not be matched by the model code.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            # Prefer `coalesce` over `ifnull`: https://docs.sqlfluff.com/en/stable/rules.html#sqlfluff.rules.sphinx.Rule_CV02\n            - name: check_model_code_does_not_contain_regexp_pattern\n              regexp_pattern: .*[i][f][n][u][l][l].*\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(\n            self.regexp_pattern.strip(), flags=re.DOTALL\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If code contains banned string.\n\n        \"\"\"\n        self._require_model()\n        if self._compiled_pattern.match(str(self.model.raw_code)) is not None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` contains a banned string: `{self.regexp_pattern}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelColumnsHaveMetaKeys","title":"<code>CheckModelColumnsHaveMetaKeys</code>","text":"<p>Columns defined for models must have the specified keys in the <code>meta</code> config.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_columns_have_meta_keys\n      keys:\n        - owner\n        - pii\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelColumnsHaveMetaKeys(BaseCheck):\n    \"\"\"Columns defined for models must have the specified keys in the `meta` config.\n\n    Parameters:\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_columns_have_meta_keys\n              keys:\n                - owner\n                - pii\n        ```\n\n    \"\"\"\n\n    keys: NestedDict\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_columns_have_meta_keys\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If any model column is missing required meta keys.\n\n        \"\"\"\n        self._require_model()\n        columns = self.model.columns or {}\n        failing_columns: dict[str, list[str]] = {}\n        for col_name, col in columns.items():\n            missing_keys = find_missing_meta_keys(\n                meta_config=col.meta or {},\n                required_keys=self.keys.model_dump(),\n            )\n            if missing_keys:\n                failing_columns[col_name] = [k.replace(\"&gt;&gt;\", \"\") for k in missing_keys]\n        if failing_columns:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has columns missing required `meta` keys: {failing_columns}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelColumnsHaveTypes","title":"<code>CheckModelColumnsHaveTypes</code>","text":"<p>Columns defined for models must have a <code>data_type</code> declared.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_columns_have_types\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelColumnsHaveTypes(BaseCheck):\n    \"\"\"Columns defined for models must have a `data_type` declared.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_columns_have_types\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_columns_have_types\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If any column lacks a declared `data_type`.\n\n        \"\"\"\n        self._require_model()\n        columns = self.model.columns or {}\n        untyped_columns = [\n            col_name for col_name, col in columns.items() if not col.data_type\n        ]\n        if untyped_columns:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has columns without a declared `data_type`: {untyped_columns}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelContractsEnforcedForPublicModel","title":"<code>CheckModelContractsEnforcedForPublicModel</code>","text":"<p>Public models must have contracts enforced.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_contract_enforced_for_public_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelContractsEnforcedForPublicModel(BaseCheck):\n    \"\"\"Public models must have contracts enforced.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_contract_enforced_for_public_model\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_contract_enforced_for_public_model\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If contracts are not enforced for public model.\n\n        \"\"\"\n        self._require_model()\n        if (\n            self.model.access\n            and self.model.access.value == \"public\"\n            and (not self.model.contract or self.model.contract.enforced is not True)\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is a public model but does not have contracts enforced.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDependsOnMacros","title":"<code>CheckModelDependsOnMacros</code>","text":"<p>Models must depend on the specified macros.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <p>(Literal[\"any\", \"all\", \"one\"] | None): Whether the model must depend on any, all, or exactly one of the specified macros. Default: <code>any</code>.</p> required <code>required_macros</code> <p>(list[str]): List of macros the model must depend on. All macros must specify a namespace, e.g. <code>dbt.is_incremental</code>.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_depends_on_macros\n      required_macros:\n        - dbt.is_incremental\n    - name: check_model_depends_on_macros\n      criteria: one\n      required_macros:\n        - my_package.sampler\n        - my_package.sampling\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDependsOnMacros(BaseCheck):\n    \"\"\"Models must depend on the specified macros.\n\n    Parameters:\n        criteria: (Literal[\"any\", \"all\", \"one\"] | None): Whether the model must depend on any, all, or exactly one of the specified macros. Default: `any`.\n        required_macros: (list[str]): List of macros the model must depend on. All macros must specify a namespace, e.g. `dbt.is_incremental`.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_depends_on_macros\n              required_macros:\n                - dbt.is_incremental\n            - name: check_model_depends_on_macros\n              criteria: one\n              required_macros:\n                - my_package.sampler\n                - my_package.sampling\n        ```\n\n    \"\"\"\n\n    criteria: Literal[\"any\", \"all\", \"one\"] = Field(default=\"all\")\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_depends_on_macros\"]\n    required_macros: list[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model does not depend on required macros.\n\n        \"\"\"\n        self._require_model()\n        upstream_macros = [\n            (\".\").join(m.split(\".\")[1:])\n            for m in getattr(self.model.depends_on, \"macros\", []) or []\n        ]\n        if self.criteria == \"any\":\n            if not any(macro in upstream_macros for macro in self.required_macros):\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` does not depend on any of the required macros: {self.required_macros}.\"\n                )\n        elif self.criteria == \"all\":\n            missing_macros = [\n                macro for macro in self.required_macros if macro not in upstream_macros\n            ]\n            if missing_macros:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` is missing required macros: {missing_macros}.\"\n                )\n        elif (\n            self.criteria == \"one\"\n            and sum(macro in upstream_macros for macro in self.required_macros) != 1\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` must depend on exactly one of the required macros: {self.required_macros}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDependsOnMultipleSources","title":"<code>CheckModelDependsOnMultipleSources</code>","text":"<p>Models cannot reference more than one source.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_depends_on_multiple_sources\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDependsOnMultipleSources(BaseCheck):\n    \"\"\"Models cannot reference more than one source.\n\n    Parameters:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_depends_on_multiple_sources\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_depends_on_multiple_sources\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model references more than one source.\n\n        \"\"\"\n        self._require_model()\n        num_reffed_sources = sum(\n            x.split(\".\")[0] == \"source\"\n            for x in getattr(self.model.depends_on, \"nodes\", []) or []\n        )\n        if num_reffed_sources &gt; 1:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` references more than one source.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDescriptionContainsRegexPattern","title":"<code>CheckModelDescriptionContainsRegexPattern</code>","text":"<p>Models must have a description that matches the provided pattern.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>regexp_pattern</code> <code>str</code> <p>The regexp pattern that should match the model description.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_description_contains_regex_pattern\n    - regex_pattern: .*pattern_to_match.*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDescriptionContainsRegexPattern(BaseCheck):\n    \"\"\"Models must have a description that matches the provided pattern.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        regexp_pattern (str): The regexp pattern that should match the model description.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_contains_regex_pattern\n            - regex_pattern: .*pattern_to_match.*\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_description_contains_regex_pattern\"]\n    regexp_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(\n            self.regexp_pattern.strip(), flags=re.DOTALL\n        )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If description does not match regex.\n\n        \"\"\"\n        self._require_model()\n        if not self._compiled_pattern.match(str(self.model.description)):\n            raise DbtBouncerFailedCheckError(\n                f\"\"\"`{get_clean_model_name(self.model.unique_id)}`'s description \"{self.model.description}\" doesn't match the supplied regex: {self.regexp_pattern}.\"\"\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDescriptionPopulated","title":"<code>CheckModelDescriptionPopulated</code>","text":"<p>Models must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_description_populated\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_description_populated\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDescriptionPopulated(BaseCheck):\n    \"\"\"Models must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_populated\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_description_populated\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    min_description_length: int | None = Field(default=None)\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_description_populated\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If description is not populated.\n\n        \"\"\"\n        self._require_model()\n        if not self._is_description_populated(\n            self.model.description or \"\", self.min_description_length\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not have a populated description.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDirectories","title":"<code>CheckModelDirectories</code>","text":"<p>Only specified sub-directories are permitted.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>str</code> <p>Regex pattern to the directory to check.</p> required <code>permitted_sub_directories</code> <code>list[str]</code> <p>List of permitted sub-directories.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n- name: check_model_directories\n  include: models\n  permitted_sub_directories:\n    - intermediate\n    - marts\n    - staging\n</code></pre> <pre><code># Restrict sub-directories within `./models/staging`\n- name: check_model_directories\n  include: ^models/staging\n  permitted_sub_directories:\n    - crm\n    - payments\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDirectories(BaseCheck):\n    \"\"\"Only specified sub-directories are permitted.\n\n    Parameters:\n        include (str): Regex pattern to the directory to check.\n        permitted_sub_directories (list[str]): List of permitted sub-directories.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n        - name: check_model_directories\n          include: models\n          permitted_sub_directories:\n            - intermediate\n            - marts\n            - staging\n        ```\n        ```yaml\n        # Restrict sub-directories within `./models/staging`\n        - name: check_model_directories\n          include: ^models/staging\n          permitted_sub_directories:\n            - crm\n            - payments\n        ```\n\n    \"\"\"\n\n    include: str\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_directories\"]\n    permitted_sub_directories: list[str]\n\n    _compiled_include: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_include = compile_pattern(self.include.strip().rstrip(\"/\"))\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model located in `./models` or invalid subdirectory.\n\n        \"\"\"\n        self._require_model()\n        clean_path = clean_path_str(self.model.original_file_path)\n        matched_path = self._compiled_include.match(clean_path)\n        if matched_path is None:\n            raise DbtBouncerFailedCheckError(\"matched_path is None\")\n        path_after_match = clean_path[matched_path.end() + 1 :]\n        directory_to_check = Path(path_after_match).parts[0]\n\n        if directory_to_check.replace(\".sql\", \"\") == self.model.name:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is not located in a valid sub-directory ({self.permitted_sub_directories}).\"\n            )\n        else:\n            if directory_to_check not in self.permitted_sub_directories:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` is located in the `{directory_to_check}` sub-directory, this is not a valid sub-directory ({self.permitted_sub_directories}).\"\n                )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelDocumentedInSameDirectory","title":"<code>CheckModelDocumentedInSameDirectory</code>","text":"<p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_documented_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDocumentedInSameDirectory(BaseCheck):\n    \"\"\"Models must be documented in the same directory where they are defined (i.e. `.yml` and `.sql` files are in the same directory).\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_documented_in_same_directory\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_documented_in_same_directory\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model is not documented in same directory.\n\n        \"\"\"\n        self._require_model()\n        model = cast(\"Nodes4\", self.model)\n        model_sql_path = Path(clean_path_str(model.original_file_path))\n        model_sql_dir = model_sql_path.parent.parts\n\n        if not (\n            hasattr(model, \"patch_path\")\n            and clean_path_str(model.patch_path or \"\") is not None\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(model.unique_id)}` is not documented.\"\n            )\n\n        patch_path_str = clean_path_str(model.patch_path or \"\")\n        start_idx = patch_path_str.find(\"models\")\n        if start_idx != -1:\n            patch_path_str = patch_path_str[start_idx:]\n\n        model_doc_path = Path(patch_path_str)\n        model_doc_dir = model_doc_path.parent.parts\n\n        if model_doc_dir != model_sql_dir:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is documented in a different directory to the `.sql` file: `{'/'.join(model_doc_dir)}` vs `{'/'.join(model_sql_dir)}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelFileName","title":"<code>CheckModelFileName</code>","text":"<p>Models must have a file name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>file_name_pattern</code> <code>str</code> <p>Regexp the file name must match. Please account for the <code>.sql</code> extension.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_file_name\n      description: Marts must include the model version in their file name.\n      include: ^models/marts\n      file_name_pattern: .*(v[0-9])\\.sql$\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelFileName(BaseCheck):\n    r\"\"\"Models must have a file name that matches the supplied regex.\n\n    Parameters:\n        file_name_pattern (str): Regexp the file name must match. Please account for the `.sql` extension.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_file_name\n              description: Marts must include the model version in their file name.\n              include: ^models/marts\n              file_name_pattern: .*(v[0-9])\\.sql$\n        ```\n\n    \"\"\"\n\n    file_name_pattern: str\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_file_name\"]\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.file_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If file name does not match regex.\n\n        \"\"\"\n        self._require_model()\n        file_name = Path(clean_path_str(self.model.original_file_path)).name\n        if self._compiled_pattern.match(file_name) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is in a file that does not match the supplied regex `{self.file_name_pattern.strip()}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelGrantPrivilege","title":"<code>CheckModelGrantPrivilege</code>","text":"<p>Model can have grant privileges that match the specified pattern.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>privilege_pattern</code> <code>str</code> <p>Regex pattern to match the privilege.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_grant_privilege\n      include: ^models/marts\n      privilege_pattern: ^select\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelGrantPrivilege(BaseCheck):\n    \"\"\"Model can have grant privileges that match the specified pattern.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        privilege_pattern (str): Regex pattern to match the privilege.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_grant_privilege\n              include: ^models/marts\n              privilege_pattern: ^select\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_grant_privilege\"]\n    privilege_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.privilege_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If grant privileges do not match regex.\n\n        \"\"\"\n        self._require_model()\n        config = self.model.config\n        grants = config.grants if config else {}\n        non_complying_grants = [\n            i for i in (grants or {}) if self._compiled_pattern.match(str(i)) is None\n        ]\n\n        if non_complying_grants:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has grants (`{self.privilege_pattern}`) that don't comply with the specified regexp pattern ({non_complying_grants}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelGrantPrivilegeRequired","title":"<code>CheckModelGrantPrivilegeRequired</code>","text":"<p>Model must have the specified grant privilege.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>privilege</code> <code>str</code> <p>The privilege that is required.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_grant_privilege_required\n      include: ^models/marts\n      privilege: select\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelGrantPrivilegeRequired(BaseCheck):\n    \"\"\"Model must have the specified grant privilege.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        privilege (str): The privilege that is required.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_grant_privilege_required\n              include: ^models/marts\n              privilege: select\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_grant_privilege_required\"]\n    privilege: str\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If required grant privilege is missing.\n\n        \"\"\"\n        self._require_model()\n        config = self.model.config\n        grants = config.grants if config else {}\n        if self.privilege not in (grants or {}):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not have the required grant privilege (`{self.privilege}`).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasConstraints","title":"<code>CheckModelHasConstraints</code>","text":"<p>Table and incremental models must have the specified constraint types defined.</p> <p>Parameters:</p> Name Type Description Default <code>required_constraint_types</code> <code>list[Literal['check', 'custom', 'foreign_key', 'not_null', 'primary_key', 'unique']]</code> <p>List of constraint types that must be present on the model.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_constraints\n      required_constraint_types:\n        - primary_key\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasConstraints(BaseCheck):\n    \"\"\"Table and incremental models must have the specified constraint types defined.\n\n    Parameters:\n        required_constraint_types (list[Literal[\"check\", \"custom\", \"foreign_key\", \"not_null\", \"primary_key\", \"unique\"]]): List of constraint types that must be present on the model.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_constraints\n              required_constraint_types:\n                - primary_key\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_constraints\"]\n    required_constraint_types: list[\n        Literal[\"check\", \"custom\", \"foreign_key\", \"not_null\", \"primary_key\", \"unique\"]\n    ]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If required constraint types are missing.\n\n        \"\"\"\n        self._require_model()\n        materialization = (\n            self.model.config.materialized\n            if self.model.config and hasattr(self.model.config, \"materialized\")\n            else None\n        )\n        if materialization not in (\"table\", \"incremental\"):\n            return\n        constraints = self.model.constraints or []\n        actual_types = {\n            (c.type.value if hasattr(c.type, \"value\") else str(c.type))\n            for c in constraints\n        }\n        missing_types = sorted(set(self.required_constraint_types) - actual_types)\n        if missing_types:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is missing required constraint types: {missing_types}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasContractsEnforced","title":"<code>CheckModelHasContractsEnforced</code>","text":"<p>Model must have contracts enforced.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_contracts_enforced\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasContractsEnforced(BaseCheck):\n    \"\"\"Model must have contracts enforced.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_contracts_enforced\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_contracts_enforced\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If contracts are not enforced.\n\n        \"\"\"\n        self._require_model()\n        if not self.model.contract or self.model.contract.enforced is not True:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not have contracts enforced.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasExposure","title":"<code>CheckModelHasExposure</code>","text":"<p>Models must have an exposure.</p> <p>Receives at execution time:</p> Name Type Description <code>exposures</code> <code>list[DbtBouncerExposureBase]</code> <p>List of DbtBouncerExposureBase objects parsed from <code>manifest.json</code>.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_exposure\n      description: Ensure all marts are part of an exposure.\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasExposure(BaseCheck):\n    \"\"\"Models must have an exposure.\n\n    Receives:\n        exposures (list[DbtBouncerExposureBase]):  List of DbtBouncerExposureBase objects parsed from `manifest.json`.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_exposure\n              description: Ensure all marts are part of an exposure.\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    exposures: list[\"DbtBouncerExposureBase\"] = Field(default=[])\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_exposure\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model does not have an exposure.\n\n        \"\"\"\n        self._require_model()\n        models_in_exposures = {\n            node\n            for e in self.exposures\n            for node in (getattr(e.depends_on, \"nodes\", []) or [])\n        }\n\n        if self.model.unique_id not in models_in_exposures:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not have an associated exposure.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasMetaKeys","title":"<code>CheckModelHasMetaKeys</code>","text":"<p>The <code>meta</code> config for models must have the specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_meta_keys\n      keys:\n        - maturity\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasMetaKeys(BaseCheck):\n    \"\"\"The `meta` config for models must have the specified keys.\n\n    Parameters:\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_meta_keys\n              keys:\n                - maturity\n                - owner\n        ```\n\n    \"\"\"\n\n    keys: NestedDict\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_meta_keys\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If required meta keys are missing.\n\n        \"\"\"\n        self._require_model()\n        missing_keys = find_missing_meta_keys(\n            meta_config=self.model.meta,\n            required_keys=self.keys.model_dump(),\n        )\n        if missing_keys != []:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasNoUpstreamDependencies","title":"<code>CheckModelHasNoUpstreamDependencies</code>","text":"<p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_no_upstream_dependencies\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasNoUpstreamDependencies(BaseCheck):\n    \"\"\"Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_no_upstream_dependencies\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_no_upstream_dependencies\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model has no upstream dependencies.\n\n        \"\"\"\n        self._require_model()\n        if (\n            not self.model.depends_on\n            or not self.model.depends_on.nodes\n            or len(self.model.depends_on.nodes) &lt;= 0\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has no upstream dependencies, this likely indicates hard-coded tables references.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasSemiColon","title":"<code>CheckModelHasSemiColon</code>","text":"<p>Model may not end with a semi-colon (<code>;</code>).</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_semi_colon\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasSemiColon(BaseCheck):\n    \"\"\"Model may not end with a semi-colon (`;`).\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_semi_colon\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_semi_colon\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model ends with a semi-colon.\n\n        \"\"\"\n        self._require_model()\n        raw_code = (self.model.raw_code or \"\").strip()\n        if raw_code and raw_code[-1] == \";\":\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` ends with a semi-colon, this is not permitted.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasTags","title":"<code>CheckModelHasTags</code>","text":"<p>Models must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <p>(Literal[\"any\", \"all\", \"one\"] | None): Whether the model must have any, all, or exactly one of the specified tags. Default: <code>any</code>.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <code>tags</code> <code>list[str]</code> <p>List of tags to check for.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasTags(BaseCheck):\n    \"\"\"Models must have the specified tags.\n\n    Parameters:\n        criteria: (Literal[\"any\", \"all\", \"one\"] | None): Whether the model must have any, all, or exactly one of the specified tags. Default: `any`.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        tags (list[str]): List of tags to check for.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n\n    \"\"\"\n\n    criteria: Literal[\"any\", \"all\", \"one\"] = Field(default=\"all\")\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_tags\"]\n    tags: list[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model does not have required tags.\n\n        \"\"\"\n        self._require_model()\n        model_tags = self.model.tags or []\n        if self.criteria == \"any\":\n            if not any(tag in model_tags for tag in self.tags):\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` does not have any of the required tags: {self.tags}.\"\n                )\n        elif self.criteria == \"all\":\n            missing_tags = [tag for tag in self.tags if tag not in model_tags]\n            if missing_tags:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` is missing required tags: {missing_tags}.\"\n                )\n        elif (\n            self.criteria == \"one\" and sum(tag in model_tags for tag in self.tags) != 1\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` must have exactly one of the required tags: {self.tags}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasUniqueTest","title":"<code>CheckModelHasUniqueTest</code>","text":"<p>Models must have a test for uniqueness of a column.</p> <p>Parameters:</p> Name Type Description Default <code>accepted_uniqueness_tests</code> <code>list[str] | None</code> <p>List of tests that are accepted as uniqueness tests.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <code>tests</code> <code>list[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_unique_test\n      include: ^models/marts\n</code></pre> <pre><code>manifest_checks:\n# Example of allowing a custom uniqueness test\n    - name: check_model_has_unique_test\n      accepted_uniqueness_tests:\n        - dbt_expectations.expect_compound_columns_to_be_unique # i.e. tests from packages must include package name\n        - my_custom_uniqueness_test\n        - unique\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasUniqueTest(BaseCheck):\n    \"\"\"Models must have a test for uniqueness of a column.\n\n    Parameters:\n        accepted_uniqueness_tests (list[str] | None): List of tests that are accepted as uniqueness tests.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        tests (list[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unique_test\n              include: ^models/marts\n        ```\n        ```yaml\n        manifest_checks:\n        # Example of allowing a custom uniqueness test\n            - name: check_model_has_unique_test\n              accepted_uniqueness_tests:\n                - dbt_expectations.expect_compound_columns_to_be_unique # i.e. tests from packages must include package name\n                - my_custom_uniqueness_test\n                - unique\n        ```\n\n    \"\"\"\n\n    accepted_uniqueness_tests: list[str] | None = Field(\n        default=[\n            \"dbt_expectations.expect_compound_columns_to_be_unique\",\n            \"dbt_utils.unique_combination_of_columns\",\n            \"unique\",\n        ],\n    )\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_unique_test\"]\n    tests: list[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model does not have a unique test.\n\n        \"\"\"\n        self._require_model()\n        num_unique_tests = 0\n        for test in self.tests:\n            test_metadata = getattr(test, \"test_metadata\", None)\n            attached_node = getattr(test, \"attached_node\", None)\n            if (\n                test_metadata\n                and attached_node == self.model.unique_id\n                and (\n                    (\n                        f\"{getattr(test_metadata, 'namespace', '')}.{getattr(test_metadata, 'name', '')}\"\n                        in (self.accepted_uniqueness_tests or [])\n                    )\n                    or (\n                        getattr(test_metadata, \"namespace\", None) is None\n                        and getattr(test_metadata, \"name\", \"\")\n                        in (self.accepted_uniqueness_tests or [])\n                    )\n                )\n            ):\n                num_unique_tests += 1\n        if num_unique_tests &lt; 1:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not have a test for uniqueness of a column.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelHasUnitTests","title":"<code>CheckModelHasUnitTests</code>","text":"<p>Models must have more than the specified number of unit tests.</p> <p>Parameters:</p> Name Type Description Default <code>min_number_of_unit_tests</code> <code>int | None</code> <p>The minimum number of unit tests that a model must have.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>unit_tests</code> <code>list[UnitTests]</code> <p>List of UnitTests objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      include: ^models/marts\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_has_unit_tests\n      min_number_of_unit_tests: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasUnitTests(BaseCheck):\n    \"\"\"Models must have more than the specified number of unit tests.\n\n    Parameters:\n        min_number_of_unit_tests (int | None): The minimum number of unit tests that a model must have.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        unit_tests (list[UnitTests]): List of UnitTests objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              include: ^models/marts\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_has_unit_tests\n              min_number_of_unit_tests: 2\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    min_number_of_unit_tests: int = Field(default=1)\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_has_unit_tests\"]\n    unit_tests: list[\"UnitTests\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model does not have enough unit tests.\n\n        \"\"\"\n        self._require_manifest()\n        self._require_model()\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version or \"0.0.0\"\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            num_unit_tests = len(\n                [\n                    t.unique_id\n                    for t in self.unit_tests\n                    if t.depends_on\n                    and t.depends_on.nodes\n                    and t.depends_on.nodes[0] == self.model.unique_id\n                ],\n            )\n            if num_unit_tests &lt; self.min_number_of_unit_tests:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{get_clean_model_name(self.model.unique_id)}` has {num_unit_tests} unit tests, this is less than the minimum of {self.min_number_of_unit_tests}.\"\n                )\n        else:\n            logging.warning(\n                \"The `check_model_has_unit_tests` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelLatestVersionSpecified","title":"<code>CheckModelLatestVersionSpecified</code>","text":"<p>Check that the <code>latest_version</code> attribute of the model is set.</p> <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_latest_version_specified\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelLatestVersionSpecified(BaseCheck):\n    r\"\"\"Check that the `latest_version` attribute of the model is set.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_latest_version_specified\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_latest_version_specified\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If latest version is not specified.\n\n        \"\"\"\n        self._require_model()\n        if self.model.latest_version is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.model.name}` does not have a specified `latest_version`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxChainedViews","title":"<code>CheckModelMaxChainedViews</code>","text":"<p>Models cannot have more than the specified number of upstream dependents that are not tables.</p> <p>Parameters:</p> Name Type Description Default <code>materializations_to_include</code> <code>list[str] | None</code> <p>List of materializations to include in the check.</p> required <code>max_chained_views</code> <code>int | None</code> <p>The maximum number of upstream dependents that are not tables.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_chained_views\n      materializations_to_include:\n        - ephemeral\n        - my_custom_materialization\n        - view\n      max_chained_views: 5\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxChainedViews(BaseCheck):\n    \"\"\"Models cannot have more than the specified number of upstream dependents that are not tables.\n\n    Parameters:\n        materializations_to_include (list[str] | None): List of materializations to include in the check.\n        max_chained_views (int | None): The maximum number of upstream dependents that are not tables.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_chained_views\n              materializations_to_include:\n                - ephemeral\n                - my_custom_materialization\n                - view\n              max_chained_views: 5\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    materializations_to_include: list[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n    )\n    max_chained_views: int = Field(\n        default=3,\n    )\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_max_chained_views\"]\n    package_name: str | None = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If max chained views exceeded.\n\n        \"\"\"\n        self._require_model()\n        self._require_manifest()\n\n        models_by_id = (\n            self.models_by_unique_id\n            if self.models_by_unique_id\n            else {m.unique_id: m for m in self.models}\n        )\n\n        def return_upstream_view_models(\n            materializations,\n            max_chained_views,\n            model_unique_ids_to_check,\n            package_name,\n            depth=0,\n        ):\n            \"\"\"Recursive function to return model unique_id's of upstream models that are views. Depth of recursion can be specified. If no models meet the criteria then an empty list is returned.\n\n            Returns\n            -\n                list[str]: List of model unique_id's of upstream models that are views.\n\n            \"\"\"\n            if depth == max_chained_views or model_unique_ids_to_check == []:\n                return model_unique_ids_to_check\n\n            relevant_upstream_models = []\n            for model_id in model_unique_ids_to_check:\n                model_obj = models_by_id.get(model_id)\n                if model_obj is None:\n                    continue\n                upstream_nodes = (\n                    list(getattr(model_obj.depends_on, \"nodes\", []) or [])\n                    if model_obj.depends_on\n                    else []\n                )\n                if upstream_nodes != []:\n                    upstream_models = [\n                        m\n                        for m in upstream_nodes\n                        if m.split(\".\")[0] == \"model\"\n                        and m.split(\".\")[1] == package_name\n                    ]\n                    for i in upstream_models:\n                        upstream_obj = models_by_id.get(i)\n                        if (\n                            upstream_obj\n                            and upstream_obj.config\n                            and upstream_obj.config.materialized in materializations\n                        ):\n                            relevant_upstream_models.append(i)\n\n            depth += 1\n            return return_upstream_view_models(\n                materializations=materializations,\n                max_chained_views=max_chained_views,\n                model_unique_ids_to_check=relevant_upstream_models,\n                package_name=package_name,\n                depth=depth,\n            )\n\n        if (\n            len(\n                return_upstream_view_models(\n                    materializations=self.materializations_to_include,\n                    max_chained_views=self.max_chained_views,\n                    model_unique_ids_to_check=[self.model.unique_id],\n                    package_name=(\n                        self.package_name\n                        or self.manifest_obj.manifest.metadata.project_name\n                    ),\n                ),\n            )\n            != 0\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has more than {self.max_chained_views} upstream dependents that are not tables.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxFanout","title":"<code>CheckModelMaxFanout</code>","text":"<p>Models cannot have more than the specified number of downstream models.</p> <p>Parameters:</p> Name Type Description Default <code>max_downstream_models</code> <code>int | None</code> <p>The maximum number of permitted downstream models.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_fanout\n      max_downstream_models: 2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxFanout(BaseCheck):\n    \"\"\"Models cannot have more than the specified number of downstream models.\n\n    Parameters:\n        max_downstream_models (int | None): The maximum number of permitted downstream models.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_fanout\n              max_downstream_models: 2\n        ```\n\n    \"\"\"\n\n    max_downstream_models: int = Field(default=3)\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_max_fanout\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If max fanout exceeded.\n\n        \"\"\"\n        self._require_model()\n        num_downstream_models = sum(\n            self.model.unique_id\n            in (getattr(m.depends_on, \"nodes\", []) if m.depends_on else [])\n            for m in self.models\n        )\n\n        if num_downstream_models &gt; self.max_downstream_models:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has {num_downstream_models} downstream models, which is more than the permitted maximum of {self.max_downstream_models}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxNumberOfLines","title":"<code>CheckModelMaxNumberOfLines</code>","text":"<p>Models may not have more than the specified number of lines.</p> <p>Parameters:</p> Name Type Description Default <code>max_number_of_lines</code> <code>int</code> <p>The maximum number of permitted lines.</p> required <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_max_number_of_lines\n      max_number_of_lines: 150\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxNumberOfLines(BaseCheck):\n    \"\"\"Models may not have more than the specified number of lines.\n\n    Parameters:\n        max_number_of_lines (int): The maximum number of permitted lines.\n\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_number_of_lines\n              max_number_of_lines: 150\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_max_number_of_lines\"]\n    max_number_of_lines: int = Field(default=100)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If max lines exceeded.\n\n        \"\"\"\n        self._require_model()\n        actual_number_of_lines = (self.model.raw_code or \"\").count(\"\\n\") + 1\n\n        if actual_number_of_lines &gt; self.max_number_of_lines:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has {actual_number_of_lines} lines, this is more than the maximum permitted number of lines ({self.max_number_of_lines}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelMaxUpstreamDependencies","title":"<code>CheckModelMaxUpstreamDependencies</code>","text":"<p>Limit the number of upstream dependencies a model has.</p> <p>Parameters:</p> Name Type Description Default <code>max_upstream_macros</code> <code>int | None</code> <p>The maximum number of permitted upstream macros.</p> required <code>max_upstream_models</code> <code>int | None</code> <p>The maximum number of permitted upstream models.</p> required <code>max_upstream_sources</code> <code>int | None</code> <p>The maximum number of permitted upstream sources.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_max_upstream_dependencies\n      max_upstream_models: 3\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxUpstreamDependencies(BaseCheck):\n    \"\"\"Limit the number of upstream dependencies a model has.\n\n    Parameters:\n        max_upstream_macros (int | None): The maximum number of permitted upstream macros.\n        max_upstream_models (int | None): The maximum number of permitted upstream models.\n        max_upstream_sources (int | None): The maximum number of permitted upstream sources.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_max_upstream_dependencies\n              max_upstream_models: 3\n        ```\n\n    \"\"\"\n\n    max_upstream_macros: int = Field(\n        default=5,\n    )\n    max_upstream_models: int = Field(\n        default=5,\n    )\n    max_upstream_sources: int = Field(\n        default=1,\n    )\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_max_upstream_dependencies\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If max upstream dependencies exceeded.\n\n        \"\"\"\n        self._require_model()\n        depends_on = self.model.depends_on\n        if depends_on:\n            num_upstream_macros = len(list(getattr(depends_on, \"macros\", []) or []))\n            nodes = getattr(depends_on, \"nodes\", []) or []\n            num_upstream_models = len(\n                [m for m in nodes if m.split(\".\")[0] == \"model\"],\n            )\n            num_upstream_sources = len(\n                [m for m in nodes if m.split(\".\")[0] == \"source\"],\n            )\n        else:\n            num_upstream_macros = 0\n            num_upstream_models = 0\n            num_upstream_sources = 0\n\n        if num_upstream_macros &gt; self.max_upstream_macros:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has {num_upstream_macros} upstream macros, which is more than the permitted maximum of {self.max_upstream_macros}.\"\n            )\n        if num_upstream_models &gt; self.max_upstream_models:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has {num_upstream_models} upstream models, which is more than the permitted maximum of {self.max_upstream_models}.\"\n            )\n        if num_upstream_sources &gt; self.max_upstream_sources:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has {num_upstream_sources} upstream sources, which is more than the permitted maximum of {self.max_upstream_sources}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelNames","title":"<code>CheckModelNames</code>","text":"<p>Models must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>model_name_pattern</code> <code>str</code> <p>Regexp the model name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_names\n      include: ^models/intermediate\n      model_name_pattern: ^int_\n    - name: check_model_names\n      include: ^models/staging\n      model_name_pattern: ^stg_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelNames(BaseCheck):\n    \"\"\"Models must have a name that matches the supplied regex.\n\n    Parameters:\n        model_name_pattern (str): Regexp the model name must match.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_names\n              include: ^models/intermediate\n              model_name_pattern: ^int_\n            - name: check_model_names\n              include: ^models/staging\n              model_name_pattern: ^stg_\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_names\"]\n    model_name_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.model_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model name does not match regex.\n\n        \"\"\"\n        self._require_model()\n        if self._compiled_pattern.match(str(self.model.name)) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` does not match the supplied regex `{self.model_name_pattern.strip()}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelNumberOfGrants","title":"<code>CheckModelNumberOfGrants</code>","text":"<p>Model can have the specified number of privileges.</p> <p>Receives at execution time:</p> Name Type Description <code>max_number_of_privileges</code> <code>int | None</code> <p>Maximum number of privileges, inclusive.</p> <code>min_number_of_privileges</code> <code>int | None</code> <p>Minimum number of privileges, inclusive.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_number_of_grants\n      include: ^models/marts\n      max_number_of_privileges: 1 # Optional\n      min_number_of_privileges: 0 # Optional\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelNumberOfGrants(BaseCheck):\n    \"\"\"Model can have the specified number of privileges.\n\n    Receives:\n        max_number_of_privileges (int | None): Maximum number of privileges, inclusive.\n        min_number_of_privileges (int | None): Minimum number of privileges, inclusive.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_number_of_grants\n              include: ^models/marts\n              max_number_of_privileges: 1 # Optional\n              min_number_of_privileges: 0 # Optional\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_number_of_grants\"]\n    max_number_of_privileges: int = Field(default=100)\n    min_number_of_privileges: int = Field(default=0)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If number of grants is not within limits.\n\n        \"\"\"\n        self._require_model()\n        config = self.model.config\n        grants = config.grants if config else {}\n        num_grants = len((grants or {}).keys())\n\n        if num_grants &lt; self.min_number_of_privileges:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has less grants (`{num_grants}`) than the specified minimum ({self.min_number_of_privileges}).\"\n            )\n        if num_grants &gt; self.max_number_of_privileges:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` has more grants (`{num_grants}`) than the specified maximum ({self.max_number_of_privileges}).\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelPropertyFileLocation","title":"<code>CheckModelPropertyFileLocation</code>","text":"<p>Model properties files must follow the guidance provided by dbt here.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelPropertyFileLocation(BaseCheck):\n    \"\"\"Model properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Parameters:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_property_file_location\n        ```\n\n    \"\"\"\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_property_file_location\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If property file location is incorrect.\n\n        \"\"\"\n        self._require_model()\n        if not (\n            hasattr(self.model, \"patch_path\")\n            and self.model.patch_path\n            and clean_path_str(self.model.patch_path or \"\") is not None\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.model.unique_id)}` is not documented.\"\n            )\n\n        original_path = Path(clean_path_str(self.model.original_file_path))\n        relevant_parts = original_path.parts[1:-1]\n\n        mapped_parts = []\n        for part in relevant_parts:\n            if part == \"staging\":\n                mapped_parts.append(\"stg\")\n            elif part == \"intermediate\":\n                mapped_parts.append(\"int\")\n            elif part == \"marts\":\n                continue\n            else:\n                mapped_parts.append(part)\n\n        expected_substr = \"_\".join(mapped_parts)\n        properties_yml_name = Path(clean_path_str(self.model.patch_path or \"\")).name\n\n        if not properties_yml_name.startswith(\"_\"):\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{get_clean_model_name(self.model.unique_id)}` (`{properties_yml_name}`) does not start with an underscore.\"\n            )\n        if expected_substr not in properties_yml_name:\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{get_clean_model_name(self.model.unique_id)}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n            )\n        if not properties_yml_name.endswith(\"__models.yml\"):\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{get_clean_model_name(self.model.unique_id)}` (`{properties_yml_name}`) does not end with `__models.yml`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelSchemaName","title":"<code>CheckModelSchemaName</code>","text":"<p>Models must have a schema name that matches the supplied regex.</p> <p>Note that most setups will use schema names in development that are prefixed, for example:     * dbt_jdoe_stg_payments     * mary_stg_payments</p> <p>Please account for this if you wish to run <code>dbt-bouncer</code> against locally generated manifests.</p> <p>Parameters:</p> Name Type Description Default <code>schema_name_pattern</code> <code>str</code> <p>Regexp the schema name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_schema_name\n      include: ^models/intermediate\n      schema_name_pattern: .*intermediate # Accounting for schemas like `dbt_jdoe_intermediate`.\n    - name: check_model_schema_name\n      include: ^models/staging\n      schema_name_pattern: .*stg_.*\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelSchemaName(BaseCheck):\n    \"\"\"Models must have a schema name that matches the supplied regex.\n\n    Note that most setups will use schema names in development that are prefixed, for example:\n        * dbt_jdoe_stg_payments\n        * mary_stg_payments\n\n    Please account for this if you wish to run `dbt-bouncer` against locally generated manifests.\n\n    Parameters:\n        schema_name_pattern (str): Regexp the schema name must match.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_schema_name\n              include: ^models/intermediate\n              schema_name_pattern: .*intermediate # Accounting for schemas like `dbt_jdoe_intermediate`.\n            - name: check_model_schema_name\n              include: ^models/staging\n              schema_name_pattern: .*stg_.*\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_schema_name\"]\n    schema_name_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.schema_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If schema name does not match regex.\n\n        \"\"\"\n        self._require_model()\n        if self._compiled_pattern.match(str(self.model.schema_)) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.model.schema_}` does not match the supplied regex `{self.schema_name_pattern.strip()})`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelVersionAllowed","title":"<code>CheckModelVersionAllowed</code>","text":"<p>Check that the version of the model matches the supplied regex pattern.</p> <p>Parameters:</p> Name Type Description Default <code>version_pattern</code> <code>str</code> <p>Regexp the version must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_version_allowed\n      include: ^models/marts\n      version_pattern: &gt;- # Versions must be numeric\n        [0-9]\\d*\n    - name: check_model_version_allowed\n      include: ^models/marts\n      version_pattern: ^(stable|latest)$ # Version can be \"stable\" or \"latest\", nothing else is permitted\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelVersionAllowed(BaseCheck):\n    r\"\"\"Check that the version of the model matches the supplied regex pattern.\n\n    Parameters:\n        version_pattern (str): Regexp the version must match.\n\n    Receives:\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_version_allowed\n              include: ^models/marts\n              version_pattern: &gt;- # Versions must be numeric\n                [0-9]\\d*\n            - name: check_model_version_allowed\n              include: ^models/marts\n              version_pattern: ^(stable|latest)$ # Version can be \"stable\" or \"latest\", nothing else is permitted\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_version_allowed\"]\n    version_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.version_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If version is not allowed.\n\n        \"\"\"\n        self._require_model()\n        if self.model.version and (\n            self._compiled_pattern.match(str(self.model.version)) is None\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"Version `{self.model.version}` in `{self.model.name}` does not match the supplied regex `{self.version_pattern.strip()})`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelVersionPinnedInRef","title":"<code>CheckModelVersionPinnedInRef</code>","text":"<p>Check that the version of the model is always specified in downstream nodes.</p> <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>model</code> <code>DbtBouncerModelBase</code> <p>The DbtBouncerModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the model path. Model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>materialization</code> <code>Literal['ephemeral', 'incremental', 'table', 'view'] | None</code> <p>Limit check to models with the specified materialization.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_version_pinned_in_ref\n      include: ^models/marts\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelVersionPinnedInRef(BaseCheck):\n    r\"\"\"Check that the version of the model is always specified in downstream nodes.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        model (DbtBouncerModelBase): The DbtBouncerModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the model path. Model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        materialization (Literal[\"ephemeral\", \"incremental\", \"table\", \"view\"] | None): Limit check to models with the specified materialization.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_version_pinned_in_ref\n              include: ^models/marts\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    model: \"DbtBouncerModelBase | None\" = Field(default=None)\n    name: Literal[\"check_model_version_pinned_in_ref\"]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If version is not pinned in ref.\n\n        \"\"\"\n        self._require_model()\n        self._require_manifest()\n        child_map = self.manifest_obj.manifest.child_map\n        if child_map and self.model.unique_id in child_map:\n            downstream_models = [\n                x for x in child_map[self.model.unique_id] if x.startswith(\"model.\")\n            ]\n        else:\n            downstream_models = []\n\n        downstream_models_with_unversioned_refs: list[str] = []\n        for m in downstream_models:\n            node = self.manifest_obj.manifest.nodes.get(m)\n            refs = getattr(node, \"refs\", None)\n            if node and refs and isinstance(refs, list):\n                downstream_models_with_unversioned_refs.extend(\n                    m\n                    for ref in refs\n                    if getattr(ref, \"name\", None) == self.model.unique_id.split(\".\")[-1]\n                    and not getattr(ref, \"version\", None)\n                )\n\n        if downstream_models_with_unversioned_refs:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.model.name}` is referenced without a pinned version in downstream models: {downstream_models_with_unversioned_refs}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelsDocumentationCoverage","title":"<code>CheckModelsDocumentationCoverage</code>","text":"<p>Set the minimum percentage of models that have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <code>min_model_documentation_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have a populated description.</p> required <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_documentation_coverage\n      min_model_documentation_coverage_pct: 90\n</code></pre> <pre><code>manifest_checks:\n    - name: check_model_documentation_coverage\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsDocumentationCoverage(BaseCheck):\n    \"\"\"Set the minimum percentage of models that have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n        min_model_documentation_coverage_pct (float): The minimum percentage of models that must have a populated description.\n\n    Receives:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_documentation_coverage\n              min_model_documentation_coverage_pct: 90\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_model_documentation_coverage\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    description: str | None = Field(\n        default=None,\n        description=\"Description of what the check does and why it is implemented.\",\n    )\n    index: int | None = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    min_model_documentation_coverage_pct: int = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_model_documentation_coverage\"]\n    severity: Literal[\"error\", \"warn\"] | None = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If documentation coverage is less than minimum.\n\n        \"\"\"\n        num_models = len(self.models)\n        models_with_description = []\n        for model in self.models:\n            if is_description_populated(\n                description=model.description or \"\", min_description_length=4\n            ):\n                models_with_description.append(model.unique_id)\n\n        num_models_with_descriptions = len(models_with_description)\n        model_description_coverage_pct = (\n            num_models_with_descriptions / num_models\n        ) * 100\n\n        if model_description_coverage_pct &lt; self.min_model_documentation_coverage_pct:\n            raise DbtBouncerFailedCheckError(\n                f\"Only {model_description_coverage_pct}% of models have a populated description, this is less than the permitted minimum of {self.min_model_documentation_coverage_pct}%.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_models/#manifest.check_models.CheckModelsTestCoverage","title":"<code>CheckModelsTestCoverage</code>","text":"<p>Set the minimum percentage of models that have at least one test.</p> <p>Parameters:</p> Name Type Description Default <code>min_model_test_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have at least one test.</p> required <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> required <code>tests</code> <code>list[DbtBouncerTestBase]</code> <p>List of DbtBouncerTestBase objects parsed from <code>manifest.json</code>.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_model_test_coverage\n      min_model_test_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsTestCoverage(BaseCheck):\n    \"\"\"Set the minimum percentage of models that have at least one test.\n\n    Parameters:\n        min_model_test_coverage_pct (float): The minimum percentage of models that must have at least one test.\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        tests (list[DbtBouncerTestBase]): List of DbtBouncerTestBase objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_model_test_coverage\n              min_model_test_coverage_pct: 90\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    description: str | None = Field(\n        default=None,\n        description=\"Description of what the check does and why it is implemented.\",\n    )\n    index: int | None = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    name: Literal[\"check_model_test_coverage\"]\n    min_model_test_coverage_pct: float = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    severity: Literal[\"error\", \"warn\"] | None = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n    tests: list[\"DbtBouncerTestBase\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If test coverage is less than minimum.\n\n        \"\"\"\n        num_models = len(self.models)\n        # Build set of model IDs that have at least one test\n        tested_model_ids = {\n            node\n            for test in self.tests\n            if test.depends_on\n            for node in (getattr(test.depends_on, \"nodes\", []) or [])\n        }\n        model_ids = {m.unique_id for m in self.models}\n        num_models_with_tests = len(model_ids &amp; tested_model_ids)\n        model_test_coverage_pct = (num_models_with_tests / num_models) * 100\n\n        if model_test_coverage_pct &lt; self.min_model_test_coverage_pct:\n            raise DbtBouncerFailedCheckError(\n                f\"Only {model_test_coverage_pct}% of models have at least one test, this is less than the permitted minimum of {self.min_model_test_coverage_pct}%.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_seeds/","title":"Manifest Checks: Seeds","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSeedDescriptionPopulated</code> <p>Seeds must have a populated description.</p> <code>CheckSeedNames</code> <p>Seed must have a name that matches the supplied regex.</p>"},{"location":"checks/manifest/check_seeds/#manifest.check_seeds.CheckSeedDescriptionPopulated","title":"<code>CheckSeedDescriptionPopulated</code>","text":"<p>Seeds must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>seed</code> <code>DbtBouncerSeedBase</code> <p>The DbtBouncerSeedBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the seed path. Seed paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the seed path. Only seed paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_seed_description_populated\n</code></pre> <pre><code>manifest_checks:\n    - name: check_seed_description_populated\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_seeds.py</code> <pre><code>class CheckSeedDescriptionPopulated(BaseCheck):\n    \"\"\"Seeds must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        seed (DbtBouncerSeedBase): The DbtBouncerSeedBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the seed path. Seed paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the seed path. Only seed paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_seed_description_populated\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_seed_description_populated\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    min_description_length: int | None = Field(default=None)\n    name: Literal[\"check_seed_description_populated\"]\n    seed: \"DbtBouncerSeedBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If description is not populated.\n\n        \"\"\"\n        self._require_seed()\n        if not self._is_description_populated(\n            self.seed.description or \"\", self.min_description_length\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.seed.unique_id)}` does not have a populated description.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_seeds/#manifest.check_seeds.CheckSeedNames","title":"<code>CheckSeedNames</code>","text":"<p>Seed must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>seed_name_pattern</code> <code>str</code> <p>Regexp the seed name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>seed</code> <code>DbtBouncerSeedBase</code> <p>The DbtBouncerSeedBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the seed path. Seed paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the seed path. Only seed paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_seed_names\n      include: ^seeds\n      model_name_pattern: ^raw_\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_seeds.py</code> <pre><code>class CheckSeedNames(BaseCheck):\n    \"\"\"Seed must have a name that matches the supplied regex.\n\n    Parameters:\n        seed_name_pattern (str): Regexp the seed name must match.\n\n    Receives:\n        seed (DbtBouncerSeedBase): The DbtBouncerSeedBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the seed path. Seed paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the seed path. Only seed paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_seed_names\n              include: ^seeds\n              model_name_pattern: ^raw_\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    name: Literal[\"check_seed_names\"]\n    seed: \"DbtBouncerSeedBase | None\" = Field(default=None)\n    seed_name_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.seed_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If model name does not match regex.\n\n        \"\"\"\n        self._require_seed()\n        if self._compiled_pattern.match(str(self.seed.name)) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{get_clean_model_name(self.seed.unique_id)}` does not match the supplied regex `{self.seed_name_pattern.strip()}`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_semantic_models/","title":"Manifest Checks: Semantic Models","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSemanticModelOnNonPublicModels</code> <p>Semantic models should be based on public models only.</p>"},{"location":"checks/manifest/check_semantic_models/#manifest.check_semantic_models.CheckSemanticModelOnNonPublicModels","title":"<code>CheckSemanticModelOnNonPublicModels</code>","text":"<p>Semantic models should be based on public models only.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>semantic_model</code> <code>DbtBouncerSemanticModelBase</code> <p>The DbtBouncerSemanticModelBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Semantic model paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Only semantic model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_semantic_model_based_on_non_public_models\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_semantic_models.py</code> <pre><code>class CheckSemanticModelOnNonPublicModels(BaseCheck):\n    \"\"\"Semantic models should be based on public models only.\n\n    Receives:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        semantic_model (DbtBouncerSemanticModelBase): The DbtBouncerSemanticModelBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Semantic model paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the semantic model path (i.e the .yml file where the semantic model is configured). Only semantic model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_semantic_model_based_on_non_public_models\n        ```\n\n    \"\"\"\n\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_semantic_model_based_on_non_public_models\"]\n    semantic_model: \"DbtBouncerSemanticModelBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If semantic model is based on non-public models.\n\n        \"\"\"\n        semantic_model = self._require_semantic_model()\n        models_by_id = (\n            self.models_by_unique_id\n            if self.models_by_unique_id\n            else {m.unique_id: m for m in self.models}\n        )\n        non_public_upstream_dependencies = []\n        for model in getattr(semantic_model.depends_on, \"nodes\", []) or []:\n            model_obj = models_by_id.get(model)\n            if not model_obj:\n                continue\n            if (\n                model_obj.resource_type == \"model\"\n                and model_obj.package_name == semantic_model.package_name\n                and model_obj.access\n                and model_obj.access.value != \"public\"\n            ):\n                non_public_upstream_dependencies.append(model_obj.name)\n\n        if non_public_upstream_dependencies:\n            raise DbtBouncerFailedCheckError(\n                f\"Semantic model `{semantic_model.name}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_snapshots/","title":"Manifest Checks: Snapshots","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSnapshotHasTags</code> <p>Snapshots must have the specified tags.</p> <code>CheckSnapshotNames</code> <p>Snapshots must have a name that matches the supplied regex.</p>"},{"location":"checks/manifest/check_snapshots/#manifest.check_snapshots.CheckSnapshotHasTags","title":"<code>CheckSnapshotHasTags</code>","text":"<p>Snapshots must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <p>(Literal[\"any\", \"all\", \"one\"] | None): Whether the snapshot must have any, all, or exactly one of the specified tags. Default: <code>all</code>.</p> required <code>snapshot</code> <code>DbtBouncerSnapshotBase</code> <p>The DbtBouncerSnapshotBase object to check.</p> required <code>tags</code> <code>list[str]</code> <p>List of tags to check for.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the snapshot path. Snapshot paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the snapshot path. Only snapshot paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_snapshot_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_snapshots.py</code> <pre><code>class CheckSnapshotHasTags(BaseCheck):\n    \"\"\"Snapshots must have the specified tags.\n\n    Parameters:\n        criteria: (Literal[\"any\", \"all\", \"one\"] | None): Whether the snapshot must have any, all, or exactly one of the specified tags. Default: `all`.\n        snapshot (DbtBouncerSnapshotBase): The DbtBouncerSnapshotBase object to check.\n        tags (list[str]): List of tags to check for.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the snapshot path. Snapshot paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the snapshot path. Only snapshot paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_snapshot_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n\n    \"\"\"\n\n    criteria: Literal[\"any\", \"all\", \"one\"] = Field(default=\"all\")\n    name: Literal[\"check_snapshot_has_tags\"]\n    snapshot: \"DbtBouncerSnapshotBase | None\" = Field(default=None)\n    tags: list[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If snapshot does not have required tags.\n\n        \"\"\"\n        self._require_snapshot()\n        snapshot_tags = self.snapshot.tags or []\n        if self.criteria == \"any\":\n            if not any(tag in snapshot_tags for tag in self.tags):\n                raise DbtBouncerFailedCheckError(\n                    f\"`{self.snapshot.name}` does not have any of the required tags: {self.tags}.\"\n                )\n        elif self.criteria == \"all\":\n            missing_tags = [tag for tag in self.tags if tag not in snapshot_tags]\n            if missing_tags:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{self.snapshot.name}` is missing required tags: {missing_tags}.\"\n                )\n        elif (\n            self.criteria == \"one\"\n            and sum(tag in snapshot_tags for tag in self.tags) != 1\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.snapshot.name}` must have exactly one of the required tags: {self.tags}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_snapshots/#manifest.check_snapshots.CheckSnapshotNames","title":"<code>CheckSnapshotNames</code>","text":"<p>Snapshots must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot_name_pattern</code> <code>str</code> <p>Regexp the snapshot name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>snapshot</code> <code>DbtBouncerSnapshotBase</code> <p>The DbtBouncerSnapshotBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the snapshot path. Snapshot paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the snapshot path. Only snapshot paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_snapshot_names\n      include: ^snapshots/erp\n      snapshot_name_pattern: ^erp\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_snapshots.py</code> <pre><code>class CheckSnapshotNames(BaseCheck):\n    \"\"\"Snapshots must have a name that matches the supplied regex.\n\n    Parameters:\n        snapshot_name_pattern (str): Regexp the snapshot name must match.\n\n    Receives:\n        snapshot (DbtBouncerSnapshotBase): The DbtBouncerSnapshotBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the snapshot path. Snapshot paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the snapshot path. Only snapshot paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_snapshot_names\n              include: ^snapshots/erp\n              snapshot_name_pattern: ^erp\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_snapshot_names\"]\n    snapshot: \"DbtBouncerSnapshotBase | None\" = Field(default=None)\n    snapshot_name_pattern: str\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.snapshot_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If snapshot name does not match regex.\n\n        \"\"\"\n        self._require_snapshot()\n        if self._compiled_pattern.match(str(self.snapshot.name)) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.snapshot.name}` does not match the supplied regex `{self.snapshot_name_pattern.strip()})`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/","title":"Manifest Checks: Sources","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckSourceDescriptionPopulated</code> <p>Sources must have a populated description.</p> <code>CheckSourceFreshnessPopulated</code> <p>Sources must have a populated freshness.</p> <code>CheckSourceHasMetaKeys</code> <p>The <code>meta</code> config for sources must have the specified keys.</p> <code>CheckSourceHasTags</code> <p>Sources must have the specified tags.</p> <code>CheckSourceLoaderPopulated</code> <p>Sources must have a populated loader.</p> <code>CheckSourceNames</code> <p>Sources must have a name that matches the supplied regex.</p> <code>CheckSourceNotOrphaned</code> <p>Sources must be referenced in at least one model.</p> <code>CheckSourcePropertyFileLocation</code> <p>Source properties files must follow the guidance provided by dbt here.</p> <code>CheckSourceUsedByModelsInSameDirectory</code> <p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> <code>CheckSourceUsedByOnlyOneModel</code> <p>Each source can be referenced by a maximum of one model.</p>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceDescriptionPopulated","title":"<code>CheckSourceDescriptionPopulated</code>","text":"<p>Sources must have a populated description.</p> <p>Parameters:</p> Name Type Description Default <code>min_description_length</code> <code>int | None</code> <p>Minimum length required for the description to be considered populated.</p> required <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSourceBase</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_description_populated\n</code></pre> <pre><code>manifest_checks:\n    - name: check_source_description_populated\n      min_description_length: 25 # Setting a stricter requirement for description length\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceDescriptionPopulated(BaseCheck):\n    \"\"\"Sources must have a populated description.\n\n    Parameters:\n        min_description_length (int | None): Minimum length required for the description to be considered populated.\n\n    Receives:\n        source (DbtBouncerSourceBase): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_description_populated\n        ```\n        ```yaml\n        manifest_checks:\n            - name: check_source_description_populated\n              min_description_length: 25 # Setting a stricter requirement for description length\n        ```\n\n    \"\"\"\n\n    min_description_length: int | None = Field(default=None)\n    name: Literal[\"check_source_description_populated\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If description is not populated.\n\n        \"\"\"\n        self._require_source()\n        if not self._is_description_populated(\n            self.source.description or \"\", self.min_description_length\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.source.source_name}.{self.source.name}` does not have a populated description.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceFreshnessPopulated","title":"<code>CheckSourceFreshnessPopulated</code>","text":"<p>Sources must have a populated freshness.</p> <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_freshness_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceFreshnessPopulated(BaseCheck):\n    \"\"\"Sources must have a populated freshness.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_freshness_populated\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_freshness_populated\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If freshness is not populated.\n\n        \"\"\"\n        self._require_source()\n        error_msg = f\"`{self.source.source_name}.{self.source.name}` does not have a populated freshness.\"\n        if self.source.freshness is None:\n            raise DbtBouncerFailedCheckError(error_msg)\n        has_error_after = (\n            self.source.freshness.error_after\n            and self.source.freshness.error_after.count is not None\n            and self.source.freshness.error_after.period is not None\n        )\n        has_warn_after = (\n            self.source.freshness.warn_after\n            and self.source.freshness.warn_after.count is not None\n            and self.source.freshness.warn_after.period is not None\n        )\n\n        if not (has_error_after or has_warn_after):\n            raise DbtBouncerFailedCheckError(error_msg)\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceHasMetaKeys","title":"<code>CheckSourceHasMetaKeys</code>","text":"<p>The <code>meta</code> config for sources must have the specified keys.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>NestedDict</code> <p>A list (that may contain sub-lists) of required keys.</p> required <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_meta_keys\n      keys:\n        - contact:\n            - email\n            - slack\n        - owner\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasMetaKeys(BaseCheck):\n    \"\"\"The `meta` config for sources must have the specified keys.\n\n    Parameters:\n        keys (NestedDict): A list (that may contain sub-lists) of required keys.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_meta_keys\n              keys:\n                - contact:\n                    - email\n                    - slack\n                - owner\n        ```\n\n    \"\"\"\n\n    keys: \"NestedDict\"\n    name: Literal[\"check_source_has_meta_keys\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If required meta keys are missing.\n\n        \"\"\"\n        self._require_source()\n        missing_keys = find_missing_meta_keys(\n            meta_config=self.source.meta,\n            required_keys=self.keys.model_dump(),\n        )\n\n        if missing_keys != []:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.source.source_name}.{self.source.name}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceHasTags","title":"<code>CheckSourceHasTags</code>","text":"<p>Sources must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <p>(Literal[\"any\", \"all\", \"one\"] | None): Whether the source must have any, all, or exactly one of the specified tags. Default: <code>all</code>.</p> required <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <code>tags</code> <code>list[str]</code> <p>List of tags to check for.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_has_tags\n      tags:\n        - tag_1\n        - tag_2\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasTags(BaseCheck):\n    \"\"\"Sources must have the specified tags.\n\n    Parameters:\n        criteria: (Literal[\"any\", \"all\", \"one\"] | None): Whether the source must have any, all, or exactly one of the specified tags. Default: `all`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n        tags (list[str]): List of tags to check for.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_has_tags\n              tags:\n                - tag_1\n                - tag_2\n        ```\n\n    \"\"\"\n\n    criteria: Literal[\"any\", \"all\", \"one\"] = Field(default=\"all\")\n    name: Literal[\"check_source_has_tags\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n    tags: list[str]\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source does not have required tags.\n\n        \"\"\"\n        self._require_source()\n        source_tags = self.source.tags or []\n        if self.criteria == \"any\":\n            if not any(tag in source_tags for tag in self.tags):\n                raise DbtBouncerFailedCheckError(\n                    f\"`{self.source.source_name}.{self.source.name}` does not have any of the required tags: {self.tags}.\"\n                )\n        elif self.criteria == \"all\":\n            missing_tags = set(self.tags) - set(source_tags)\n            if missing_tags:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{self.source.source_name}.{self.source.name}` is missing required tags: {missing_tags}.\"\n                )\n        elif (\n            self.criteria == \"one\" and sum(tag in source_tags for tag in self.tags) != 1\n        ):\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.source.source_name}.{self.source.name}` must have exactly one of the required tags: {self.tags}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceLoaderPopulated","title":"<code>CheckSourceLoaderPopulated</code>","text":"<p>Sources must have a populated loader.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_loader_populated\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceLoaderPopulated(BaseCheck):\n    \"\"\"Sources must have a populated loader.\n\n    Parameters:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_loader_populated\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_loader_populated\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If loader is not populated.\n\n        \"\"\"\n        self._require_source()\n        if self.source.loader == \"\":\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.source.source_name}.{self.source.name}` does not have a populated loader.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceNames","title":"<code>CheckSourceNames</code>","text":"<p>Sources must have a name that matches the supplied regex.</p> <p>Parameters:</p> Name Type Description Default <code>source_name_pattern</code> <code>str</code> <p>Regexp the source name must match.</p> required <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_names\n      source_name_pattern: &gt;\n        ^[a-z0-9_]*$\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNames(BaseCheck):\n    \"\"\"Sources must have a name that matches the supplied regex.\n\n    Parameters:\n        source_name_pattern (str): Regexp the source name must match.\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_names\n              source_name_pattern: &gt;\n                ^[a-z0-9_]*$\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_names\"]\n    source_name_pattern: str\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    _compiled_pattern: re.Pattern[str] = PrivateAttr()\n\n    def model_post_init(self, __context: object) -&gt; None:\n        \"\"\"Compile the regex pattern once at initialisation time.\"\"\"\n        self._compiled_pattern = compile_pattern(self.source_name_pattern.strip())\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source name does not match regex.\n\n        \"\"\"\n        self._require_source()\n        if self._compiled_pattern.match(str(self.source.name)) is None:\n            raise DbtBouncerFailedCheckError(\n                f\"`{self.source.source_name}.{self.source.name}` does not match the supplied regex `({self.source_name_pattern.strip()})`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceNotOrphaned","title":"<code>CheckSourceNotOrphaned</code>","text":"<p>Sources must be referenced in at least one model.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_not_orphaned\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNotOrphaned(BaseCheck):\n    \"\"\"Sources must be referenced in at least one model.\n\n    Receives:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_not_orphaned\n        ```\n\n    \"\"\"\n\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_not_orphaned\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source is orphaned.\n\n        \"\"\"\n        self._require_source()\n        num_refs = sum(\n            self.source.unique_id in getattr(model.depends_on, \"nodes\", [])\n            for model in self.models\n            if model.depends_on\n        )\n        if num_refs &lt; 1:\n            raise DbtBouncerFailedCheckError(\n                f\"Source `{self.source.source_name}.{self.source.name}` is orphaned, i.e. not referenced by any model.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourcePropertyFileLocation","title":"<code>CheckSourcePropertyFileLocation</code>","text":"<p>Source properties files must follow the guidance provided by dbt here.</p> <p>Receives at execution time:</p> Name Type Description <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_property_file_location\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourcePropertyFileLocation(BaseCheck):\n    \"\"\"Source properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n\n    Receives:\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_property_file_location\n        ```\n\n    \"\"\"\n\n    name: Literal[\"check_source_property_file_location\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If property file location is incorrect.\n\n        \"\"\"\n        self._require_source()\n        original_path = Path(clean_path_str(self.source.original_file_path))\n\n        if (\n            len(original_path.parts) &gt; 2\n            and original_path.parts[0] == \"models\"\n            and original_path.parts[1] == \"staging\"\n        ):\n            subdir_parts = original_path.parent.parts[2:]\n        else:\n            subdir_parts = original_path.parent.parts\n\n        expected_substring = \"_\" + \"_\".join(subdir_parts) if subdir_parts else \"\"\n        properties_yml_name = original_path.name\n\n        if not properties_yml_name.startswith(\"_\"):\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n            )\n        if expected_substring not in properties_yml_name:\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substring}`).\"\n            )\n        if not properties_yml_name.endswith(\"__sources.yml\"):\n            raise DbtBouncerFailedCheckError(\n                f\"The properties file for `{self.source.source_name}.{self.source.name}` (`{properties_yml_name}`) does not end with `__sources.yml`.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceUsedByModelsInSameDirectory","title":"<code>CheckSourceUsedByModelsInSameDirectory</code>","text":"<p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> <p>Parameters:</p> Name Type Description Default <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> required <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_models_in_same_directory\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByModelsInSameDirectory(BaseCheck):\n    \"\"\"Sources can only be referenced by models that are located in the same directory where the source is defined.\n\n    Parameters:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_models_in_same_directory\n        ```\n\n    \"\"\"\n\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_used_by_models_in_same_directory\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source is referenced by models in different directory.\n\n        \"\"\"\n        self._require_source()\n        reffed_models_not_in_same_dir = []\n        for model in self.models:\n            if (\n                model.depends_on\n                and self.source.unique_id in getattr(model.depends_on, \"nodes\", [])\n                and model.original_file_path.split(\"/\")[:-1]\n                != self.source.original_file_path.split(\"/\")[:-1]\n            ):\n                reffed_models_not_in_same_dir.append(model.name)\n\n        if len(reffed_models_not_in_same_dir) != 0:\n            raise DbtBouncerFailedCheckError(\n                f\"Source `{self.source.source_name}.{self.source.name}` is referenced by models defined in a different directory: {reffed_models_not_in_same_dir}\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_sources/#manifest.check_sources.CheckSourceUsedByOnlyOneModel","title":"<code>CheckSourceUsedByOnlyOneModel</code>","text":"<p>Each source can be referenced by a maximum of one model.</p> <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>source</code> <code>DbtBouncerSource</code> <p>The DbtBouncerSourceBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_source_used_by_only_one_model\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByOnlyOneModel(BaseCheck):\n    \"\"\"Each source can be referenced by a maximum of one model.\n\n    Receives:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        source (DbtBouncerSource): The DbtBouncerSourceBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Source paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the source path (i.e the .yml file where the source is configured). Only source paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_source_used_by_only_one_model\n        ```\n\n    \"\"\"\n\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_source_used_by_only_one_model\"]\n    source: \"DbtBouncerSourceBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If source is referenced by more than one model.\n\n        \"\"\"\n        self._require_source()\n        num_refs = sum(\n            self.source.unique_id in getattr(model.depends_on, \"nodes\", [])\n            for model in self.models\n            if model.depends_on\n        )\n        if num_refs &gt; 1:\n            raise DbtBouncerFailedCheckError(\n                f\"Source `{self.source.source_name}.{self.source.name}` is referenced by more than one model.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_tests/","title":"Manifest Checks: Tests","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckTestHasTags</code> <p>Data tests must have the specified tags.</p>"},{"location":"checks/manifest/check_tests/#manifest.check_tests.CheckTestHasTags","title":"<code>CheckTestHasTags</code>","text":"<p>Data tests must have the specified tags.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Literal['any', 'all', 'one'] | None</code> <p>Whether the test must have any, all, or exactly one of the specified tags. Default: <code>any</code>.</p> required <code>tags</code> <code>list[str]</code> <p>List of tags to check for.</p> required <p>Receives at execution time:</p> Name Type Description <code>test</code> <code>DbtBouncerTestBase</code> <p>The DbtBouncerTestBase object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the test path. Test paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the test path. Only test paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_test_has_tags\n      tags:\n        - critical\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_tests.py</code> <pre><code>class CheckTestHasTags(BaseCheck):\n    \"\"\"Data tests must have the specified tags.\n\n    Parameters:\n        criteria (Literal[\"any\", \"all\", \"one\"] | None): Whether the test must have any, all, or exactly one of the specified tags. Default: `any`.\n        tags (list[str]): List of tags to check for.\n\n    Receives:\n        test (DbtBouncerTestBase): The DbtBouncerTestBase object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the test path. Test paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the test path. Only test paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_test_has_tags\n              tags:\n                - critical\n        ```\n\n    \"\"\"\n\n    criteria: Literal[\"any\", \"all\", \"one\"] = Field(default=\"any\")\n    name: Literal[\"check_test_has_tags\"]\n    tags: list[str]\n    test: \"DbtBouncerTestBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If the test does not have the required tags.\n\n        \"\"\"\n        test = self._require_test()\n        test_tags = test.tags or []\n        if self.criteria == \"any\":\n            if not any(tag in test_tags for tag in self.tags):\n                raise DbtBouncerFailedCheckError(\n                    f\"`{test.unique_id}` does not have any of the required tags: {self.tags}.\"\n                )\n        elif self.criteria == \"all\":\n            missing_tags = [tag for tag in self.tags if tag not in test_tags]\n            if missing_tags:\n                raise DbtBouncerFailedCheckError(\n                    f\"`{test.unique_id}` is missing required tags: {missing_tags}.\"\n                )\n        elif self.criteria == \"one\" and sum(tag in test_tags for tag in self.tags) != 1:\n            raise DbtBouncerFailedCheckError(\n                f\"`{test.unique_id}` must have exactly one of the required tags: {self.tags}.\"\n            )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/","title":"Manifest Checks: Unit Tests","text":"<p>Note</p> <p>The below checks require <code>manifest.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckUnitTestCoverage</code> <p>Set the minimum percentage of models that have a unit test.</p> <code>CheckUnitTestExpectFormats</code> <p>Unit tests can only use the specified formats.</p> <code>CheckUnitTestGivenFormats</code> <p>Unit tests can only use the specified formats.</p>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestCoverage","title":"<code>CheckUnitTestCoverage</code>","text":"<p>Set the minimum percentage of models that have a unit test.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>min_unit_test_coverage_pct</code> <code>float</code> <p>The minimum percentage of models that must have a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>models</code> <code>list[DbtBouncerModelBase]</code> <p>List of DbtBouncerModelBase objects parsed from <code>manifest.json</code>.</p> <code>unit_tests</code> <code>list[UnitTests]</code> <p>List of UnitTests objects parsed from <code>manifest.json</code>.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the model path. Only model paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_coverage\n      min_unit_test_coverage_pct: 90\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestCoverage(BaseCheck):\n    \"\"\"Set the minimum percentage of models that have a unit test.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        min_unit_test_coverage_pct (float): The minimum percentage of models that must have a unit test.\n\n    Receives:\n        models (list[DbtBouncerModelBase]): List of DbtBouncerModelBase objects parsed from `manifest.json`.\n        unit_tests (list[UnitTests]): List of UnitTests objects parsed from `manifest.json`.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        include (str | None): Regex pattern to match the model path. Only model paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_coverage\n              min_unit_test_coverage_pct: 90\n        ```\n\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n    description: str | None = Field(\n        default=None,\n        description=\"Description of what the check does and why it is implemented.\",\n    )\n    include: str | None = Field(\n        default=None,\n        description=\"Regexp to match which paths to include.\",\n    )\n    index: int | None = Field(\n        default=None,\n        description=\"Index to uniquely identify the check, calculated at runtime.\",\n    )\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    min_unit_test_coverage_pct: int = Field(\n        default=100,\n        ge=0,\n        le=100,\n    )\n    models: list[\"DbtBouncerModelBase\"] = Field(default=[])\n    name: Literal[\"check_unit_test_coverage\"]\n    severity: Literal[\"error\", \"warn\"] | None = Field(\n        default=\"error\",\n        description=\"Severity of the check, one of 'error' or 'warn'.\",\n    )\n    unit_tests: list[\"UnitTests\"] = Field(default=[])\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If unit test coverage is less than permitted minimum.\n\n        \"\"\"\n        self._require_manifest()\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version or \"0.0.0\"\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            relevant_models = [\n                m.unique_id\n                for m in self.models\n                if object_in_path(self.include, m.original_file_path)\n            ]\n            models_with_unit_test = []\n            for unit_test in self.unit_tests:\n                if unit_test.depends_on and unit_test.depends_on.nodes:\n                    for node in unit_test.depends_on.nodes:\n                        if node in relevant_models:\n                            models_with_unit_test.append(node)\n\n            num_models_with_unit_tests = len(set(models_with_unit_test))\n            unit_test_coverage_pct = (\n                num_models_with_unit_tests / len(relevant_models)\n            ) * 100\n\n            if unit_test_coverage_pct &lt; self.min_unit_test_coverage_pct:\n                raise DbtBouncerFailedCheckError(\n                    f\"Only {unit_test_coverage_pct}% of models have a unit test, this is less than the permitted minimum of {self.min_unit_test_coverage_pct}%.\"\n                )\n        else:\n            logging.warning(\n                \"The `check_unit_test_expect_format` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestExpectFormats","title":"<code>CheckUnitTestExpectFormats</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>permitted_formats</code> <code>list[Literal['csv', 'dict', 'sql']] | None</code> <p>A list of formats that are allowed to be used for <code>expect</code> input in a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_expect_format\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestExpectFormats(BaseCheck):\n    \"\"\"Unit tests can only use the specified formats.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        permitted_formats (list[Literal[\"csv\", \"dict\", \"sql\"]] | None): A list of formats that are allowed to be used for `expect` input in a unit test.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_expect_format\n              permitted_formats:\n                - csv\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    name: Literal[\"check_unit_test_expect_format\"]\n    permitted_formats: list[Literal[\"csv\", \"dict\", \"sql\"]] = Field(\n        default=[\"csv\", \"dict\", \"sql\"],\n    )\n    unit_test: \"UnitTests | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If unit test expect format is not permitted.\n\n        \"\"\"\n        self._require_manifest()\n        self._require_unit_test()\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version or \"0.0.0\"\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            if self.unit_test.expect.format is None:\n                raise DbtBouncerFailedCheckError(\n                    f\"Unit test `{self.unit_test.name}` does not have an `expect` format defined. \"\n                    f\"Permitted formats are: {self.permitted_formats}.\"\n                )\n\n            format_value = (\n                self.unit_test.expect.format.value\n                if self.unit_test.expect.format\n                else None\n            )\n\n            if format_value not in self.permitted_formats:\n                raise DbtBouncerFailedCheckError(\n                    f\"Unit test `{self.unit_test.name}` has an `expect` format that is not permitted. \"\n                    f\"Permitted formats are: {self.permitted_formats}. \"\n                    f\"Found: {format_value}\"\n                )\n        else:\n            logging.warning(\n                \"The `check_unit_test_expect_format` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/manifest/check_unit_tests/#manifest.check_unit_tests.CheckUnitTestGivenFormats","title":"<code>CheckUnitTestGivenFormats</code>","text":"<p>Unit tests can only use the specified formats.</p> <p>Warning</p> <p>This check is only supported for dbt 1.8.0 and above.</p> <p>Parameters:</p> Name Type Description Default <code>permitted_formats</code> <code>list[Literal['csv', 'dict', 'sql']] | None</code> <p>A list of formats that are allowed to be used for <code>expect</code> input in a unit test.</p> required <p>Receives at execution time:</p> Name Type Description <code>manifest_obj</code> <code>DbtBouncerManifest</code> <p>The DbtBouncerManifest object parsed from <code>manifest.json</code>.</p> <code>unit_test</code> <code>UnitTests</code> <p>The UnitTests object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>manifest_checks:\n    - name: check_unit_test_given_formats\n      permitted_formats:\n        - csv\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/manifest/check_unit_tests.py</code> <pre><code>class CheckUnitTestGivenFormats(BaseCheck):\n    \"\"\"Unit tests can only use the specified formats.\n\n    !!! warning\n\n        This check is only supported for dbt 1.8.0 and above.\n\n    Parameters:\n        permitted_formats (list[Literal[\"csv\", \"dict\", \"sql\"]] | None): A list of formats that are allowed to be used for `expect` input in a unit test.\n\n    Receives:\n        manifest_obj (DbtBouncerManifest): The DbtBouncerManifest object parsed from `manifest.json`.\n        unit_test (UnitTests): The UnitTests object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Unit test paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the unit test path (i.e the .yml file where the unit test is configured). Only unit test paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        manifest_checks:\n            - name: check_unit_test_given_formats\n              permitted_formats:\n                - csv\n        ```\n\n    \"\"\"\n\n    manifest_obj: \"DbtBouncerManifest | None\" = Field(default=None)\n    name: Literal[\"check_unit_test_given_formats\"]\n    permitted_formats: list[Literal[\"csv\", \"dict\", \"sql\"]] = Field(\n        default=[\"csv\", \"dict\", \"sql\"],\n    )\n    unit_test: \"UnitTests | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If unit test given formats are not permitted.\n\n        \"\"\"\n        self._require_manifest()\n        self._require_unit_test()\n        if get_package_version_number(\n            self.manifest_obj.manifest.metadata.dbt_version or \"0.0.0\"\n        ) &gt;= get_package_version_number(\"1.8.0\"):\n            given_formats = [\n                i.format.value for i in self.unit_test.given if i.format is not None\n            ]\n            if not all(e in self.permitted_formats for e in given_formats):\n                raise DbtBouncerFailedCheckError(\n                    f\"Unit test `{self.unit_test.name}` has given formats which are not permitted. Permitted formats are: {self.permitted_formats}.\"\n                )\n        else:\n            logging.warning(\n                \"The `check_unit_test_given_formats` check is only supported for dbt 1.8.0 and above.\",\n            )\n</code></pre>"},{"location":"checks/run_results/check_run_results/","title":"Run Results Checks","text":"<p>Note</p> <p>The below checks require both <code>manifest.json</code> and <code>run_results.json</code> to be present.</p> <p>Classes:</p> Name Description <code>CheckRunResultsMaxExecutionTime</code> <p>Each result can take a maximum duration (seconds).</p> <code>CheckRunResultsMaxGigabytesBilled</code> <p>Each result can have a maximum number of gigabytes billed.</p>"},{"location":"checks/run_results/check_run_results/#run_results.check_run_results.CheckRunResultsMaxExecutionTime","title":"<code>CheckRunResultsMaxExecutionTime</code>","text":"<p>Each result can take a maximum duration (seconds).</p> <p>Parameters:</p> Name Type Description Default <code>max_execution_time_seconds</code> <code>float</code> <p>The maximum execution time (seconds) allowed for a node.</p> required <p>Receives at execution time:</p> Name Type Description <code>run_result</code> <code>DbtBouncerRunResult</code> <p>The DbtBouncerRunResult object to check.</p> <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      max_execution_time_seconds: 60\n</code></pre> <pre><code>run_results_checks:\n    - name: check_run_results_max_execution_time\n      include: ^models/staging # Not a good idea, here for demonstration purposes only\n      max_execution_time_seconds: 10\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxExecutionTime(BaseCheck):\n    \"\"\"Each result can take a maximum duration (seconds).\n\n    Parameters:\n        max_execution_time_seconds (float): The maximum execution time (seconds) allowed for a node.\n\n    Receives:\n        run_result (DbtBouncerRunResult): The DbtBouncerRunResult object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              max_execution_time_seconds: 60\n        ```\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_execution_time\n              include: ^models/staging # Not a good idea, here for demonstration purposes only\n              max_execution_time_seconds: 10\n        ```\n\n    \"\"\"\n\n    max_execution_time_seconds: float\n    name: Literal[\"check_run_results_max_execution_time\"]\n    run_result: \"DbtBouncerRunResultBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If execution time is greater than permitted.\n\n        \"\"\"\n        run_result = self._require_run_result()\n        if run_result.execution_time &gt; self.max_execution_time_seconds:\n            raise DbtBouncerFailedCheckError(\n                f\"`{run_result.unique_id.split('.')[-1]}` has an execution time ({run_result.execution_time} greater than permitted ({self.max_execution_time_seconds}s).\"\n            )\n</code></pre>"},{"location":"checks/run_results/check_run_results/#run_results.check_run_results.CheckRunResultsMaxGigabytesBilled","title":"<code>CheckRunResultsMaxGigabytesBilled</code>","text":"<p>Each result can have a maximum number of gigabytes billed.</p> <p>Note</p> <p>Note that this check only works for the <code>dbt-bigquery</code> adapter.</p> <p>Parameters:</p> Name Type Description Default <code>max_gigabytes_billed</code> <code>float</code> <p>The maximum number of gigabytes billed.</p> required <code>run_result</code> <code>DbtBouncerRunResult</code> <p>The DbtBouncerRunResult object to check.</p> required <p>Other Parameters (passed via config file):</p> Name Type Description <code>description</code> <code>str | None</code> <p>Description of what the check does and why it is implemented.</p> <code>exclude</code> <code>str | None</code> <p>Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.</p> <code>include</code> <code>str | None</code> <p>Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.</p> <code>severity</code> <code>Literal['error', 'warn'] | None</code> <p>Severity level of the check. Default: <code>error</code>.</p> <p>Example(s):     <pre><code>run_results_checks:\n    - name: check_run_results_max_gigabytes_billed\n      max_gigabytes_billed: 100\n      exclude: ^seeds\n</code></pre></p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxGigabytesBilled(BaseCheck):\n    \"\"\"Each result can have a maximum number of gigabytes billed.\n\n    !!! note\n\n        Note that this check only works for the `dbt-bigquery` adapter.\n\n    Parameters:\n        max_gigabytes_billed (float): The maximum number of gigabytes billed.\n        run_result (DbtBouncerRunResult): The DbtBouncerRunResult object to check.\n\n    Other Parameters:\n        description (str | None): Description of what the check does and why it is implemented.\n        exclude (str | None): Regex pattern to match the resource path. Resource paths that match the pattern will not be checked.\n        include (str | None): Regex pattern to match the resource path. Only resource paths that match the pattern will be checked.\n        severity (Literal[\"error\", \"warn\"] | None): Severity level of the check. Default: `error`.\n\n    Raises: # noqa:DOC502\n        KeyError: If the `dbt-bigquery` adapter is not used.\n\n    Example(s):\n        ```yaml\n        run_results_checks:\n            - name: check_run_results_max_gigabytes_billed\n              max_gigabytes_billed: 100\n              exclude: ^seeds\n        ```\n\n    \"\"\"\n\n    max_gigabytes_billed: float\n    name: Literal[\"check_run_results_max_gigabytes_billed\"]\n    run_result: \"DbtBouncerRunResultBase | None\" = Field(default=None)\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the check.\n\n        Raises:\n            DbtBouncerFailedCheckError: If gigabytes billed is greater than permitted.\n            RuntimeError: If running with adapter other than `dbt-bigquery`.\n\n        \"\"\"\n        run_result = self._require_run_result()\n        try:\n            gigabytes_billed = run_result.adapter_response[\"bytes_billed\"] / (1000**3)\n        except KeyError as e:\n            raise RuntimeError(\n                \"`bytes_billed` not found in adapter response. Are you using the `dbt-bigquery` adapter?\",\n            ) from e\n\n        if gigabytes_billed &gt; self.max_gigabytes_billed:\n            raise DbtBouncerFailedCheckError(\n                f\"`{run_result.unique_id.split('.')[-2]}` results in ({gigabytes_billed} billed bytes, this is greater than permitted ({self.max_gigabytes_billed}).\"\n            )\n</code></pre>"}]}