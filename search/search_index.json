{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-dbt-bouncer","title":"Welcome to dbt-bouncer","text":"<p><code>dbt-bouncer</code> is an open-source tool that allows you to configure and enforce conventions for your dbt project. The conventions are run against dbt's artifact files (think <code>./target/manifest.json</code>) resulting in speedy tests. Conventions can be specified in a <code>.yml</code> file, allowing maximum customisation to the conventions you wish to follow (or create \ud83d\ude00).</p> <p>Click here to view our <code>Getting Started</code> guide.</p>"},{"location":"#terminology","title":"Terminology","text":"<ul> <li>Check: A check is a rule run against a dbt artifact.</li> <li>Config file: A <code>.yml</code> file that specifies which checks to run along with any parameters.</li> <li>dbt artifacts directory: The directory that contains the dbt artifacts (<code>manifest.json</code>, etc.), generally this is <code>./target</code>.</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>dbt-bouncer</code> is free software, released under the MIT license. It originated at Xebia Data in Amsterdam, Netherlands. Source code is available on Github here.</p> <p>All contributions, in the form of bug reports, pull requests, feedback or discussion are welcome. See the contributing guide for more information.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>dbt-bouncer</code>","text":"<p><code>dbt-bouncer</code> is open source software. Whether you are a seasoned open source contributor or a first-time committer, we welcome and encourage you to contribute code, documentation, ideas, or problem statements to this project.</p>"},{"location":"CONTRIBUTING/#about-this-document","title":"About this document","text":"<p>There are many ways to contribute to the ongoing development of <code>dbt-bouncer</code>, such as by participating in discussions and issues.</p> <p>The rest of this document serves as a more granular guide for contributing code changes to <code>dbt-bouncer</code> (this repository). It is not intended as a guide for using <code>dbt-bouncer</code>, and some pieces assume a level of familiarity with Python development (virtualenvs, <code>Poetry</code>, etc). Specific code snippets in this guide assume you are using macOS or Linux and are comfortable with the command line.</p> <p>If you get stuck, we're happy to help! Just open an issue or draft PR and we'll do our best to help out.</p>"},{"location":"CONTRIBUTING/#note","title":"Note","text":"<ul> <li>Branches: All pull requests from community contributors should target the <code>main</code> branch (default).</li> </ul>"},{"location":"CONTRIBUTING/#getting-the-code","title":"Getting the code","text":""},{"location":"CONTRIBUTING/#installing-git","title":"Installing git","text":"<p>You will need <code>git</code> in order to download and modify the <code>dbt-bouncer</code> source code. On macOS, the best way to download git is to just install Xcode.</p>"},{"location":"CONTRIBUTING/#contributors","title":"Contributors","text":"<p>You can contribute to <code>dbt-bouncer</code> by forking the <code>dbt-bouncer</code> repository. For a detailed overview on forking, check out the GitHub docs on forking. In short, you will need to:</p> <ol> <li>Fork the <code>dbt-bouncer</code> repository.</li> <li>Clone your fork locally.</li> <li>Check out a new branch for your proposed changes.</li> <li>Push changes to your fork.</li> <li>Open a pull request against <code>godatadriven/dbt-bouncer</code> from your forked repository.</li> </ol>"},{"location":"CONTRIBUTING/#setting-up-an-environment","title":"Setting up an environment","text":"<p>There are some tools that will be helpful to you in developing locally. While this is the list relevant for <code>dbt-bouncer</code> development, many of these tools are used commonly across open-source python projects.</p>"},{"location":"CONTRIBUTING/#tools","title":"Tools","text":"<p>These are the tools used in <code>dbt-bouncer</code> development and testing:</p> <ul> <li><code>black</code> for code formatting.</li> <li><code>click</code> to create our CLI interface.</li> <li>GitHub Actions for automating tests and checks, once a PR is pushed to the <code>dbt-bouncer</code> repository.</li> <li><code>make</code> to run multiple setup or test steps in combination.</li> <li><code>mypy</code> for static type checking.</li> <li><code>Poetry</code> to manage our python virtual environment.</li> <li><code>pre-commit</code> to easily run those checks.</li> <li><code>Pydantic</code> to validate our configuration file.</li> <li><code>pytest</code> to define, discover, and run tests.</li> </ul> <p>A deep understanding of these tools in not required to effectively contribute to <code>dbt-bouncer</code>, but we recommend checking out the attached documentation if you're interested in learning more about each one.</p>"},{"location":"CONTRIBUTING/#virtual-environments","title":"Virtual environments","text":"<p>We strongly recommend using virtual environments when developing code in <code>dbt-bouncer</code>. We recommend creating this virtualenv in the root of the <code>dbt-bouncer</code> repository. To create a new virtualenv, run:</p> <pre><code>poetry shell\n</code></pre> <p>This will create a new Python virtual environment.</p>"},{"location":"CONTRIBUTING/#setting-environment-variables","title":"Setting environment variables","text":"<p>Set required environment variables by copying <code>.env.example</code> to <code>.env</code> and updating the values.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer-in-development","title":"Running <code>dbt-bouncer</code> in development","text":""},{"location":"CONTRIBUTING/#installation","title":"Installation","text":"<p>First make sure that you set up your <code>virtualenv</code> as described in Setting up an environment. Next, install <code>dbt-bouncer</code>, its dependencies and <code>pre-commit</code>:</p> <pre><code>poetry install\npoetry run pre-commit install\n</code></pre> <p>When installed in this way, any changes you make to your local copy of the source code will be reflected immediately in your next <code>dbt-bouncer</code> run.</p>"},{"location":"CONTRIBUTING/#running-dbt-bouncer","title":"Running <code>dbt-bouncer</code>","text":"<p>With your virtualenv activated, the <code>dbt-bouncer</code> script should point back to the source code you've cloned on your machine. You can verify this by running <code>which dbt-bouncer</code>. This command should show you a path to an executable in your virtualenv. You can run <code>dbt-bouncer</code> using the provided example configuration file via:</p> <pre><code>poetry run dbt-bouncer --config-file dbt-bouncer-example.yml\n</code></pre>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Once you're able to manually test that your code change is working as expected, it's important to run existing automated tests, as well as adding some new ones. These tests will ensure that: - Your code changes do not unexpectedly break other established functionality - Your code changes can handle all known edge cases - The functionality you're adding will keep working in the future</p>"},{"location":"CONTRIBUTING/#note_1","title":"Note","text":"<ul> <li>Generating dbt artifacts: If you change the configuration of the dbt project located in <code>dbt_project</code> then you will need to re-generate the dbt artifacts used in testing. To do so, run:</li> </ul> <pre><code>make build-artifacts\n</code></pre>"},{"location":"CONTRIBUTING/#test-commands","title":"Test commands","text":"<p>There are a few methods for running tests locally.</p>"},{"location":"CONTRIBUTING/#makefile","title":"<code>makefile</code>","text":"<p>There are multiple targets in the <code>makefile</code> to run common test suites, most notably:</p> <pre><code># Runs unit tests\nmake test-unit\n\n# Runs integration tests\nmake test-integration\n\n# Runs all tests\nmake test\n</code></pre>"},{"location":"CONTRIBUTING/#pre-commit","title":"<code>pre-commit</code>","text":"<p><code>pre-commit</code> takes care of running all code-checks for formatting and linting. Run <code>poetry run pre-commit install</code> to install <code>pre-commit</code> in your local environment. Once this is done you can use the git pre-commit hooks to ensure proper formatting and linting.</p>"},{"location":"CONTRIBUTING/#pytest","title":"<code>pytest</code>","text":"<p>Finally, you can also run a specific test or group of tests using <code>pytest</code> directly. With a virtualenv active and dev dependencies installed you can do things like:</p> <pre><code># run all unit tests in a file\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py\n\n# run a specific unit test\npoetry run pytest ./tests/unit/checks/catalog/test_columns.py::test_check_columns_are_documented_in_public_models\n</code></pre> <p>See pytest usage docs for an overview of useful command-line options.</p>"},{"location":"CONTRIBUTING/#assorted-development-tips","title":"Assorted development tips","text":"<ul> <li>Append <code># type: ignore</code> to the end of a line if you need to disable <code>mypy</code> on that line.</li> </ul>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>Code can be merged into the current development branch <code>main</code> by opening a pull request. If the proposal looks like it's on the right track, then a <code>dbt-bouncer</code> maintainer will review the PR. They may suggest code revision for style or clarity, or request that you add unit or integration test(s). These are good things! We believe that, with a little bit of help, anyone can contribute high-quality code. Once merged, your contribution will be available for the next release of <code>dbt-bouncer</code>.</p> <p>Automated tests run via GitHub Actions. If you're a first-time contributor, all tests will require a maintainer to approve.</p> <p>Once all tests are passing and your PR has been approved, a <code>dbt-bouncer</code> maintainer will merge your changes into the active development branch. And that's it! Happy developing :tada:</p>"},{"location":"checks_catalog/","title":"Catalog Checks","text":""},{"location":"checks_catalog/#catalog.check_catalog_sources","title":"<code>check_catalog_sources</code>","text":""},{"location":"checks_catalog/#catalog.check_catalog_sources.CheckSourceColumnsAreAllDocumented","title":"<code>CheckSourceColumnsAreAllDocumented</code>","text":"Source code in <code>src/dbt_bouncer/checks/catalog/check_catalog_sources.py</code> <pre><code>class CheckSourceColumnsAreAllDocumented(BaseCheck):\n    name: Literal[\"check_source_columns_are_all_documented\"]\n</code></pre>"},{"location":"checks_catalog/#catalog.check_catalog_sources.CheckSourceColumnsAreAllDocumented.name","title":"<code>name: Literal['check_source_columns_are_all_documented']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_catalog_sources.check_source_columns_are_all_documented","title":"<code>check_source_columns_are_all_documented</code>","text":"<p>All columns in a source should be included in the source's properties file, i.e. <code>.yml</code> file.</p> Source code in <code>src/dbt_bouncer/checks/catalog/check_catalog_sources.py</code> <pre><code>@pytest.mark.iterate_over_catalog_sources\n@bouncer_check\ndef check_source_columns_are_all_documented(\n    sources: List[DbtBouncerSource],\n    request: TopRequest,\n    catalog_source: Union[DbtBouncerCatalogNode, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    All columns in a source should be included in the source's properties file, i.e. `.yml` file.\n    \"\"\"\n\n    source = [s for s in sources if s.unique_id == catalog_source.unique_id][0]\n    undocumented_columns = [\n        v.name for _, v in catalog_source.columns.items() if v.name not in source.columns.keys()\n    ]\n    assert (\n        not undocumented_columns\n    ), f\"`{catalog_source.unique_id}` has columns that are not included in the sources properties file: {undocumented_columns}\"\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns","title":"<code>check_columns</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.CheckColumnNameCompliesToColumnType","title":"<code>CheckColumnNameCompliesToColumnType</code>","text":"Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnNameCompliesToColumnType(BaseCheck):\n    column_name_pattern: str\n    name: Literal[\"check_column_name_complies_to_column_type\"]\n    types: List[str]\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnNameCompliesToColumnType.column_name_pattern","title":"<code>column_name_pattern: str</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.CheckColumnNameCompliesToColumnType.name","title":"<code>name: Literal['check_column_name_complies_to_column_type']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.CheckColumnNameCompliesToColumnType.types","title":"<code>types: List[str]</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.check_column_name_complies_to_column_type","title":"<code>check_column_name_complies_to_column_type</code>","text":"<p>Columns with specified data types must comply to the specified regexp naming pattern.</p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_column_name_complies_to_column_type(\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    column_name_pattern: Union[None, str] = None,\n    types: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns with specified data types must comply to the specified regexp naming pattern.\n    \"\"\"\n\n    non_complying_columns = [\n        v.name\n        for _, v in catalog_node.columns.items()\n        if v.type in types and re.compile(column_name_pattern.strip()).match(v.name) is None  # type: ignore[operator]\n    ]\n\n    assert (\n        not non_complying_columns\n    ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that don't comply with the specified regexp pattern (`{column_name_pattern}`): {non_complying_columns}\"\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnsAreAllDocumented","title":"<code>CheckColumnsAreAllDocumented</code>","text":"Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreAllDocumented(BaseCheck):\n    name: Literal[\"check_columns_are_all_documented\"]\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnsAreAllDocumented.name","title":"<code>name: Literal['check_columns_are_all_documented']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.check_columns_are_all_documented","title":"<code>check_columns_are_all_documented</code>","text":"<p>All columns in a model should be included in the model's properties file, i.e. <code>.yml</code> file.</p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_columns_are_all_documented(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    All columns in a model should be included in the model's properties file, i.e. `.yml` file.\n    \"\"\"\n\n    if catalog_node.unique_id.split(\".\")[0] == \"model\":\n        model = [m for m in models if m.unique_id == catalog_node.unique_id][0]\n        undocumented_columns = [\n            v.name for _, v in catalog_node.columns.items() if v.name not in model.columns.keys()\n        ]\n        assert (\n            not undocumented_columns\n        ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that are not included in the models properties file: {undocumented_columns}\"\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnsAreDocumentedInPublicModels","title":"<code>CheckColumnsAreDocumentedInPublicModels</code>","text":"Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnsAreDocumentedInPublicModels(BaseCheck):\n    name: Literal[\"check_columns_are_documented_in_public_models\"]\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnsAreDocumentedInPublicModels.name","title":"<code>name: Literal['check_columns_are_documented_in_public_models']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.check_columns_are_documented_in_public_models","title":"<code>check_columns_are_documented_in_public_models</code>","text":"<p>Columns should have a populated description in public models.</p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_columns_are_documented_in_public_models(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    catalog_node: Union[CatalogTable, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns should have a populated description in public models.\n    \"\"\"\n\n    if catalog_node.unique_id.split(\".\")[0] == \"model\":\n        model = [m for m in models if m.unique_id == catalog_node.unique_id][0]\n        non_complying_columns = []\n        for k, v in catalog_node.columns.items():\n            if model.access.value == \"public\":\n                column_config = model.columns.get(v.name)\n                if column_config is None or len(column_config.description.strip()) &lt; 4:\n                    non_complying_columns.append(v.name)\n\n        assert (\n            not non_complying_columns\n        ), f\"`{catalog_node.unique_id.split('.')[-1]}` is a public model but has columns that don't have a populated description: {non_complying_columns}\"\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnHasSpecifiedTest","title":"<code>CheckColumnHasSpecifiedTest</code>","text":"Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>class CheckColumnHasSpecifiedTest(BaseCheck):\n    column_name_pattern: str\n    name: Literal[\"check_column_has_specified_test\"]\n    test_name: str\n</code></pre>"},{"location":"checks_catalog/#catalog.check_columns.CheckColumnHasSpecifiedTest.column_name_pattern","title":"<code>column_name_pattern: str</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.CheckColumnHasSpecifiedTest.name","title":"<code>name: Literal['check_column_has_specified_test']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.CheckColumnHasSpecifiedTest.test_name","title":"<code>test_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"checks_catalog/#catalog.check_columns.check_column_has_specified_test","title":"<code>check_column_has_specified_test</code>","text":"<p>Columns that match the specified regexp pattern must have a specified test.</p> Source code in <code>src/dbt_bouncer/checks/catalog/check_columns.py</code> <pre><code>@pytest.mark.iterate_over_catalog_nodes\n@bouncer_check\ndef check_column_has_specified_test(\n    request: TopRequest,\n    tests: List[DbtBouncerTest],\n    catalog_node: Union[CatalogTable, None] = None,\n    column_name_pattern: Union[None, str] = None,\n    test_name: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Columns that match the specified regexp pattern must have a specified test.\n    \"\"\"\n\n    columns_to_check = [\n        v.name\n        for _, v in catalog_node.columns.items()\n        if re.compile(column_name_pattern.strip()).match(v.name) is not None\n    ]\n    relevant_tests = [\n        t\n        for t in tests\n        if t.test_metadata.name == test_name and t.attached_node == catalog_node.unique_id\n    ]\n    non_complying_columns = [\n        c\n        for c in columns_to_check\n        if f\"{catalog_node.unique_id}.{c}\"\n        not in [f\"{t.attached_node}.{t.column_name}\" for t in relevant_tests]\n    ]\n\n    assert (\n        not non_complying_columns\n    ), f\"`{catalog_node.unique_id.split('.')[-1]}` has columns that should have a `{test_name}` test: {non_complying_columns}\"\n</code></pre>"},{"location":"checks_manifest/","title":"Manifest Checks","text":""},{"location":"checks_manifest/#manifest.check_macros","title":"<code>check_macros</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.CheckMacroArgumentsDescriptionPopulated","title":"<code>CheckMacroArgumentsDescriptionPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroArgumentsDescriptionPopulated(BaseCheck):\n    name: Literal[\"check_macro_arguments_description_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroArgumentsDescriptionPopulated.name","title":"<code>name: Literal['check_macro_arguments_description_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.check_macro_arguments_description_populated","title":"<code>check_macro_arguments_description_populated</code>","text":"<p>Macro arguments must have a populated description.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_arguments_description_populated(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macro arguments must have a populated description.\n    \"\"\"\n\n    for arg in macro.arguments:\n        assert (\n            len(arg.description.strip()) &gt; 4\n        ), f\"Argument `{arg.name}` in {macro.unique_id.split('.')[-1]} does not have a populated description.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroCodeDoesNotContainRegexpPattern","title":"<code>CheckMacroCodeDoesNotContainRegexpPattern</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroCodeDoesNotContainRegexpPattern(BaseCheck):\n    name: Literal[\"check_macro_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str = Field(\n        description=\"The regexp pattern that should not be matched by the macro code.\"\n    )\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroCodeDoesNotContainRegexpPattern.name","title":"<code>name: Literal['check_macro_code_does_not_contain_regexp_pattern']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.CheckMacroCodeDoesNotContainRegexpPattern.regexp_pattern","title":"<code>regexp_pattern: str = Field(description='The regexp pattern that should not be matched by the macro code.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.check_macro_code_does_not_contain_regexp_pattern","title":"<code>check_macro_code_does_not_contain_regexp_pattern</code>","text":"<p>The raw code for a macro must not match the specified regexp pattern.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_code_does_not_contain_regexp_pattern(\n    request: TopRequest,\n    macro: Union[Macros, None] = None,\n    regexp_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The raw code for a macro must not match the specified regexp pattern.\n    \"\"\"\n\n    assert (\n        re.compile(regexp_pattern.strip(), flags=re.DOTALL).match(macro.macro_sql) is None\n    ), f\"`{macro.unique_id.split('.')[-1]}` contains a banned string: `{regexp_pattern.strip()}`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroDescriptionPopulated","title":"<code>CheckMacroDescriptionPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroDescriptionPopulated(BaseCheck):\n    name: Literal[\"check_macro_description_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroDescriptionPopulated.name","title":"<code>name: Literal['check_macro_description_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.check_macro_description_populated","title":"<code>check_macro_description_populated</code>","text":"<p>Macros must have a populated description.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_description_populated(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macros must have a populated description.\n    \"\"\"\n\n    assert (\n        len(macro.description.strip()) &gt; 4\n    ), f\"`{macro.unique_id.split('.')[-1]}` does not have a populated description.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroNameMatchesFileName","title":"<code>CheckMacroNameMatchesFileName</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroNameMatchesFileName(BaseCheck):\n    name: Literal[\"check_macro_name_matches_file_name\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroNameMatchesFileName.name","title":"<code>name: Literal['check_macro_name_matches_file_name']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.check_macro_name_matches_file_name","title":"<code>check_macro_name_matches_file_name</code>","text":"<p>Macros names must be the same as the file they are contained in.</p> <p>Generic tests are also macros, however to document these tests the \"name\" value must be precededed with \"test_\".</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_name_matches_file_name(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macros names must be the same as the file they are contained in.\n\n    Generic tests are also macros, however to document these tests the \"name\" value must be precededed with \"test_\".\n    \"\"\"\n\n    if macro.name.startswith(\"test_\"):\n        assert (\n            macro.name[5:] == macro.path.split(\"/\")[-1].split(\".\")[0]\n        ), f\"{macro.unique_id} is not in a file named `{macro.name[5:]}.sql`.\"\n    else:\n        assert (\n            macro.name == macro.path.split(\"/\")[-1].split(\".\")[0]\n        ), f\"`{macro.unique_id.split('.')[-1]}` is not in a file of the same name.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroPropertyFileLocation","title":"<code>CheckMacroPropertyFileLocation</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>class CheckMacroPropertyFileLocation(BaseCheck):\n    name: Literal[\"check_macro_property_file_location\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_macros.CheckMacroPropertyFileLocation.name","title":"<code>name: Literal['check_macro_property_file_location']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_macros.check_macro_property_file_location","title":"<code>check_macro_property_file_location</code>","text":"<p>Macro properties files must follow the guidance provided by dbt here.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_macros.py</code> <pre><code>@pytest.mark.iterate_over_macros\n@bouncer_check\ndef check_macro_property_file_location(\n    request: TopRequest, macro: Union[Macros, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Macro properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/5-the-rest-of-the-project#how-we-use-the-other-folders).\n    \"\"\"\n\n    expected_substr = \"_\".join(macro.path[6:].split(\"/\")[:-1])\n    properties_yml_name = macro.patch_path.split(\"/\")[-1]\n\n    if macro.path.startswith(\"tests/\"):  # Do not check generic tests (which are also macros)\n        pass\n    elif expected_substr == \"\":  # i.e. macro in ./macros\n        assert (\n            properties_yml_name == \"_macros.yml\"\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) should be `_macros.yml`.\"\n    else:\n        assert properties_yml_name.startswith(\n            \"_\"\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) does not start with an underscore.\"\n        assert (\n            expected_substr in properties_yml_name\n        ), f\"The properties file for `{macro.name}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n        assert properties_yml_name.endswith(\n            \"__macros.yml\"\n        ), f\"The properties file for `{macro.name.split('.')[-1]}` (`{properties_yml_name}`) does not end with `__macros.yml`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_metadata","title":"<code>check_metadata</code>","text":""},{"location":"checks_manifest/#manifest.check_metadata.CheckProjectName","title":"<code>CheckProjectName</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_metadata.py</code> <pre><code>class CheckProjectName(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    index: Optional[int] = Field(\n        default=None, description=\"Index to uniquely identify the check, calculated at runtime.\"\n    )\n    name: Literal[\"check_project_name\"]\n    project_name_pattern: str = Field(description=\"Regexp the project name must match.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_metadata.CheckProjectName.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_metadata.CheckProjectName.index","title":"<code>index: Optional[int] = Field(default=None, description='Index to uniquely identify the check, calculated at runtime.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_metadata.CheckProjectName.name","title":"<code>name: Literal['check_project_name']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_metadata.CheckProjectName.project_name_pattern","title":"<code>project_name_pattern: str = Field(description='Regexp the project name must match.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_metadata.check_project_name","title":"<code>check_project_name</code>","text":"<p>Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  <code>company_&lt;DOMAIN&gt;</code>.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_metadata.py</code> <pre><code>@bouncer_check\ndef check_project_name(\n    manifest_obj: DbtBouncerManifest,\n    request: TopRequest,\n    project_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Enforce that the name of the dbt project matches a supplied regex. Generally used to enforce that project names conform to something like  `company_&lt;DOMAIN&gt;`.\n    \"\"\"\n\n    assert (\n        re.compile(project_name_pattern.strip()).match(manifest_obj.manifest.metadata.project_name)\n        is not None\n    ), f\"Project name (`{manifest_obj.manifest.metadata.project_name}`) does not conform to the supplied regex `({project_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models","title":"<code>check_models</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelAccess","title":"<code>CheckModelAccess</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelAccess(BaseCheck):\n    access: Literal[\"private\", \"protected\", \"public\"]\n    name: Literal[\"check_model_access\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelAccess.access","title":"<code>access: Literal['private', 'protected', 'public']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelAccess.name","title":"<code>name: Literal['check_model_access']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_access","title":"<code>check_model_access</code>","text":"<p>Models must have the specified access attribute. Requires dbt 1.7+.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_access(\n    request: TopRequest,\n    access: Union[None, str] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have the specified access attribute. Requires dbt 1.7+.\n    \"\"\"\n\n    assert (\n        model.access.value == access\n    ), f\"`{model.unique_id.split('.')[-1]}` has `{model.access.value}` access, it should have access `{access}`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelContractsEnforcedForPublicModel","title":"<code>CheckModelContractsEnforcedForPublicModel</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelContractsEnforcedForPublicModel(BaseCheck):\n    name: Literal[\"check_model_contract_enforced_for_public_model\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelContractsEnforcedForPublicModel.name","title":"<code>name: Literal['check_model_contract_enforced_for_public_model']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_contract_enforced_for_public_model","title":"<code>check_model_contract_enforced_for_public_model</code>","text":"<p>Public models must have contracts enforced.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_contract_enforced_for_public_model(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Public models must have contracts enforced.\n    \"\"\"\n\n    if model.access.value == \"public\":\n        assert (\n            model.contract.enforced is True\n        ), f\"`{model.unique_id.split('.')[-1]}` is a public model but does not have contracts enforced.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDescriptionPopulated","title":"<code>CheckModelDescriptionPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDescriptionPopulated(BaseCheck):\n    name: Literal[\"check_model_description_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDescriptionPopulated.name","title":"<code>name: Literal['check_model_description_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_description_populated","title":"<code>check_model_description_populated</code>","text":"<p>Models must have a populated description.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_description_populated(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models must have a populated description.\n    \"\"\"\n\n    assert (\n        len(model.description.strip()) &gt; 4\n    ), f\"`{model.unique_id.split('.')[-1]}` does not have a populated description.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelsDocumentationCoverage","title":"<code>CheckModelsDocumentationCoverage</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsDocumentationCoverage(BaseCheck):\n    name: Literal[\"check_model_documentation_coverage\"]\n    min_model_documentation_coverage_pct: int = Field(\n        default=100,\n        description=\"The minimum percentage of models that must have a populated description. Default: 100\",\n        ge=0,\n        le=100,\n    )\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelsDocumentationCoverage.name","title":"<code>name: Literal['check_model_documentation_coverage']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelsDocumentationCoverage.min_model_documentation_coverage_pct","title":"<code>min_model_documentation_coverage_pct: int = Field(default=100, description='The minimum percentage of models that must have a populated description. Default: 100', ge=0, le=100)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_documentation_coverage","title":"<code>check_model_documentation_coverage</code>","text":"<p>Set the minimum percentage of models that have a populated description.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@bouncer_check\ndef check_model_documentation_coverage(\n    request: TopRequest,\n    models: List[DbtBouncerModel],\n    min_model_documentation_coverage_pct: Union[float, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Set the minimum percentage of models that have a populated description.\n    \"\"\"\n\n    num_models = len(models)\n    models_with_description = []\n    for model in models:\n        if len(model.description.strip()) &gt; 4:\n            models_with_description.append(model.unique_id)\n\n    num_models_with_descriptions = len(models_with_description)\n    model_description_coverage_pct = (num_models_with_descriptions / num_models) * 100\n\n    assert (\n        model_description_coverage_pct &gt;= min_model_documentation_coverage_pct  # type: ignore[operator]\n    ), f\"Only {model_description_coverage_pct}% of models have a populated description, this is less than the permitted minimum of {min_model_documentation_coverage_pct}%.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDocumentedInSameDirectory","title":"<code>CheckModelDocumentedInSameDirectory</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDocumentedInSameDirectory(BaseCheck):\n    name: Literal[\"check_model_documented_in_same_directory\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDocumentedInSameDirectory.name","title":"<code>name: Literal['check_model_documented_in_same_directory']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_documented_in_same_directory","title":"<code>check_model_documented_in_same_directory</code>","text":"<p>Models must be documented in the same directory where they are defined (i.e. <code>.yml</code> and <code>.sql</code> files are in the same directory).</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_documented_in_same_directory(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models must be documented in the same directory where they are defined (i.e. `.yml` and `.sql` files are in the same directory).\n    \"\"\"\n\n    model_doc_dir = model.patch_path[model.patch_path.find(\"models\") :].split(\"/\")[1:-1]\n    model_sql_dir = model.path.split(\"/\")[:-1]\n\n    assert (\n        model_doc_dir == model_sql_dir\n    ), f\"`{model.unique_id.split('.')[-1]}` is documented in a different directory to the `.sql` file: `{'/'.join(model_doc_dir)}` vs `{'/'.join(model_sql_dir)}`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelCodeDoesNotContainRegexpPattern","title":"<code>CheckModelCodeDoesNotContainRegexpPattern</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelCodeDoesNotContainRegexpPattern(BaseCheck):\n    name: Literal[\"check_model_code_does_not_contain_regexp_pattern\"]\n    regexp_pattern: str = Field(\n        description=\"The regexp pattern that should not be matched by the model code.\"\n    )\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelCodeDoesNotContainRegexpPattern.name","title":"<code>name: Literal['check_model_code_does_not_contain_regexp_pattern']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelCodeDoesNotContainRegexpPattern.regexp_pattern","title":"<code>regexp_pattern: str = Field(description='The regexp pattern that should not be matched by the model code.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_code_does_not_contain_regexp_pattern","title":"<code>check_model_code_does_not_contain_regexp_pattern</code>","text":"<p>The raw code for a model must not match the specified regexp pattern.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_code_does_not_contain_regexp_pattern(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    regexp_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The raw code for a model must not match the specified regexp pattern.\n    \"\"\"\n\n    assert (\n        re.compile(regexp_pattern.strip(), flags=re.DOTALL).match(model.raw_code) is None\n    ), f\"`{model.unique_id.split('.')[-1]}` contains a banned string: `{regexp_pattern.strip()}`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDependsOnMultipleSources","title":"<code>CheckModelDependsOnMultipleSources</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDependsOnMultipleSources(BaseCheck):\n    name: Literal[\"check_model_depends_on_multiple_sources\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDependsOnMultipleSources.name","title":"<code>name: Literal['check_model_depends_on_multiple_sources']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_depends_on_multiple_sources","title":"<code>check_model_depends_on_multiple_sources</code>","text":"<p>Models cannot reference more than one source.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_depends_on_multiple_sources(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Models cannot reference more than one source.\n    \"\"\"\n\n    num_reffed_sources = sum(x.split(\".\")[0] == \"source\" for x in model.depends_on.nodes)\n    assert (\n        num_reffed_sources &lt;= 1\n    ), f\"`{model.unique_id.split('.')[-1]}` references more than one source.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories","title":"<code>CheckModelDirectories</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelDirectories(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    include: str = Field(\n        description=\"Regex pattern to match the model path. Only model paths that match the pattern will be checked.\"\n    )\n    index: Optional[int] = Field(\n        default=None, description=\"Index to uniquely identify the check, calculated at runtime.\"\n    )\n    name: Literal[\"check_model_directories\"]\n    permitted_sub_directories: List[str] = Field(description=\"List of permitted sub-directories.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories.include","title":"<code>include: str = Field(description='Regex pattern to match the model path. Only model paths that match the pattern will be checked.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories.index","title":"<code>index: Optional[int] = Field(default=None, description='Index to uniquely identify the check, calculated at runtime.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories.name","title":"<code>name: Literal['check_model_directories']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelDirectories.permitted_sub_directories","title":"<code>permitted_sub_directories: List[str] = Field(description='List of permitted sub-directories.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_directories","title":"<code>check_model_directories</code>","text":"<p>Only specified sub-directories are permitted.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_directories(\n    request: TopRequest,\n    include: Union[None, str] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    permitted_sub_directories: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Only specified sub-directories are permitted.\n    \"\"\"\n\n    # Special case for `models` directory\n    if include == \"\":\n        assert (\n            model.path.split(\"/\")[0] in permitted_sub_directories  # type: ignore[operator]\n        ), f\"{model.unique_id} is located in `{model.path.split('/')[0]}`, this is not a valid sub- directory.\"\n    else:\n        matched_path = re.compile(include.strip()).match(model.path)\n        path_after_match = model.path[matched_path.end() + 1 :]  # type: ignore[union-attr]\n\n        assert (\n            path_after_match.split(\"/\")[0] in permitted_sub_directories  # type: ignore[operator]\n        ), f\"`{model.unique_id.split('.')[-1]}` is located in `{model.path.split('/')[0]}`, this is not a valid sub-directory.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasContractsEnforced","title":"<code>CheckModelHasContractsEnforced</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasContractsEnforced(BaseCheck):\n    name: Literal[\"check_model_has_contracts_enforced\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasContractsEnforced.name","title":"<code>name: Literal['check_model_has_contracts_enforced']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_has_contracts_enforced","title":"<code>check_model_has_contracts_enforced</code>","text":"<p>Model must have contracts enforced.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_contracts_enforced(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Model must have contracts enforced.\n    \"\"\"\n\n    assert (\n        model.contract.enforced is True\n    ), f\"`{model.unique_id.split('.')[-1]}` does not have contracts enforced.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasMetaKeys","title":"<code>CheckModelHasMetaKeys</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasMetaKeys(BaseCheck):\n    keys: Optional[Union[Dict[str, Any], List[Any]]]\n    name: Literal[\"check_model_has_meta_keys\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasMetaKeys.keys","title":"<code>keys: Optional[Union[Dict[str, Any], List[Any]]]</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelHasMetaKeys.name","title":"<code>name: Literal['check_model_has_meta_keys']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_has_meta_keys","title":"<code>check_model_has_meta_keys</code>","text":"<p>The <code>meta</code> config for models must have the specified keys.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_meta_keys(\n    request: TopRequest,\n    keys: Union[Dict[str, Dict[str, str]], None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The `meta` config for models must have the specified keys.\n    \"\"\"\n\n    missing_keys = find_missing_meta_keys(\n        meta_config=model.meta,\n        required_keys=keys,\n    )\n    assert (\n        missing_keys == []\n    ), f\"`{model.unique_id.split('.')[-1]}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasNoUpstreamDependencies","title":"<code>CheckModelHasNoUpstreamDependencies</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasNoUpstreamDependencies(BaseCheck):\n    name: Literal[\"check_model_has_no_upstream_dependencies\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasNoUpstreamDependencies.name","title":"<code>name: Literal['check_model_has_no_upstream_dependencies']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_has_no_upstream_dependencies","title":"<code>check_model_has_no_upstream_dependencies</code>","text":"<p>Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_no_upstream_dependencies(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Identify if models have no upstream dependencies as this likely indicates hard-coded tables references.\n    \"\"\"\n\n    assert (\n        len(model.depends_on.nodes) &gt; 0\n    ), f\"`{model.unique_id.split('.')[-1]}` has no upstream dependencies, this likely indicates hard-coded tables references.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasTags","title":"<code>CheckModelHasTags</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasTags(BaseCheck):\n    name: Literal[\"check_model_has_tags\"]\n    tags: List[str] = Field(default=[], description=\"List of tags to check for.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasTags.name","title":"<code>name: Literal['check_model_has_tags']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelHasTags.tags","title":"<code>tags: List[str] = Field(default=[], description='List of tags to check for.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_has_tags","title":"<code>check_model_has_tags</code>","text":"<p>Models must have the specified tags.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_tags(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    tags: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have the specified tags.\n    \"\"\"\n\n    missing_tags = [tag for tag in tags if tag not in model.tags]\n    assert (\n        not missing_tags\n    ), f\"`{model.unique_id.split('.')[-1]}` is missing required tags: {missing_tags}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasUniqueTest","title":"<code>CheckModelHasUniqueTest</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelHasUniqueTest(BaseCheck):\n    accepted_uniqueness_tests: Optional[List[str]] = Field(\n        default=[\n            \"expect_compound_columns_to_be_unique\",\n            \"dbt_utils.unique_combination_of_columns\",\n            \"unique\",\n        ],\n        description=\"List of tests that are accepted as uniqueness tests. If not provided, defaults to `expect_compound_columns_to_be_unique`, `dbt_utils.unique_combination_of_columns` and `unique`.\",\n    )\n    name: Literal[\"check_model_has_unique_test\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelHasUniqueTest.accepted_uniqueness_tests","title":"<code>accepted_uniqueness_tests: Optional[List[str]] = Field(default=['expect_compound_columns_to_be_unique', 'dbt_utils.unique_combination_of_columns', 'unique'], description='List of tests that are accepted as uniqueness tests. If not provided, defaults to `expect_compound_columns_to_be_unique`, `dbt_utils.unique_combination_of_columns` and `unique`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelHasUniqueTest.name","title":"<code>name: Literal['check_model_has_unique_test']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_has_unique_test","title":"<code>check_model_has_unique_test</code>","text":"<p>Models must have a test for uniqueness of a column.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_has_unique_test(\n    request: TopRequest,\n    tests: List[DbtBouncerModel],\n    accepted_uniqueness_tests: Union[List[str], None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have a test for uniqueness of a column.\n    \"\"\"\n\n    num_unique_tests = sum(\n        test.attached_node == model.unique_id\n        and test.test_metadata.name in accepted_uniqueness_tests  # type: ignore[operator]\n        for test in tests\n    )\n    assert (\n        num_unique_tests &gt;= 1\n    ), f\"`{model.unique_id.split('.')[-1]}` does not have a test for uniqueness of a column.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxChainedViews","title":"<code>CheckModelMaxChainedViews</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxChainedViews(BaseCheck):\n    materializations_to_include: List[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n        description=\"List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.\",\n    )\n    max_chained_views: int = Field(\n        default=3,\n        description=\"The maximum number of upstream dependents that are not tables. Default: 3\",\n    )\n    name: Literal[\"check_model_max_chained_views\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxChainedViews.materializations_to_include","title":"<code>materializations_to_include: List[str] = Field(default=['ephemeral', 'view'], description='List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxChainedViews.max_chained_views","title":"<code>max_chained_views: int = Field(default=3, description='The maximum number of upstream dependents that are not tables. Default: 3')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxChainedViews.name","title":"<code>name: Literal['check_model_max_chained_views']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_max_chained_views","title":"<code>check_model_max_chained_views</code>","text":"<p>Models cannot have more than the specified number of upstream dependents that are not tables (default: 3).</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_chained_views(\n    manifest_obj: DbtBouncerManifest,\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    materializations_to_include: Union[List[str], None] = None,\n    max_chained_views: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models cannot have more than the specified number of upstream dependents that are not tables (default: 3).\n    \"\"\"\n\n    def return_upstream_view_models(\n        materializations,\n        max_chained_views,\n        models,\n        model_unique_ids_to_check,\n        package_name,\n        depth=0,\n    ):\n        \"\"\"\n        Recursive function to return model unique_id's of upstream models that are views. Depth of recursion can be specified. If no models meet the criteria then an empty list is returned.\n        \"\"\"\n\n        if depth == max_chained_views or model_unique_ids_to_check == []:\n            return model_unique_ids_to_check\n\n        relevant_upstream_models = []\n        for model in model_unique_ids_to_check:\n            upstream_nodes = list(\n                [m2 for m2 in models if m2.unique_id == model][0].depends_on.nodes\n            )\n            if upstream_nodes != []:\n                upstream_models = [\n                    m\n                    for m in upstream_nodes\n                    if m.split(\".\")[0] == \"model\" and m.split(\".\")[1] == package_name\n                ]\n                for i in upstream_models:\n                    if [m for m in models if m.unique_id == i][\n                        0\n                    ].config.materialized in materializations:\n                        relevant_upstream_models.append(i)\n\n        depth += 1\n        return return_upstream_view_models(\n            materializations=materializations,\n            max_chained_views=max_chained_views,\n            models=models,\n            model_unique_ids_to_check=relevant_upstream_models,\n            package_name=package_name,\n            depth=depth,\n        )\n\n    assert (\n        len(\n            return_upstream_view_models(\n                materializations=materializations_to_include,\n                max_chained_views=max_chained_views,\n                models=models,\n                model_unique_ids_to_check=[model.unique_id],\n                package_name=manifest_obj.manifest.metadata.project_name,\n            )\n        )\n        == 0\n    ), f\"`{model.unique_id.split('.')[-1]}` has more than {max_chained_views} upstream dependents that are not tables.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxFanout","title":"<code>CheckModelMaxFanout</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxFanout(BaseCheck):\n    max_downstream_models: int = Field(\n        default=3, description=\"The maximum number of permitted downstream models.\"\n    )\n    name: Literal[\"check_model_max_fanout\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxFanout.max_downstream_models","title":"<code>max_downstream_models: int = Field(default=3, description='The maximum number of permitted downstream models.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxFanout.name","title":"<code>name: Literal['check_model_max_fanout']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_max_fanout","title":"<code>check_model_max_fanout</code>","text":"<p>Models cannot have more than the specified number of downstream models (default: 3).</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_fanout(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    max_downstream_models: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models cannot have more than the specified number of downstream models (default: 3).\n    \"\"\"\n\n    num_downstream_models = sum(model.unique_id in m.depends_on.nodes for m in models)\n\n    assert (\n        num_downstream_models &lt;= max_downstream_models  # type: ignore[operator]\n    ), f\"`{model.unique_id.split('.')[-1]}` has {num_downstream_models} downstream models, which is more than the permitted maximum of {max_downstream_models}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxUpstreamDependencies","title":"<code>CheckModelMaxUpstreamDependencies</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelMaxUpstreamDependencies(BaseCheck):\n    max_upstream_macros: int = Field(\n        default=5, description=\"The maximum number of permitted upstream macros.\"\n    )\n    max_upstream_models: int = Field(\n        default=5, description=\"The maximum number of permitted upstream models.\"\n    )\n    max_upstream_sources: int = Field(\n        default=1, description=\"The maximum number of permitted upstream sources.\"\n    )\n    name: Literal[\"check_model_max_upstream_dependencies\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxUpstreamDependencies.max_upstream_macros","title":"<code>max_upstream_macros: int = Field(default=5, description='The maximum number of permitted upstream macros.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxUpstreamDependencies.max_upstream_models","title":"<code>max_upstream_models: int = Field(default=5, description='The maximum number of permitted upstream models.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxUpstreamDependencies.max_upstream_sources","title":"<code>max_upstream_sources: int = Field(default=1, description='The maximum number of permitted upstream sources.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelMaxUpstreamDependencies.name","title":"<code>name: Literal['check_model_max_upstream_dependencies']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_max_upstream_dependencies","title":"<code>check_model_max_upstream_dependencies</code>","text":"<p>Limit the number of upstream dependencies a model has. Default values are 5 for models, 5 for macros, and 1 for sources.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_max_upstream_dependencies(\n    request: TopRequest,\n    max_upstream_macros: Union[int, None] = None,\n    max_upstream_models: Union[int, None] = None,\n    max_upstream_sources: Union[int, None] = None,\n    model: Union[DbtBouncerModel, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Limit the number of upstream dependencies a model has. Default values are 5 for models, 5 for macros, and 1 for sources.\n    \"\"\"\n\n    num_upstream_macros = len([m for m in model.depends_on.macros])\n    num_upstream_models = len([m for m in model.depends_on.nodes if m.split(\".\")[0] == \"model\"])\n    num_upstream_sources = len([m for m in model.depends_on.nodes if m.split(\".\")[0] == \"source\"])\n\n    assert (\n        num_upstream_macros &lt;= max_upstream_macros  # type: ignore[operator]\n    ), f\"`{model.unique_id.split('.')[-1]}` has {num_upstream_macros} upstream macros, which is more than the permitted maximum of {max_upstream_macros}.\"\n    assert (\n        num_upstream_models &lt;= max_upstream_models  # type: ignore[operator]\n    ), f\"`{model.unique_id.split('.')[-1]}` has {num_upstream_models} upstream models, which is more than the permitted maximum of {max_upstream_models}.\"\n    assert (\n        num_upstream_sources &lt;= max_upstream_sources  # type: ignore[operator]\n    ), f\"`{model.unique_id.split('.')[-1]}` has {num_upstream_sources} upstream sources, which is more than the permitted maximum of {max_upstream_sources}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelNames","title":"<code>CheckModelNames</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelNames(BaseCheck):\n    model_config = ConfigDict(extra=\"forbid\", protected_namespaces=())\n\n    name: Literal[\"check_model_names\"]\n    model_name_pattern: str = Field(description=\"Regexp the model name must match.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelNames.model_config","title":"<code>model_config = ConfigDict(extra='forbid', protected_namespaces=())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelNames.name","title":"<code>name: Literal['check_model_names']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelNames.model_name_pattern","title":"<code>model_name_pattern: str = Field(description='Regexp the model name must match.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_names","title":"<code>check_model_names</code>","text":"<p>Models must have a name that matches the supplied regex.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_names(\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    model_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Models must have a name that matches the supplied regex.\n    \"\"\"\n\n    assert (\n        re.compile(model_name_pattern.strip()).match(model.name) is not None\n    ), f\"`{model.unique_id.split('.')[-1]}` does not match the supplied regex `{model_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelPropertyFileLocation","title":"<code>CheckModelPropertyFileLocation</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelPropertyFileLocation(BaseCheck):\n    name: Literal[\"check_model_property_file_location\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelPropertyFileLocation.name","title":"<code>name: Literal['check_model_property_file_location']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_property_file_location","title":"<code>check_model_property_file_location</code>","text":"<p>Model properties files must follow the guidance provided by dbt here.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_model_property_file_location(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Model properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n    \"\"\"\n\n    expected_substr = (\n        \"_\".join(model.path.split(\"/\")[:-1])\n        .replace(\"staging\", \"stg\")\n        .replace(\"intermediate\", \"int\")\n        .replace(\"marts\", \"\")\n    )\n    properties_yml_name = model.patch_path.split(\"/\")[-1]\n\n    assert properties_yml_name.startswith(\n        \"_\"\n    ), f\"The properties file for `{model.unique_id.split('.')[-1]}` (`{properties_yml_name}`) does not start with an underscore.\"\n    assert (\n        expected_substr in properties_yml_name\n    ), f\"The properties file for `{model.unique_id.split('.')[-1]}` (`{properties_yml_name}`) does not contain the expected substring (`{expected_substr}`).\"\n    assert properties_yml_name.endswith(\n        \"__models.yml\"\n    ), f\"The properties file for `{model.unique_id.split('.')[-1]}` (`{properties_yml_name}`) does not end with `__models.yml`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelsTestCoverage","title":"<code>CheckModelsTestCoverage</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>class CheckModelsTestCoverage(BaseCheck):\n    name: Literal[\"check_model_test_coverage\"]\n    min_model_test_coverage_pct: int = Field(\n        default=100,\n        description=\"The minimum percentage of models that must have at least one test. Default: 100\",\n        ge=0,\n        le=100,\n    )\n</code></pre>"},{"location":"checks_manifest/#manifest.check_models.CheckModelsTestCoverage.name","title":"<code>name: Literal['check_model_test_coverage']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.CheckModelsTestCoverage.min_model_test_coverage_pct","title":"<code>min_model_test_coverage_pct: int = Field(default=100, description='The minimum percentage of models that must have at least one test. Default: 100', ge=0, le=100)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_models.check_model_test_coverage","title":"<code>check_model_test_coverage</code>","text":"<p>Set the minimum percentage of models that have at least one test.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_models.py</code> <pre><code>@bouncer_check\ndef check_model_test_coverage(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    tests: List[DbtBouncerModel],\n    min_model_test_coverage_pct: Union[int, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Set the minimum percentage of models that have at least one test.\n    \"\"\"\n\n    num_models = len(models)\n    models_with_tests = []\n    for model in models:\n        for test in tests:\n            if model.unique_id in test.depends_on.nodes:\n                models_with_tests.append(model.unique_id)\n    num_models_with_tests = len(set(models_with_tests))\n    model_test_coverage_pct = (num_models_with_tests / num_models) * 100\n\n    assert (\n        model_test_coverage_pct &gt;= min_model_test_coverage_pct  # type: ignore[operator]\n    ), f\"Only {model_test_coverage_pct}% of models have at least one test, this is less than the permitted minimum of {min_model_test_coverage_pct}%.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources","title":"<code>check_sources</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.CheckSourceDescriptionPopulated","title":"<code>CheckSourceDescriptionPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceDescriptionPopulated(BaseCheck):\n    name: Literal[\"check_source_description_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceDescriptionPopulated.name","title":"<code>name: Literal['check_source_description_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_description_populated","title":"<code>check_source_description_populated</code>","text":"<p>Sources must have a populated description.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_description_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated description.\n    \"\"\"\n\n    assert (\n        len(source.description.strip()) &gt; 4\n    ), f\"`{source.unique_id}` does not have a populated description.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceFreshnessPopulated","title":"<code>CheckSourceFreshnessPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceFreshnessPopulated(BaseCheck):\n    name: Literal[\"check_source_freshness_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceFreshnessPopulated.name","title":"<code>name: Literal['check_source_freshness_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_freshness_populated","title":"<code>check_source_freshness_populated</code>","text":"<p>Sources must have a populated freshness.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_freshness_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated freshness.\n    \"\"\"\n\n    assert (\n        source.freshness.error_after.count is not None\n        and source.freshness.error_after.period is not None\n    ) or (\n        source.freshness.warn_after.count is not None\n        and source.freshness.warn_after.period is not None\n    ), f\"`{source.unique_id}` does not have a populated freshness.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasMetaKeys","title":"<code>CheckSourceHasMetaKeys</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasMetaKeys(BaseCheck):\n    keys: Optional[Union[Dict[str, Any], List[Any]]]\n    name: Literal[\"check_source_has_meta_keys\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasMetaKeys.keys","title":"<code>keys: Optional[Union[Dict[str, Any], List[Any]]]</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasMetaKeys.name","title":"<code>name: Literal['check_source_has_meta_keys']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_has_meta_keys","title":"<code>check_source_has_meta_keys</code>","text":"<p>The <code>meta</code> config for sources must have the specified keys.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_has_meta_keys(\n    request,\n    keys: Union[Dict[str, Dict[str, str]], None] = None,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The `meta` config for sources must have the specified keys.\n    \"\"\"\n\n    missing_keys = find_missing_meta_keys(\n        meta_config=source.meta,\n        required_keys=keys,\n    )\n    assert (\n        missing_keys == []\n    ), f\"`{source.unique_id}` is missing the following keys from the `meta` config: {[x.replace('&gt;&gt;', '') for x in missing_keys]}\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasTags","title":"<code>CheckSourceHasTags</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceHasTags(BaseCheck):\n    name: Literal[\"check_source_has_tags\"]\n    tags: List[str] = Field(default=[], description=\"List of tags to check for.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasTags.name","title":"<code>name: Literal['check_source_has_tags']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.CheckSourceHasTags.tags","title":"<code>tags: List[str] = Field(default=[], description='List of tags to check for.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_has_tags","title":"<code>check_source_has_tags</code>","text":"<p>Sources must have the specified tags.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_has_tags(\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    tags: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must have the specified tags.\n    \"\"\"\n\n    missing_tags = [tag for tag in tags if tag not in source.tags]\n    assert not missing_tags, f\"`{source.unique_id}` is missing required tags: {missing_tags}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceLoaderPopulated","title":"<code>CheckSourceLoaderPopulated</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceLoaderPopulated(BaseCheck):\n    name: Literal[\"check_source_loader_populated\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceLoaderPopulated.name","title":"<code>name: Literal['check_source_loader_populated']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_loader_populated","title":"<code>check_source_loader_populated</code>","text":"<p>Sources must have a populated loader.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_loader_populated(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources must have a populated loader.\n    \"\"\"\n\n    assert source.loader != \"\", f\"`{source.unique_id}` does not have a populated loader.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceNames","title":"<code>CheckSourceNames</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNames(BaseCheck):\n    name: Literal[\"check_source_names\"]\n    source_name_pattern: str = Field(description=\"Regexp the source name must match.\")\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceNames.name","title":"<code>name: Literal['check_source_names']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.CheckSourceNames.source_name_pattern","title":"<code>source_name_pattern: str = Field(description='Regexp the source name must match.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_names","title":"<code>check_source_names</code>","text":"<p>Sources must have a name that matches the supplied regex.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_names(\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    source_name_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must have a name that matches the supplied regex.\n    \"\"\"\n\n    assert (\n        re.compile(source_name_pattern.strip()).match(source.name) is not None\n    ), f\"`{source.unique_id.split('.')[0]}` does not match the supplied regex `({source_name_pattern.strip()})`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceNotOrphaned","title":"<code>CheckSourceNotOrphaned</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceNotOrphaned(BaseCheck):\n    name: Literal[\"check_source_not_orphaned\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceNotOrphaned.name","title":"<code>name: Literal['check_source_not_orphaned']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_not_orphaned","title":"<code>check_source_not_orphaned</code>","text":"<p>Sources must be referenced in at least one model.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_not_orphaned(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources must be referenced in at least one model.\n    \"\"\"\n\n    num_refs = sum(source.unique_id in model.depends_on.nodes for model in models)\n    assert (\n        num_refs &gt;= 1\n    ), f\"Source `{source.unique_id}` is orphaned, i.e. not referenced by any model.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourcePropertyFileLocation","title":"<code>CheckSourcePropertyFileLocation</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourcePropertyFileLocation(BaseCheck):\n    name: Literal[\"check_source_property_file_location\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourcePropertyFileLocation.name","title":"<code>name: Literal['check_source_property_file_location']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_property_file_location","title":"<code>check_source_property_file_location</code>","text":"<p>Source properties files must follow the guidance provided by dbt here.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_property_file_location(\n    request: TopRequest, source: Union[DbtBouncerSource, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Source properties files must follow the guidance provided by dbt [here](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview).\n    \"\"\"\n\n    path_cleaned = source.path.replace(\"models/staging\", \"\")\n    expected_substring = \"_\".join(path_cleaned.split(\"/\")[:-1])\n\n    assert path_cleaned.split(\"/\")[-1].startswith(\n        \"_\"\n    ), f\"The properties file for `{source.unique_id}` (`{path_cleaned}`) does not start with an underscore.\"\n    assert (\n        expected_substring in path_cleaned\n    ), f\"The properties file for `{source.unique_id}` (`{path_cleaned}`) does not contain the expected substring (`{expected_substring}`).\"\n    assert path_cleaned.split(\"/\")[-1].endswith(\n        \"__sources.yml\"\n    ), f\"The properties file for `{source.unique_id}` (`{path_cleaned}`) does not end with `__sources.yml`.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceUsedByModelsInSameDirectory","title":"<code>CheckSourceUsedByModelsInSameDirectory</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByModelsInSameDirectory(BaseCheck):\n    name: Literal[\"check_source_used_by_models_in_same_directory\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceUsedByModelsInSameDirectory.name","title":"<code>name: Literal['check_source_used_by_models_in_same_directory']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_used_by_models_in_same_directory","title":"<code>check_source_used_by_models_in_same_directory</code>","text":"<p>Sources can only be referenced by models that are located in the same directory where the source is defined.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_used_by_models_in_same_directory(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Sources can only be referenced by models that are located in the same directory where the source is defined.\n    \"\"\"\n\n    reffed_models_not_in_same_dir = []\n    for model in models:\n        if (\n            source.unique_id in model.depends_on.nodes\n            and model.path.split(\"/\")[:-1] != source.path.split(\"/\")[1:-1]\n        ):\n            reffed_models_not_in_same_dir.append(model.unique_id.split(\".\")[0])\n\n    assert (\n        len(reffed_models_not_in_same_dir) == 0\n    ), f\"Source `{source.unique_id}` is referenced by models defined in a different directory: {reffed_models_not_in_same_dir}\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceUsedByOnlyOneModel","title":"<code>CheckSourceUsedByOnlyOneModel</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>class CheckSourceUsedByOnlyOneModel(BaseCheck):\n    name: Literal[\"check_source_used_by_only_one_model\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_sources.CheckSourceUsedByOnlyOneModel.name","title":"<code>name: Literal['check_source_used_by_only_one_model']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_sources.check_source_used_by_only_one_model","title":"<code>check_source_used_by_only_one_model</code>","text":"<p>Each source can be referenced by a maximum of one model.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_sources.py</code> <pre><code>@pytest.mark.iterate_over_sources\n@bouncer_check\ndef check_source_used_by_only_one_model(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    source: Union[DbtBouncerSource, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each source can be referenced by a maximum of one model.\n    \"\"\"\n\n    num_refs = sum(source.unique_id in model.depends_on.nodes for model in models)\n    assert num_refs &lt;= 1, f\"Source `{source.unique_id}` is referenced by more than one model.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage","title":"<code>check_lineage</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels","title":"<code>CheckLineagePermittedUpstreamModels</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineagePermittedUpstreamModels(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    include: str = Field(\n        description=\"Regex pattern to match the model path. Only model paths that match the pattern will be checked.\"\n    )\n    index: Optional[int] = Field(\n        default=None, description=\"Index to uniquely identify the check, calculated at runtime.\"\n    )\n    name: Literal[\"check_lineage_permitted_upstream_models\"]\n    upstream_path_pattern: str = Field(\n        description=\"Regexp pattern to match the upstream model(s) path.\"\n    )\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels.include","title":"<code>include: str = Field(description='Regex pattern to match the model path. Only model paths that match the pattern will be checked.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels.index","title":"<code>index: Optional[int] = Field(default=None, description='Index to uniquely identify the check, calculated at runtime.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels.name","title":"<code>name: Literal['check_lineage_permitted_upstream_models']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineagePermittedUpstreamModels.upstream_path_pattern","title":"<code>upstream_path_pattern: str = Field(description='Regexp pattern to match the upstream model(s) path.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.check_lineage_permitted_upstream_models","title":"<code>check_lineage_permitted_upstream_models</code>","text":"<p>Upstream models must have a path that matches the provided <code>upstream_path_pattern</code>.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_permitted_upstream_models(\n    manifest_obj: DbtBouncerManifest,\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    model: Union[DbtBouncerModel, None] = None,\n    upstream_path_pattern: Union[None, str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Upstream models must have a path that matches the provided `upstream_path_pattern`.\n    \"\"\"\n\n    upstream_models = [\n        x\n        for x in model.depends_on.nodes\n        if x.split(\".\")[0] == \"model\"\n        and x.split(\".\")[1] == manifest_obj.manifest.metadata.project_name\n    ]\n    not_permitted_upstream_models = [\n        upstream_model\n        for upstream_model in upstream_models\n        if re.compile(upstream_path_pattern.strip()).match(\n            [m for m in models if m.unique_id == upstream_model][0].path\n        )\n        is None\n    ]\n    assert (\n        not not_permitted_upstream_models\n    ), f\"`{model.unique_id.split('.')[-1]}` references upstream models that are not permitted: {[m.split('.')[-1] for m in not_permitted_upstream_models]}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSeedCannotBeUsed","title":"<code>CheckLineageSeedCannotBeUsed</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSeedCannotBeUsed(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    include: str = Field(\n        description=\"Regex pattern to match the model path. Only model paths that match the pattern will be checked.\"\n    )\n    index: Optional[int] = Field(\n        default=None, description=\"Index to uniquely identify the check, calculated at runtime.\"\n    )\n    name: Literal[\"check_lineage_seed_cannot_be_used\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSeedCannotBeUsed.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSeedCannotBeUsed.include","title":"<code>include: str = Field(description='Regex pattern to match the model path. Only model paths that match the pattern will be checked.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSeedCannotBeUsed.index","title":"<code>index: Optional[int] = Field(default=None, description='Index to uniquely identify the check, calculated at runtime.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSeedCannotBeUsed.name","title":"<code>name: Literal['check_lineage_seed_cannot_be_used']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.check_lineage_seed_cannot_be_used","title":"<code>check_lineage_seed_cannot_be_used</code>","text":"<p>Seed cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_seed_cannot_be_used(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Seed cannot be referenced in models with a path that matches the specified `include` config.\n    \"\"\"\n\n    assert not [\n        x for x in model.depends_on.nodes if x.split(\".\")[0] == \"seed\"\n    ], f\"`{model.unique_id.split('.')[-1]}` references a seed even though this is not permitted.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSourceCannotBeUsed","title":"<code>CheckLineageSourceCannotBeUsed</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>class CheckLineageSourceCannotBeUsed(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    include: str = Field(\n        description=\"Regex pattern to match the model path. Only model paths that match the pattern will be checked.\"\n    )\n    index: Optional[int] = Field(\n        default=None, description=\"Index to uniquely identify the check, calculated at runtime.\"\n    )\n    name: Literal[\"check_lineage_source_cannot_be_used\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSourceCannotBeUsed.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSourceCannotBeUsed.include","title":"<code>include: str = Field(description='Regex pattern to match the model path. Only model paths that match the pattern will be checked.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSourceCannotBeUsed.index","title":"<code>index: Optional[int] = Field(default=None, description='Index to uniquely identify the check, calculated at runtime.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.CheckLineageSourceCannotBeUsed.name","title":"<code>name: Literal['check_lineage_source_cannot_be_used']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_lineage.check_lineage_source_cannot_be_used","title":"<code>check_lineage_source_cannot_be_used</code>","text":"<p>Sources cannot be referenced in models with a path that matches the specified <code>include</code> config.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_lineage.py</code> <pre><code>@pytest.mark.iterate_over_models\n@bouncer_check\ndef check_lineage_source_cannot_be_used(\n    request: TopRequest, model: Union[DbtBouncerModel, None] = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Sources cannot be referenced in models with a path that matches the specified `include` config.\n    \"\"\"\n\n    assert not [\n        x for x in model.depends_on.nodes if x.split(\".\")[0] == \"source\"\n    ], f\"`{model.unique_id.split('.')[-1]}` references a source even though this is not permitted.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_exposures","title":"<code>check_exposures</code>","text":""},{"location":"checks_manifest/#manifest.check_exposures.CheckExposureOnNonPublicModels","title":"<code>CheckExposureOnNonPublicModels</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnNonPublicModels(BaseCheck):\n    name: Literal[\"check_exposure_based_on_non_public_models\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_exposures.CheckExposureOnNonPublicModels.name","title":"<code>name: Literal['check_exposure_based_on_non_public_models']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_exposures.check_exposure_based_on_non_public_models","title":"<code>check_exposure_based_on_non_public_models</code>","text":"<p>Exposures should be based on public models only.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>@pytest.mark.iterate_over_exposures\n@bouncer_check\ndef check_exposure_based_on_non_public_models(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    exposure: Union[Exposures, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Exposures should be based on public models only.\n    \"\"\"\n\n    non_public_upstream_dependencies = []\n    for model in exposure.depends_on.nodes:\n        if (\n            model.split(\".\")[0] == \"model\"\n            and model.split(\".\")[1] == exposure.unique_id.split(\".\")[1]\n        ):\n            model = [m for m in models if m.unique_id == model][0]\n            if model.access.value != \"public\":\n                non_public_upstream_dependencies.append(model.unique_id.split(\".\")[-1])\n\n    assert (\n        not non_public_upstream_dependencies\n    ), f\"`{exposure.unique_id.split('.')[-1]}` is based on a model(s) that is not public: {non_public_upstream_dependencies}.\"\n</code></pre>"},{"location":"checks_manifest/#manifest.check_exposures.CheckExposureOnView","title":"<code>CheckExposureOnView</code>","text":"Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>class CheckExposureOnView(BaseCheck):\n    materializations_to_include: List[str] = Field(\n        default=[\"ephemeral\", \"view\"],\n        description=\"List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.\",\n    )\n    name: Literal[\"check_exposure_based_on_view\"]\n</code></pre>"},{"location":"checks_manifest/#manifest.check_exposures.CheckExposureOnView.materializations_to_include","title":"<code>materializations_to_include: List[str] = Field(default=['ephemeral', 'view'], description='List of materializations to include in the check. If not provided, defaults to `ephemeral` and `view`.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_exposures.CheckExposureOnView.name","title":"<code>name: Literal['check_exposure_based_on_view']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_manifest/#manifest.check_exposures.check_exposure_based_on_view","title":"<code>check_exposure_based_on_view</code>","text":"<p>Exposures should not be based on views.</p> Source code in <code>src/dbt_bouncer/checks/manifest/check_exposures.py</code> <pre><code>@pytest.mark.iterate_over_exposures\n@bouncer_check\ndef check_exposure_based_on_view(\n    models: List[DbtBouncerModel],\n    request: TopRequest,\n    exposure: Union[Exposures, None] = None,\n    materializations_to_include: Union[List[str], None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Exposures should not be based on views.\n    \"\"\"\n\n    non_table_upstream_dependencies = []\n    for model in exposure.depends_on.nodes:\n        if (\n            model.split(\".\")[0] == \"model\"\n            and model.split(\".\")[1] == exposure.unique_id.split(\".\")[1]\n        ):\n            model = [m for m in models if m.unique_id == model][0]\n            if model.config.materialized in materializations_to_include:  # type: ignore[operator]\n                non_table_upstream_dependencies.append(model.unique_id.split(\".\")[-1])\n\n    assert (\n        not non_table_upstream_dependencies\n    ), f\"`{exposure.unique_id.split('.')[-1]}` is based on a model that is not a table: {non_table_upstream_dependencies}.\"\n</code></pre>"},{"location":"checks_run_results/","title":"Run Results Checks","text":""},{"location":"checks_run_results/#run_results.check_run_results","title":"<code>check_run_results</code>","text":""},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxGigabytesBilled","title":"<code>CheckRunResultsMaxGigabytesBilled</code>","text":"Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxGigabytesBilled(BaseCheck):\n    max_gigabytes_billed: float = Field(\n        description=\"The maximum gigagbytes billed allowed for a node.\"\n    )\n    name: Literal[\"check_run_results_max_gigabytes_billed\"]\n</code></pre>"},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxGigabytesBilled.max_gigabytes_billed","title":"<code>max_gigabytes_billed: float = Field(description='The maximum gigagbytes billed allowed for a node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxGigabytesBilled.name","title":"<code>name: Literal['check_run_results_max_gigabytes_billed']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_run_results/#run_results.check_run_results.check_run_results_max_gigabytes_billed","title":"<code>check_run_results_max_gigabytes_billed</code>","text":"<p>Each result can have a maximum number of gigabytes billed. Note that this only works for the <code>dbt-bigquery</code> adapter.</p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>@pytest.mark.iterate_over_run_results\n@bouncer_check\ndef check_run_results_max_gigabytes_billed(\n    request: TopRequest,\n    max_gigabytes_billed: Union[float, None] = None,\n    run_result: Union[DbtBouncerResult, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each result can have a maximum number of gigabytes billed. Note that this only works for the `dbt-bigquery` adapter.\n    \"\"\"\n\n    try:\n        gigabytes_billed = run_result.adapter_response[\"bytes_billed\"] / (1000**3)\n    except KeyError:\n        raise RuntimeError(\n            \"`bytes_billed` not found in adapter response. Are you using the `dbt-bigquery` adapter?\"\n        )\n\n    assert (\n        gigabytes_billed &lt; max_gigabytes_billed\n    ), f\"`{run_result.unique_id.split('.')[-2]}` results in ({gigabytes_billed} billed bytes, this is greater than permitted ({max_gigabytes_billed}).\"\n</code></pre>"},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxExecutionTime","title":"<code>CheckRunResultsMaxExecutionTime</code>","text":"Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>class CheckRunResultsMaxExecutionTime(BaseCheck):\n    max_execution_time: float = Field(\n        description=\"The maximum execution time (seconds) allowed for a node.\"\n    )\n    name: Literal[\"check_run_results_max_execution_time\"]\n</code></pre>"},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxExecutionTime.max_execution_time","title":"<code>max_execution_time: float = Field(description='The maximum execution time (seconds) allowed for a node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"checks_run_results/#run_results.check_run_results.CheckRunResultsMaxExecutionTime.name","title":"<code>name: Literal['check_run_results_max_execution_time']</code>  <code>instance-attribute</code>","text":""},{"location":"checks_run_results/#run_results.check_run_results.check_run_results_max_execution_time","title":"<code>check_run_results_max_execution_time</code>","text":"<p>Each result can take a maximum duration (seconds).</p> Source code in <code>src/dbt_bouncer/checks/run_results/check_run_results.py</code> <pre><code>@pytest.mark.iterate_over_run_results\n@bouncer_check\ndef check_run_results_max_execution_time(\n    request: TopRequest,\n    max_execution_time: Union[float, None] = None,\n    run_result: Union[DbtBouncerResult, None] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Each result can take a maximum duration (seconds).\n    \"\"\"\n\n    assert (\n        run_result.execution_time &lt;= max_execution_time\n    ), f\"`{run_result.unique_id.split('.')[-1]}` has an execution time ({run_result.execution_time} greater than permitted ({max_execution_time}s).\"\n</code></pre>"},{"location":"config_file/","title":"Config file","text":"<p><code>dbt-bouncer</code> requires a config file to be provided. This file configures what checks are run. Here is an example config file:</p> <pre><code>dbt_artifacts_dir: target # [Optional] Directory where the dbt artifacts exists, generally the `target` directory inside a dbt project. Defaults to `./target`.\n\nmanifest_checks:\n  - name: check_macro_name_matches_file_name\n  - name: check_model_names\n    include: ^staging\n    model_name_pattern: ^stg_\n</code></pre> <p>For more example config files, see here.</p> <p>Note that the config can also be passed via a <code>pyproject.toml</code> file: <pre><code>[tool.dbt-bouncer]\ndbt_artifacts_dir = \"target\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_macro_name_matches_file_name\"\n\n[[tool.dbt-bouncer.manifest_checks]]\nname = \"check_model_names\"\ninclude = \"^staging\"\nmodel_name_pattern = \"^stg_\"\n</code></pre></p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#how-to-run-dbt-bouncer","title":"How to run <code>dbt-bouncer</code>","text":"<ol> <li> <p>Generate dbt artifacts by running a dbt command:</p> <ul> <li><code>dbt parse</code> to generate a <code>manifest.json</code> artifact.</li> <li><code>dbt docs generate</code> to generate a <code>catalog.json</code> artifact (necessary if you are using catalog checks).</li> </ul> </li> <li> <p>Create a <code>dbt-bouncer.yml</code> config file, details here.</p> </li> <li> <p>Run <code>dbt-bouncer</code> to validate that your conventions are being maintained.</p> </li> </ol>"},{"location":"getting_started/#python","title":"Python","text":"<p>Install from pypi.org:</p> <pre><code>pip install dbt-bouncer\n</code></pre> <p>Run:</p> <pre><code>dbt-bouncer --config-file &lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre> <pre><code>Running dbt-bouncer (X.X.X)...\nLoaded config from dbt-bouncer-example.yml...\nValidating conf...\n</code></pre>"},{"location":"getting_started/#github-actions","title":"GitHub Actions","text":"<p>Run <code>dbt-bouncer</code> as part of your CI pipeline: <pre><code>steps:\n    ...\n\n    - uses: godatadriven/dbt-bouncer@vX.X\n      with:\n        config-file: ./&lt;PATH_TO_CONFIG_FILE&gt;\n        output-file: results.json # optional, default does not save a results file\n        send-pr-comment: true # optional, defaults to true\n\n    ...\n</code></pre></p> <p>We recommend pinning both a major and minor version number.</p>"},{"location":"getting_started/#docker","title":"Docker","text":"<p>Run <code>dbt-bouncer</code> via Docker:</p> <pre><code>docker run --rm \\\n    --volume \"$PWD\":/app \\\n    ghcr.io/godatadriven/dbt-bouncer:vX.X.X \\\n    --config-file /app/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"},{"location":"getting_started/#pex","title":"Pex","text":"<p>You can also run the <code>.pex</code> (Python EXecutable) artifact directly once you have a python executable (3.8 -&gt; 3.12) installed:</p> <pre><code>wget https://github.com/godatadriven/dbt-bouncer/releases/download/vX.X.X/dbt-bouncer.pex -O dbt-bouncer.pex\n\npython dbt-bouncer.pex --config-file $PWD/&lt;PATH_TO_CONFIG_FILE&gt;\n</code></pre>"}]}